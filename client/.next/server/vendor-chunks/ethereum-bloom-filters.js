"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereum-bloom-filters";
exports.ids = ["vendor-chunks/ethereum-bloom-filters"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereum-bloom-filters/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethereum-bloom-filters/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/ethereum-bloom-filters/dist/utils.js\");\n/**\r\n * Returns true if the bloom is a valid bloom\r\n * @param bloom The bloom\r\n */ function isBloom(bloom) {\n    if (typeof bloom !== \"string\") {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n        return false;\n    }\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n        return true;\n    }\n    return false;\n}\nexports.isBloom = isBloom;\n/**\r\n * Returns true if the value is part of the given bloom\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param value The value\r\n */ function isInBloom(bloom, value) {\n    if (typeof value === \"object\" && value.constructor === Uint8Array) {\n        value = utils_1.bytesToHex(value);\n    }\n    const hash = utils_1.keccak256(value).replace(\"0x\", \"\");\n    for(let i = 0; i < 12; i += 4){\n        // calculate bit position in bloom filter that must be active\n        const bitpos = (parseInt(hash.substr(i, 2), 16) << 8) + parseInt(hash.substr(i + 2, 2), 16) & 2047;\n        // test if bitpos in bloom is active\n        const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));\n        const offset = 1 << bitpos % 4;\n        if ((code & offset) !== offset) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isInBloom = isInBloom;\n/**\r\n * Code points to int\r\n * @param codePoint The code point\r\n */ function codePointToInt(codePoint) {\n    if (codePoint >= 48 && codePoint <= 57) {\n        /* ['0'..'9'] -> [0..9] */ return codePoint - 48;\n    }\n    if (codePoint >= 65 && codePoint <= 70) {\n        /* ['A'..'F'] -> [10..15] */ return codePoint - 55;\n    }\n    if (codePoint >= 97 && codePoint <= 102) {\n        /* ['a'..'f'] -> [10..15] */ return codePoint - 87;\n    }\n    throw new Error(\"invalid bloom\");\n}\n/**\r\n * Returns true if the ethereum users address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param address the address to test\r\n */ function isUserEthereumAddressInBloom(bloom, ethereumAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error(\"Invalid bloom given\");\n    }\n    if (!isAddress(ethereumAddress)) {\n        throw new Error(`Invalid ethereum address given: \"${ethereumAddress}\"`);\n    }\n    // you have to pad the ethereum address to 32 bytes\n    // else the bloom filter does not work\n    // this is only if your matching the USERS\n    // ethereum address. Contract address do not need this\n    // hence why we have 2 methods\n    // (0x is not in the 2nd parameter of padleft so 64 chars is fine)\n    const address = utils_1.padLeft(ethereumAddress, 64);\n    return isInBloom(bloom, address);\n}\nexports.isUserEthereumAddressInBloom = isUserEthereumAddressInBloom;\n/**\r\n * Returns true if the contract address is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param contractAddress the contract address to test\r\n */ function isContractAddressInBloom(bloom, contractAddress) {\n    if (!isBloom(bloom)) {\n        throw new Error(\"Invalid bloom given\");\n    }\n    if (!isAddress(contractAddress)) {\n        throw new Error(`Invalid contract address given: \"${contractAddress}\"`);\n    }\n    return isInBloom(bloom, contractAddress);\n}\nexports.isContractAddressInBloom = isContractAddressInBloom;\n/**\r\n * Returns true if the topic is part of the given bloom.\r\n * note: false positives are possible.\r\n * @param bloom encoded bloom\r\n * @param topic the topic encoded hex\r\n */ function isTopicInBloom(bloom, topic) {\n    if (!isBloom(bloom)) {\n        throw new Error(\"Invalid bloom given\");\n    }\n    if (!isTopic(topic)) {\n        throw new Error(\"Invalid topic\");\n    }\n    return isInBloom(bloom, topic);\n}\nexports.isTopicInBloom = isTopicInBloom;\n/**\r\n * Checks if its a valid topic\r\n * @param topic encoded hex topic\r\n */ function isTopic(topic) {\n    if (typeof topic !== \"string\") {\n        return false;\n    }\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n        return false;\n    } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n        return true;\n    }\n    return false;\n}\nexports.isTopic = isTopic;\n/**\r\n * Is valid address\r\n * @param address The address\r\n */ function isAddress(address) {\n    if (typeof address !== \"string\") {\n        return false;\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        return true;\n    }\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        return true;\n    }\n    return false;\n}\nexports.isAddress = isAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tYmxvb20tZmlsdGVycy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLDBFQUFTO0FBQ2pDOzs7Q0FHQyxHQUNELFNBQVNDLFFBQVFDLEtBQUs7SUFDbEIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBTztJQUNYO0lBQ0EsSUFBSSxDQUFDLHdCQUF3QkMsSUFBSSxDQUFDRCxRQUFRO1FBQ3RDLE9BQU87SUFDWDtJQUNBLElBQUksdUJBQXVCQyxJQUFJLENBQUNELFVBQzVCLHVCQUF1QkMsSUFBSSxDQUFDRCxRQUFRO1FBQ3BDLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBTCxlQUFlLEdBQUdJO0FBQ2xCOzs7OztDQUtDLEdBQ0QsU0FBU0csVUFBVUYsS0FBSyxFQUFFSixLQUFLO0lBQzNCLElBQUksT0FBT0EsVUFBVSxZQUFZQSxNQUFNTyxXQUFXLEtBQUtDLFlBQVk7UUFDL0RSLFFBQVFDLFFBQVFRLFVBQVUsQ0FBQ1Q7SUFDL0I7SUFDQSxNQUFNVSxPQUFPVCxRQUFRVSxTQUFTLENBQUNYLE9BQU9ZLE9BQU8sQ0FBQyxNQUFNO0lBQ3BELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssRUFBRztRQUM1Qiw2REFBNkQ7UUFDN0QsTUFBTUMsU0FBUyxDQUFFQyxTQUFTTCxLQUFLTSxNQUFNLENBQUNILEdBQUcsSUFBSSxPQUFPLEtBQ2hERSxTQUFTTCxLQUFLTSxNQUFNLENBQUNILElBQUksR0FBRyxJQUFJLE1BQ2hDO1FBQ0osb0NBQW9DO1FBQ3BDLE1BQU1JLE9BQU9DLGVBQWVkLE1BQU1lLFVBQVUsQ0FBQ2YsTUFBTWdCLE1BQU0sR0FBRyxJQUFJQyxLQUFLQyxLQUFLLENBQUNSLFNBQVM7UUFDcEYsTUFBTVMsU0FBUyxLQUFLVCxTQUFTO1FBQzdCLElBQUksQ0FBQ0csT0FBT00sTUFBSyxNQUFPQSxRQUFRO1lBQzVCLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0F4QixpQkFBaUIsR0FBR087QUFDcEI7OztDQUdDLEdBQ0QsU0FBU1ksZUFBZU0sU0FBUztJQUM3QixJQUFJQSxhQUFhLE1BQU1BLGFBQWEsSUFBSTtRQUNwQyx3QkFBd0IsR0FDeEIsT0FBT0EsWUFBWTtJQUN2QjtJQUNBLElBQUlBLGFBQWEsTUFBTUEsYUFBYSxJQUFJO1FBQ3BDLDBCQUEwQixHQUMxQixPQUFPQSxZQUFZO0lBQ3ZCO0lBQ0EsSUFBSUEsYUFBYSxNQUFNQSxhQUFhLEtBQUs7UUFDckMsMEJBQTBCLEdBQzFCLE9BQU9BLFlBQVk7SUFDdkI7SUFDQSxNQUFNLElBQUlDLE1BQU07QUFDcEI7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLDZCQUE2QnRCLEtBQUssRUFBRXVCLGVBQWU7SUFDeEQsSUFBSSxDQUFDeEIsUUFBUUMsUUFBUTtRQUNqQixNQUFNLElBQUlxQixNQUFNO0lBQ3BCO0lBQ0EsSUFBSSxDQUFDRyxVQUFVRCxrQkFBa0I7UUFDN0IsTUFBTSxJQUFJRixNQUFNLENBQUMsaUNBQWlDLEVBQUVFLGdCQUFnQixDQUFDLENBQUM7SUFDMUU7SUFDQSxtREFBbUQ7SUFDbkQsc0NBQXNDO0lBQ3RDLDBDQUEwQztJQUMxQyxzREFBc0Q7SUFDdEQsOEJBQThCO0lBQzlCLGtFQUFrRTtJQUNsRSxNQUFNRSxVQUFVNUIsUUFBUTZCLE9BQU8sQ0FBQ0gsaUJBQWlCO0lBQ2pELE9BQU9yQixVQUFVRixPQUFPeUI7QUFDNUI7QUFDQTlCLG9DQUFvQyxHQUFHMkI7QUFDdkM7Ozs7O0NBS0MsR0FDRCxTQUFTSyx5QkFBeUIzQixLQUFLLEVBQUU0QixlQUFlO0lBQ3BELElBQUksQ0FBQzdCLFFBQVFDLFFBQVE7UUFDakIsTUFBTSxJQUFJcUIsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ0csVUFBVUksa0JBQWtCO1FBQzdCLE1BQU0sSUFBSVAsTUFBTSxDQUFDLGlDQUFpQyxFQUFFTyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzFFO0lBQ0EsT0FBTzFCLFVBQVVGLE9BQU80QjtBQUM1QjtBQUNBakMsZ0NBQWdDLEdBQUdnQztBQUNuQzs7Ozs7Q0FLQyxHQUNELFNBQVNFLGVBQWU3QixLQUFLLEVBQUU4QixLQUFLO0lBQ2hDLElBQUksQ0FBQy9CLFFBQVFDLFFBQVE7UUFDakIsTUFBTSxJQUFJcUIsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ1UsUUFBUUQsUUFBUTtRQUNqQixNQUFNLElBQUlULE1BQU07SUFDcEI7SUFDQSxPQUFPbkIsVUFBVUYsT0FBTzhCO0FBQzVCO0FBQ0FuQyxzQkFBc0IsR0FBR2tDO0FBQ3pCOzs7Q0FHQyxHQUNELFNBQVNFLFFBQVFELEtBQUs7SUFDbEIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBTztJQUNYO0lBQ0EsSUFBSSxDQUFDLHVCQUF1QjdCLElBQUksQ0FBQzZCLFFBQVE7UUFDckMsT0FBTztJQUNYLE9BQ0ssSUFBSSxzQkFBc0I3QixJQUFJLENBQUM2QixVQUNoQyxzQkFBc0I3QixJQUFJLENBQUM2QixRQUFRO1FBQ25DLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBbkMsZUFBZSxHQUFHb0M7QUFDbEI7OztDQUdDLEdBQ0QsU0FBU1AsVUFBVUMsT0FBTztJQUN0QixJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUM3QixPQUFPO0lBQ1g7SUFDQSxJQUFJQSxRQUFRTyxLQUFLLENBQUMsMkJBQTJCO1FBQ3pDLE9BQU87SUFDWDtJQUNBLElBQUlQLFFBQVFPLEtBQUssQ0FBQyxtQ0FBbUM7UUFDakQsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0FyQyxpQkFBaUIsR0FBRzZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWJsb29tLWZpbHRlcnMvZGlzdC9pbmRleC5qcz83YjEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmxvb20gaXMgYSB2YWxpZCBibG9vbVxyXG4gKiBAcGFyYW0gYmxvb20gVGhlIGJsb29tXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jsb29tKGJsb29tKSB7XHJcbiAgICBpZiAodHlwZW9mIGJsb29tICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghL14oMHgpP1swLTlhLWZdezUxMn0kL2kudGVzdChibG9vbSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoL14oMHgpP1swLTlhLWZdezUxMn0kLy50ZXN0KGJsb29tKSB8fFxyXG4gICAgICAgIC9eKDB4KT9bMC05QS1GXXs1MTJ9JC8udGVzdChibG9vbSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmlzQmxvb20gPSBpc0Jsb29tO1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxyXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxyXG4gKiBAcGFyYW0gYmxvb20gZW5jb2RlZCBibG9vbVxyXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0luQmxvb20oYmxvb20sIHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkge1xyXG4gICAgICAgIHZhbHVlID0gdXRpbHNfMS5ieXRlc1RvSGV4KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGhhc2ggPSB1dGlsc18xLmtlY2NhazI1Nih2YWx1ZSkucmVwbGFjZSgnMHgnLCAnJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpICs9IDQpIHtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgYml0IHBvc2l0aW9uIGluIGJsb29tIGZpbHRlciB0aGF0IG11c3QgYmUgYWN0aXZlXHJcbiAgICAgICAgY29uc3QgYml0cG9zID0gKChwYXJzZUludChoYXNoLnN1YnN0cihpLCAyKSwgMTYpIDw8IDgpICtcclxuICAgICAgICAgICAgcGFyc2VJbnQoaGFzaC5zdWJzdHIoaSArIDIsIDIpLCAxNikpICZcclxuICAgICAgICAgICAgMjA0NztcclxuICAgICAgICAvLyB0ZXN0IGlmIGJpdHBvcyBpbiBibG9vbSBpcyBhY3RpdmVcclxuICAgICAgICBjb25zdCBjb2RlID0gY29kZVBvaW50VG9JbnQoYmxvb20uY2hhckNvZGVBdChibG9vbS5sZW5ndGggLSAxIC0gTWF0aC5mbG9vcihiaXRwb3MgLyA0KSkpO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDEgPDwgYml0cG9zICUgNDtcclxuICAgICAgICBpZiAoKGNvZGUgJiBvZmZzZXQpICE9PSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNJbkJsb29tID0gaXNJbkJsb29tO1xyXG4vKipcclxuICogQ29kZSBwb2ludHMgdG8gaW50XHJcbiAqIEBwYXJhbSBjb2RlUG9pbnQgVGhlIGNvZGUgcG9pbnRcclxuICovXHJcbmZ1bmN0aW9uIGNvZGVQb2ludFRvSW50KGNvZGVQb2ludCkge1xyXG4gICAgaWYgKGNvZGVQb2ludCA+PSA0OCAmJiBjb2RlUG9pbnQgPD0gNTcpIHtcclxuICAgICAgICAvKiBbJzAnLi4nOSddIC0+IFswLi45XSAqL1xyXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA0ODtcclxuICAgIH1cclxuICAgIGlmIChjb2RlUG9pbnQgPj0gNjUgJiYgY29kZVBvaW50IDw9IDcwKSB7XHJcbiAgICAgICAgLyogWydBJy4uJ0YnXSAtPiBbMTAuLjE1XSAqL1xyXG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA1NTtcclxuICAgIH1cclxuICAgIGlmIChjb2RlUG9pbnQgPj0gOTcgJiYgY29kZVBvaW50IDw9IDEwMikge1xyXG4gICAgICAgIC8qIFsnYScuLidmJ10gLT4gWzEwLi4xNV0gKi9cclxuICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gODc7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmxvb20nKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBldGhlcmV1bSB1c2VycyBhZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tLlxyXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxyXG4gKiBAcGFyYW0gYmxvb20gZW5jb2RlZCBibG9vbVxyXG4gKiBAcGFyYW0gYWRkcmVzcyB0aGUgYWRkcmVzcyB0byB0ZXN0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tKGJsb29tLCBldGhlcmV1bUFkZHJlc3MpIHtcclxuICAgIGlmICghaXNCbG9vbShibG9vbSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvb20gZ2l2ZW4nKTtcclxuICAgIH1cclxuICAgIGlmICghaXNBZGRyZXNzKGV0aGVyZXVtQWRkcmVzcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXRoZXJldW0gYWRkcmVzcyBnaXZlbjogXCIke2V0aGVyZXVtQWRkcmVzc31cImApO1xyXG4gICAgfVxyXG4gICAgLy8geW91IGhhdmUgdG8gcGFkIHRoZSBldGhlcmV1bSBhZGRyZXNzIHRvIDMyIGJ5dGVzXHJcbiAgICAvLyBlbHNlIHRoZSBibG9vbSBmaWx0ZXIgZG9lcyBub3Qgd29ya1xyXG4gICAgLy8gdGhpcyBpcyBvbmx5IGlmIHlvdXIgbWF0Y2hpbmcgdGhlIFVTRVJTXHJcbiAgICAvLyBldGhlcmV1bSBhZGRyZXNzLiBDb250cmFjdCBhZGRyZXNzIGRvIG5vdCBuZWVkIHRoaXNcclxuICAgIC8vIGhlbmNlIHdoeSB3ZSBoYXZlIDIgbWV0aG9kc1xyXG4gICAgLy8gKDB4IGlzIG5vdCBpbiB0aGUgMm5kIHBhcmFtZXRlciBvZiBwYWRsZWZ0IHNvIDY0IGNoYXJzIGlzIGZpbmUpXHJcbiAgICBjb25zdCBhZGRyZXNzID0gdXRpbHNfMS5wYWRMZWZ0KGV0aGVyZXVtQWRkcmVzcywgNjQpO1xyXG4gICAgcmV0dXJuIGlzSW5CbG9vbShibG9vbSwgYWRkcmVzcyk7XHJcbn1cclxuZXhwb3J0cy5pc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tID0gaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbTtcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJhY3QgYWRkcmVzcyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbS5cclxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cclxuICogQHBhcmFtIGJsb29tIGVuY29kZWQgYmxvb21cclxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyB0aGUgY29udHJhY3QgYWRkcmVzcyB0byB0ZXN0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb20oYmxvb20sIGNvbnRyYWN0QWRkcmVzcykge1xyXG4gICAgaWYgKCFpc0Jsb29tKGJsb29tKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9vbSBnaXZlbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FkZHJlc3MoY29udHJhY3RBZGRyZXNzKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb250cmFjdCBhZGRyZXNzIGdpdmVuOiBcIiR7Y29udHJhY3RBZGRyZXNzfVwiYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNJbkJsb29tKGJsb29tLCBjb250cmFjdEFkZHJlc3MpO1xyXG59XHJcbmV4cG9ydHMuaXNDb250cmFjdEFkZHJlc3NJbkJsb29tID0gaXNDb250cmFjdEFkZHJlc3NJbkJsb29tO1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0b3BpYyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbS5cclxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cclxuICogQHBhcmFtIGJsb29tIGVuY29kZWQgYmxvb21cclxuICogQHBhcmFtIHRvcGljIHRoZSB0b3BpYyBlbmNvZGVkIGhleFxyXG4gKi9cclxuZnVuY3Rpb24gaXNUb3BpY0luQmxvb20oYmxvb20sIHRvcGljKSB7XHJcbiAgICBpZiAoIWlzQmxvb20oYmxvb20pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJsb29tIGdpdmVuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVG9waWModG9waWMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRvcGljJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNJbkJsb29tKGJsb29tLCB0b3BpYyk7XHJcbn1cclxuZXhwb3J0cy5pc1RvcGljSW5CbG9vbSA9IGlzVG9waWNJbkJsb29tO1xyXG4vKipcclxuICogQ2hlY2tzIGlmIGl0cyBhIHZhbGlkIHRvcGljXHJcbiAqIEBwYXJhbSB0b3BpYyBlbmNvZGVkIGhleCB0b3BpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNUb3BpYyh0b3BpYykge1xyXG4gICAgaWYgKHR5cGVvZiB0b3BpYyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs2NH0kL2kudGVzdCh0b3BpYykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NjR9JC8udGVzdCh0b3BpYykgfHxcclxuICAgICAgICAvXigweCk/WzAtOUEtRl17NjR9JC8udGVzdCh0b3BpYykpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmlzVG9waWMgPSBpc1RvcGljO1xyXG4vKipcclxuICogSXMgdmFsaWQgYWRkcmVzc1xyXG4gKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzc1xyXG4gKi9cclxuZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3MpIHtcclxuICAgIGlmICh0eXBlb2YgYWRkcmVzcyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmlzQWRkcmVzcyA9IGlzQWRkcmVzcztcclxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXRpbHNfMSIsInJlcXVpcmUiLCJpc0Jsb29tIiwiYmxvb20iLCJ0ZXN0IiwiaXNJbkJsb29tIiwiY29uc3RydWN0b3IiLCJVaW50OEFycmF5IiwiYnl0ZXNUb0hleCIsImhhc2giLCJrZWNjYWsyNTYiLCJyZXBsYWNlIiwiaSIsImJpdHBvcyIsInBhcnNlSW50Iiwic3Vic3RyIiwiY29kZSIsImNvZGVQb2ludFRvSW50IiwiY2hhckNvZGVBdCIsImxlbmd0aCIsIk1hdGgiLCJmbG9vciIsIm9mZnNldCIsImNvZGVQb2ludCIsIkVycm9yIiwiaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSIsImV0aGVyZXVtQWRkcmVzcyIsImlzQWRkcmVzcyIsImFkZHJlc3MiLCJwYWRMZWZ0IiwiaXNDb250cmFjdEFkZHJlc3NJbkJsb29tIiwiY29udHJhY3RBZGRyZXNzIiwiaXNUb3BpY0luQmxvb20iLCJ0b3BpYyIsImlzVG9waWMiLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-bloom-filters/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-bloom-filters/dist/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/ethereum-bloom-filters/dist/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst sha3 = __webpack_require__(/*! js-sha3 */ \"(ssr)/./node_modules/js-sha3/src/sha3.js\");\n/**\r\n * Keccak256 hash\r\n * @param data The data\r\n */ function keccak256(data) {\n    return \"0x\" + sha3.keccak_256(toByteArray(data));\n}\nexports.keccak256 = keccak256;\n/**\r\n * Adding padding to string on the left\r\n * @param value The value\r\n * @param chars The chars\r\n */ exports.padLeft = (value, chars)=>{\n    const hasPrefix = /^0x/i.test(value) || typeof value === \"number\";\n    value = value.toString().replace(/^0x/i, \"\");\n    const padding = chars - value.length + 1 >= 0 ? chars - value.length + 1 : 0;\n    return (hasPrefix ? \"0x\" : \"\") + new Array(padding).join(\"0\") + value;\n};\n/**\r\n * Convert bytes to hex\r\n * @param bytes The bytes\r\n */ function bytesToHex(bytes) {\n    const hex = [];\n    for(let i = 0; i < bytes.length; i++){\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xf).toString(16));\n    }\n    return `0x${hex.join(\"\").replace(/^0+/, \"\")}`;\n}\nexports.bytesToHex = bytesToHex;\n/**\r\n * To byte array\r\n * @param value The value\r\n */ function toByteArray(value) {\n    if (value == null) {\n        throw new Error(\"cannot convert null value to array\");\n    }\n    if (typeof value === \"string\") {\n        const match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n        if (!match) {\n            throw new Error(\"invalid hexidecimal string\");\n        }\n        if (match[1] !== \"0x\") {\n            throw new Error(\"hex string must have 0x prefix\");\n        }\n        value = value.substring(2);\n        if (value.length % 2) {\n            value = \"0\" + value;\n        }\n        const result = [];\n        for(let i = 0; i < value.length; i += 2){\n            result.push(parseInt(value.substr(i, 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isByteArray(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    throw new Error(\"invalid arrayify value\");\n}\nexports.toByteArray = toByteArray;\n/**\r\n * Is byte array\r\n * @param value The value\r\n */ function isByteArray(value) {\n    if (!value || // tslint:disable-next-line: radix\n    parseInt(String(value.length)) != value.length || typeof value === \"string\") {\n        return false;\n    }\n    for(let i = 0; i < value.length; i++){\n        const v = value[i];\n        // tslint:disable-next-line: radix\n        if (v < 0 || v >= 256 || parseInt(String(v)) != v) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\r\n * Add slice to array\r\n * @param array The array\r\n */ function addSlice(array) {\n    if (array.slice !== undefined) {\n        return array;\n    }\n    array.slice = ()=>{\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tYmxvb20tZmlsdGVycy9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLE9BQU9DLG1CQUFPQSxDQUFDLHlEQUFTO0FBQzlCOzs7Q0FHQyxHQUNELFNBQVNDLFVBQVVDLElBQUk7SUFDbkIsT0FBTyxPQUFPSCxLQUFLSSxVQUFVLENBQUNDLFlBQVlGO0FBQzlDO0FBQ0FMLGlCQUFpQixHQUFHSTtBQUNwQjs7OztDQUlDLEdBQ0RKLGVBQWUsR0FBRyxDQUFDQyxPQUFPUTtJQUN0QixNQUFNQyxZQUFZLE9BQU9DLElBQUksQ0FBQ1YsVUFBVSxPQUFPQSxVQUFVO0lBQ3pEQSxRQUFRQSxNQUFNVyxRQUFRLEdBQUdDLE9BQU8sQ0FBQyxRQUFRO0lBQ3pDLE1BQU1DLFVBQVVMLFFBQVFSLE1BQU1jLE1BQU0sR0FBRyxLQUFLLElBQUlOLFFBQVFSLE1BQU1jLE1BQU0sR0FBRyxJQUFJO0lBQzNFLE9BQU8sQ0FBQ0wsWUFBWSxPQUFPLEVBQUMsSUFBSyxJQUFJTSxNQUFNRixTQUFTRyxJQUFJLENBQUMsT0FBT2hCO0FBQ3BFO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU2lCLFdBQVdDLEtBQUs7SUFDckIsTUFBTUMsTUFBTSxFQUFFO0lBQ2QsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLE1BQU1KLE1BQU0sRUFBRU0sSUFBSztRQUNuQ0QsSUFBSUUsSUFBSSxDQUFDLENBQUNILEtBQUssQ0FBQ0UsRUFBRSxLQUFLLEdBQUdULFFBQVEsQ0FBQztRQUNuQ1EsSUFBSUUsSUFBSSxDQUFDLENBQUNILEtBQUssQ0FBQ0UsRUFBRSxHQUFHLEdBQUUsRUFBR1QsUUFBUSxDQUFDO0lBQ3ZDO0lBQ0EsT0FBTyxDQUFDLEVBQUUsRUFBRVEsSUFBSUgsSUFBSSxDQUFDLElBQUlKLE9BQU8sQ0FBQyxPQUFPLElBQUksQ0FBQztBQUNqRDtBQUNBYixrQkFBa0IsR0FBR2tCO0FBQ3JCOzs7Q0FHQyxHQUNELFNBQVNYLFlBQVlOLEtBQUs7SUFDdEIsSUFBSUEsU0FBUyxNQUFNO1FBQ2YsTUFBTSxJQUFJc0IsTUFBTTtJQUNwQjtJQUNBLElBQUksT0FBT3RCLFVBQVUsVUFBVTtRQUMzQixNQUFNdUIsUUFBUXZCLE1BQU11QixLQUFLLENBQUM7UUFDMUIsSUFBSSxDQUFDQSxPQUFPO1lBQ1IsTUFBTSxJQUFJRCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxNQUFNO1lBQ25CLE1BQU0sSUFBSUQsTUFBTTtRQUNwQjtRQUNBdEIsUUFBUUEsTUFBTXdCLFNBQVMsQ0FBQztRQUN4QixJQUFJeEIsTUFBTWMsTUFBTSxHQUFHLEdBQUc7WUFDbEJkLFFBQVEsTUFBTUE7UUFDbEI7UUFDQSxNQUFNeUIsU0FBUyxFQUFFO1FBQ2pCLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJcEIsTUFBTWMsTUFBTSxFQUFFTSxLQUFLLEVBQUc7WUFDdENLLE9BQU9KLElBQUksQ0FBQ0ssU0FBUzFCLE1BQU0yQixNQUFNLENBQUNQLEdBQUcsSUFBSTtRQUM3QztRQUNBLE9BQU9RLFNBQVMsSUFBSUMsV0FBV0o7SUFDbkM7SUFDQSxJQUFJSyxZQUFZOUIsUUFBUTtRQUNwQixPQUFPNEIsU0FBUyxJQUFJQyxXQUFXN0I7SUFDbkM7SUFDQSxNQUFNLElBQUlzQixNQUFNO0FBQ3BCO0FBQ0F2QixtQkFBbUIsR0FBR087QUFDdEI7OztDQUdDLEdBQ0QsU0FBU3dCLFlBQVk5QixLQUFLO0lBQ3RCLElBQUksQ0FBQ0EsU0FDRCxrQ0FBa0M7SUFDbEMwQixTQUFTSyxPQUFPL0IsTUFBTWMsTUFBTSxNQUFNZCxNQUFNYyxNQUFNLElBQzlDLE9BQU9kLFVBQVUsVUFBVTtRQUMzQixPQUFPO0lBQ1g7SUFDQSxJQUFLLElBQUlvQixJQUFJLEdBQUdBLElBQUlwQixNQUFNYyxNQUFNLEVBQUVNLElBQUs7UUFDbkMsTUFBTVksSUFBSWhDLEtBQUssQ0FBQ29CLEVBQUU7UUFDbEIsa0NBQWtDO1FBQ2xDLElBQUlZLElBQUksS0FBS0EsS0FBSyxPQUFPTixTQUFTSyxPQUFPQyxPQUFPQSxHQUFHO1lBQy9DLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0osU0FBU0ssS0FBSztJQUNuQixJQUFJQSxNQUFNQyxLQUFLLEtBQUtDLFdBQVc7UUFDM0IsT0FBT0Y7SUFDWDtJQUNBQSxNQUFNQyxLQUFLLEdBQUc7UUFDVixNQUFNRSxPQUFPckIsTUFBTXNCLFNBQVMsQ0FBQ0gsS0FBSyxDQUFDSSxJQUFJLENBQUNDO1FBQ3hDLE9BQU9YLFNBQVMsSUFBSUMsV0FBV2QsTUFBTXNCLFNBQVMsQ0FBQ0gsS0FBSyxDQUFDTSxLQUFLLENBQUNQLE9BQU9HO0lBQ3RFO0lBQ0EsT0FBT0g7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1ibG9vbS1maWx0ZXJzL2Rpc3QvdXRpbHMuanM/ZWU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBzaGEzID0gcmVxdWlyZShcImpzLXNoYTNcIik7XHJcbi8qKlxyXG4gKiBLZWNjYWsyNTYgaGFzaFxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YVxyXG4gKi9cclxuZnVuY3Rpb24ga2VjY2FrMjU2KGRhdGEpIHtcclxuICAgIHJldHVybiAnMHgnICsgc2hhMy5rZWNjYWtfMjU2KHRvQnl0ZUFycmF5KGRhdGEpKTtcclxufVxyXG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1NjtcclxuLyoqXHJcbiAqIEFkZGluZyBwYWRkaW5nIHRvIHN0cmluZyBvbiB0aGUgbGVmdFxyXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlXHJcbiAqIEBwYXJhbSBjaGFycyBUaGUgY2hhcnNcclxuICovXHJcbmV4cG9ydHMucGFkTGVmdCA9ICh2YWx1ZSwgY2hhcnMpID0+IHtcclxuICAgIGNvbnN0IGhhc1ByZWZpeCA9IC9eMHgvaS50ZXN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xyXG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoL14weC9pLCAnJyk7XHJcbiAgICBjb25zdCBwYWRkaW5nID0gY2hhcnMgLSB2YWx1ZS5sZW5ndGggKyAxID49IDAgPyBjaGFycyAtIHZhbHVlLmxlbmd0aCArIDEgOiAwO1xyXG4gICAgcmV0dXJuIChoYXNQcmVmaXggPyAnMHgnIDogJycpICsgbmV3IEFycmF5KHBhZGRpbmcpLmpvaW4oJzAnKSArIHZhbHVlO1xyXG59O1xyXG4vKipcclxuICogQ29udmVydCBieXRlcyB0byBoZXhcclxuICogQHBhcmFtIGJ5dGVzIFRoZSBieXRlc1xyXG4gKi9cclxuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xyXG4gICAgY29uc3QgaGV4ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xyXG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSAmIDB4ZikudG9TdHJpbmcoMTYpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBgMHgke2hleC5qb2luKCcnKS5yZXBsYWNlKC9eMCsvLCAnJyl9YDtcclxufVxyXG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xyXG4vKipcclxuICogVG8gYnl0ZSBhcnJheVxyXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0J5dGVBcnJheSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb252ZXJ0IG51bGwgdmFsdWUgdG8gYXJyYXknKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl0qJC8pO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhleGlkZWNpbWFsIHN0cmluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hbMV0gIT09ICcweCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIG11c3QgaGF2ZSAweCBwcmVmaXgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMik7XHJcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludCh2YWx1ZS5zdWJzdHIoaSwgMiksIDE2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0J5dGVBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcnJheWlmeSB2YWx1ZScpO1xyXG59XHJcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheTtcclxuLyoqXHJcbiAqIElzIGJ5dGUgYXJyYXlcclxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNCeXRlQXJyYXkodmFsdWUpIHtcclxuICAgIGlmICghdmFsdWUgfHxcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHJhZGl4XHJcbiAgICAgICAgcGFyc2VJbnQoU3RyaW5nKHZhbHVlLmxlbmd0aCkpICE9IHZhbHVlLmxlbmd0aCB8fFxyXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcmFkaXhcclxuICAgICAgICBpZiAodiA8IDAgfHwgdiA+PSAyNTYgfHwgcGFyc2VJbnQoU3RyaW5nKHYpKSAhPSB2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQWRkIHNsaWNlIHRvIGFycmF5XHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXlcclxuICovXHJcbmZ1bmN0aW9uIGFkZFNsaWNlKGFycmF5KSB7XHJcbiAgICBpZiAoYXJyYXkuc2xpY2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuICAgIGFycmF5LnNsaWNlID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNoYTMiLCJyZXF1aXJlIiwia2VjY2FrMjU2IiwiZGF0YSIsImtlY2Nha18yNTYiLCJ0b0J5dGVBcnJheSIsInBhZExlZnQiLCJjaGFycyIsImhhc1ByZWZpeCIsInRlc3QiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJwYWRkaW5nIiwibGVuZ3RoIiwiQXJyYXkiLCJqb2luIiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiaGV4IiwiaSIsInB1c2giLCJFcnJvciIsIm1hdGNoIiwic3Vic3RyaW5nIiwicmVzdWx0IiwicGFyc2VJbnQiLCJzdWJzdHIiLCJhZGRTbGljZSIsIlVpbnQ4QXJyYXkiLCJpc0J5dGVBcnJheSIsIlN0cmluZyIsInYiLCJhcnJheSIsInNsaWNlIiwidW5kZWZpbmVkIiwiYXJncyIsInByb3RvdHlwZSIsImNhbGwiLCJhcmd1bWVudHMiLCJhcHBseSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-bloom-filters/dist/utils.js\n");

/***/ })

};
;