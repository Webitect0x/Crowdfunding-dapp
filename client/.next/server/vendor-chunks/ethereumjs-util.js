"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereumjs-util";
exports.ids = ["vendor-chunks/ethereumjs-util"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/account.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/account.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethereumjs-util/dist/constants.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\");\nclass Account {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */ constructor(nonce = new externals_1.BN(0), balance = new externals_1.BN(0), stateRoot = constants_1.KECCAK256_RLP, codeHash = constants_1.KECCAK256_NULL){\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    static fromAccountData(accountData) {\n        const { nonce, balance, stateRoot, codeHash } = accountData;\n        return new Account(nonce ? new externals_1.BN((0, bytes_1.toBuffer)(nonce)) : undefined, balance ? new externals_1.BN((0, bytes_1.toBuffer)(balance)) : undefined, stateRoot ? (0, bytes_1.toBuffer)(stateRoot) : undefined, codeHash ? (0, bytes_1.toBuffer)(codeHash) : undefined);\n    }\n    static fromRlpSerializedAccount(serialized) {\n        const values = externals_1.rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error(\"Invalid serialized account input. Must be array\");\n        }\n        return this.fromValuesArray(values);\n    }\n    static fromValuesArray(values) {\n        const [nonce, balance, stateRoot, codeHash] = values;\n        return new Account(new externals_1.BN(nonce), new externals_1.BN(balance), stateRoot, codeHash);\n    }\n    _validate() {\n        if (this.nonce.lt(new externals_1.BN(0))) {\n            throw new Error(\"nonce must be greater than zero\");\n        }\n        if (this.balance.lt(new externals_1.BN(0))) {\n            throw new Error(\"balance must be greater than zero\");\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error(\"stateRoot must have a length of 32\");\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error(\"codeHash must have a length of 32\");\n        }\n    }\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */ raw() {\n        return [\n            (0, types_1.bnToUnpaddedBuffer)(this.nonce),\n            (0, types_1.bnToUnpaddedBuffer)(this.balance),\n            this.stateRoot,\n            this.codeHash\n        ];\n    }\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */ serialize() {\n        return externals_1.rlp.encode(this.raw());\n    }\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */ isContract() {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */ isEmpty() {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    }\n}\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */ const isValidAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\nexports.isValidAddress = isValidAddress;\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */ const toChecksumAddress = function(hexAddress, eip1191ChainId) {\n    (0, helpers_1.assertIsHexString)(hexAddress);\n    const address = (0, internal_1.stripHexPrefix)(hexAddress).toLowerCase();\n    let prefix = \"\";\n    if (eip1191ChainId) {\n        const chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + \"0x\";\n    }\n    const hash = (0, hash_1.keccakFromString)(prefix + address).toString(\"hex\");\n    let ret = \"0x\";\n    for(let i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */ const isValidChecksumAddress = function(hexAddress, eip1191ChainId) {\n    return (0, exports.isValidAddress)(hexAddress) && (0, exports.toChecksumAddress)(hexAddress, eip1191ChainId) === hexAddress;\n};\nexports.isValidChecksumAddress = isValidChecksumAddress;\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */ const generateAddress = function(from, nonce) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(nonce);\n    const nonceBN = new externals_1.BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return (0, hash_1.rlphash)([\n            from,\n            null\n        ]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.rlphash)([\n        from,\n        Buffer.from(nonceBN.toArray())\n    ]).slice(-20);\n};\nexports.generateAddress = generateAddress;\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */ const generateAddress2 = function(from, salt, initCode) {\n    (0, helpers_1.assertIsBuffer)(from);\n    (0, helpers_1.assertIsBuffer)(salt);\n    (0, helpers_1.assertIsBuffer)(initCode);\n    (0, assert_1.default)(from.length === 20);\n    (0, assert_1.default)(salt.length === 32);\n    const address = (0, hash_1.keccak256)(Buffer.concat([\n        Buffer.from(\"ff\", \"hex\"),\n        from,\n        salt,\n        (0, hash_1.keccak256)(initCode)\n    ]));\n    return address.slice(-20);\n};\nexports.generateAddress2 = generateAddress2;\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */ const isValidPrivate = function(privateKey) {\n    return (0, secp256k1_1.privateKeyVerify)(privateKey);\n};\nexports.isValidPrivate = isValidPrivate;\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const isValidPublic = function(publicKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return (0, secp256k1_1.publicKeyVerify)(Buffer.concat([\n            Buffer.from([\n                4\n            ]),\n            publicKey\n        ]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return (0, secp256k1_1.publicKeyVerify)(publicKey);\n};\nexports.isValidPublic = isValidPublic;\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ const pubToAddress = function(pubKey, sanitize = false) {\n    (0, helpers_1.assertIsBuffer)(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(pubKey, false).slice(1));\n    }\n    (0, assert_1.default)(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return (0, hash_1.keccak)(pubKey).slice(-20);\n};\nexports.pubToAddress = pubToAddress;\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToPublic = function(privateKey) {\n    (0, helpers_1.assertIsBuffer)(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from((0, secp256k1_1.publicKeyCreate)(privateKey, false)).slice(1);\n};\nexports.privateToPublic = privateToPublic;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ const privateToAddress = function(privateKey) {\n    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));\n};\nexports.privateToAddress = privateToAddress;\n/**\n * Converts a public key to the Ethereum format.\n */ const importPublic = function(publicKey) {\n    (0, helpers_1.assertIsBuffer)(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from((0, secp256k1_1.publicKeyConvert)(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\nexports.importPublic = importPublic;\n/**\n * Returns the zero address.\n */ const zeroAddress = function() {\n    const addressLength = 20;\n    const addr = (0, bytes_1.zeros)(addressLength);\n    return (0, bytes_1.bufferToHex)(addr);\n};\nexports.zeroAddress = zeroAddress;\n/**\n * Checks if a given address is the zero address.\n */ const isZeroAddress = function(hexAddress) {\n    try {\n        (0, helpers_1.assertIsString)(hexAddress);\n    } catch (e) {\n        return false;\n    }\n    const zeroAddr = (0, exports.zeroAddress)();\n    return zeroAddr === hexAddress;\n};\nexports.isZeroAddress = isZeroAddress; //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLG1CQUFtQixHQUFHQSxvQkFBb0IsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSx1QkFBdUIsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSw4QkFBOEIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUM5WCxNQUFNaUIsV0FBV3RCLGdCQUFnQnVCLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pELE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3pDLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLGdHQUFpQztBQUM3RCxNQUFNRyxhQUFhSCxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN2QyxNQUFNSSxjQUFjSixtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQyxpRUFBUTtBQUMvQixNQUFNTyxZQUFZUCxtQkFBT0EsQ0FBQyx1RUFBVztBQUNyQyxNQUFNUSxVQUFVUixtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNRjtJQUNGOzs7S0FHQyxHQUNEVyxZQUFZQyxRQUFRLElBQUlULFlBQVlVLEVBQUUsQ0FBQyxFQUFFLEVBQUVDLFVBQVUsSUFBSVgsWUFBWVUsRUFBRSxDQUFDLEVB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eEMsT0FBT3FHLGFBQWE3QztBQUN4QjtBQUNBM0QscUJBQXFCLEdBQUdFLGVBQ3hCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9hY2NvdW50LmpzP2JiMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzID0gZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBleHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuQWNjb3VudCA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxXCIpO1xuY29uc3QgaW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNsYXNzIEFjY291bnQge1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29uc3RydWN0b3IgYXNzaWducyBhbmQgdmFsaWRhdGVzIHRoZSB2YWx1ZXMuXG4gICAgICogVXNlIHRoZSBzdGF0aWMgZmFjdG9yeSBtZXRob2RzIHRvIGFzc2lzdCBpbiBjcmVhdGluZyBhbiBBY2NvdW50IGZyb20gdmFyeWluZyBkYXRhIHR5cGVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vbmNlID0gbmV3IGV4dGVybmFsc18xLkJOKDApLCBiYWxhbmNlID0gbmV3IGV4dGVybmFsc18xLkJOKDApLCBzdGF0ZVJvb3QgPSBjb25zdGFudHNfMS5LRUNDQUsyNTZfUkxQLCBjb2RlSGFzaCA9IGNvbnN0YW50c18xLktFQ0NBSzI1Nl9OVUxMKSB7XG4gICAgICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgICAgICAgdGhpcy5iYWxhbmNlID0gYmFsYW5jZTtcbiAgICAgICAgdGhpcy5zdGF0ZVJvb3QgPSBzdGF0ZVJvb3Q7XG4gICAgICAgIHRoaXMuY29kZUhhc2ggPSBjb2RlSGFzaDtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BY2NvdW50RGF0YShhY2NvdW50RGF0YSkge1xuICAgICAgICBjb25zdCB7IG5vbmNlLCBiYWxhbmNlLCBzdGF0ZVJvb3QsIGNvZGVIYXNoIH0gPSBhY2NvdW50RGF0YTtcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KG5vbmNlID8gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBieXRlc18xLnRvQnVmZmVyKShub25jZSkpIDogdW5kZWZpbmVkLCBiYWxhbmNlID8gbmV3IGV4dGVybmFsc18xLkJOKCgwLCBieXRlc18xLnRvQnVmZmVyKShiYWxhbmNlKSkgOiB1bmRlZmluZWQsIHN0YXRlUm9vdCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShzdGF0ZVJvb3QpIDogdW5kZWZpbmVkLCBjb2RlSGFzaCA/ICgwLCBieXRlc18xLnRvQnVmZmVyKShjb2RlSGFzaCkgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJscFNlcmlhbGl6ZWRBY2NvdW50KHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZXh0ZXJuYWxzXzEucmxwLmRlY29kZShzZXJpYWxpemVkKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJpYWxpemVkIGFjY291bnQgaW5wdXQuIE11c3QgYmUgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tVmFsdWVzQXJyYXkodmFsdWVzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZXNBcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgW25vbmNlLCBiYWxhbmNlLCBzdGF0ZVJvb3QsIGNvZGVIYXNoXSA9IHZhbHVlcztcbiAgICAgICAgcmV0dXJuIG5ldyBBY2NvdW50KG5ldyBleHRlcm5hbHNfMS5CTihub25jZSksIG5ldyBleHRlcm5hbHNfMS5CTihiYWxhbmNlKSwgc3RhdGVSb290LCBjb2RlSGFzaCk7XG4gICAgfVxuICAgIF92YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uY2UubHQobmV3IGV4dGVybmFsc18xLkJOKDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub25jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmFsYW5jZS5sdChuZXcgZXh0ZXJuYWxzXzEuQk4oMCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhbGFuY2UgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlUm9vdC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXRlUm9vdCBtdXN0IGhhdmUgYSBsZW5ndGggb2YgMzInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2RlSGFzaC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvZGVIYXNoIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAzMicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCdWZmZXIgQXJyYXkgb2YgdGhlIHJhdyBCdWZmZXJzIGZvciB0aGUgYWNjb3VudCwgaW4gb3JkZXIuXG4gICAgICovXG4gICAgcmF3KCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKDAsIHR5cGVzXzEuYm5Ub1VucGFkZGVkQnVmZmVyKSh0aGlzLm5vbmNlKSxcbiAgICAgICAgICAgICgwLCB0eXBlc18xLmJuVG9VbnBhZGRlZEJ1ZmZlcikodGhpcy5iYWxhbmNlKSxcbiAgICAgICAgICAgIHRoaXMuc3RhdGVSb290LFxuICAgICAgICAgICAgdGhpcy5jb2RlSGFzaCxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUkxQIHNlcmlhbGl6YXRpb24gb2YgdGhlIGFjY291bnQgYXMgYSBgQnVmZmVyYC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbHNfMS5ybHAuZW5jb2RlKHRoaXMucmF3KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEJvb2xlYW5gIGRldGVybWluaW5nIGlmIHRoZSBhY2NvdW50IGlzIGEgY29udHJhY3QuXG4gICAgICovXG4gICAgaXNDb250cmFjdCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvZGVIYXNoLmVxdWFscyhjb25zdGFudHNfMS5LRUNDQUsyNTZfTlVMTCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQm9vbGVhbmAgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjY291bnQgaXMgZW1wdHkgY29tcGx5aW5nIHRvIHRoZSBkZWZpbml0aW9uIG9mXG4gICAgICogYWNjb3VudCBlbXB0aW5lc3MgaW4gW0VJUC0xNjFdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTYxKTpcbiAgICAgKiBcIkFuIGFjY291bnQgaXMgY29uc2lkZXJlZCBlbXB0eSB3aGVuIGl0IGhhcyBubyBjb2RlIGFuZCB6ZXJvIG5vbmNlIGFuZCB6ZXJvIGJhbGFuY2UuXCJcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlLmlzWmVybygpICYmIHRoaXMubm9uY2UuaXNaZXJvKCkgJiYgdGhpcy5jb2RlSGFzaC5lcXVhbHMoY29uc3RhbnRzXzEuS0VDQ0FLMjU2X05VTEwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b28uXG4gKi9cbmNvbnN0IGlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShoZXhBZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoaGV4QWRkcmVzcyk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGlzVmFsaWRBZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzcy5cbiAqXG4gKiBJZiBhbiBlaXAxMTkxQ2hhaW5JZCBpcyBwcm92aWRlZCwgdGhlIGNoYWluSWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY2hlY2tzdW0gY2FsY3VsYXRpb24uIFRoaXNcbiAqIGhhcyB0aGUgZWZmZWN0IG9mIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyBmb3Igb25lIGNoYWluIGhhdmluZyBpbnZhbGlkIGNoZWNrc3VtcyBmb3Igb3RoZXJzLlxuICogRm9yIG1vcmUgZGV0YWlscyBzZWUgW0VJUC0xMTkxXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTEpLlxuICpcbiAqIFdBUk5JTkc6IENoZWNrc3VtcyB3aXRoIGFuZCB3aXRob3V0IHRoZSBjaGFpbklkIHdpbGwgZGlmZmVyIGFuZCB0aGUgRUlQLTExOTEgY2hlY2tzdW0gaXMgbm90XG4gKiBiYWNrd2FyZHMgY29tcGF0aWJsZSB0byB0aGUgb3JpZ2luYWwgd2lkZWx5IGFkb3B0ZWQgY2hlY2tzdW0gZm9ybWF0IHN0YW5kYXJkIGludHJvZHVjZWQgaW5cbiAqIFtFSVAtNTVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNTUpLCBzbyB0aGlzIHdpbGwgYnJlYWsgaW4gZXhpc3RpbmcgYXBwbGljYXRpb25zLlxuICogVXNhZ2Ugb2YgdGhpcyBFSVAgaXMgdGhlcmVmb3JlIGRpc2NvdXJhZ2VkIHVubGVzcyB5b3UgaGF2ZSBhIHZlcnkgdGFyZ2V0ZWQgdXNlIGNhc2UuXG4gKi9cbmNvbnN0IHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGhleEFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgY29uc3QgYWRkcmVzcyA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShoZXhBZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBwcmVmaXggPSAnJztcbiAgICBpZiAoZWlwMTE5MUNoYWluSWQpIHtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9ICgwLCB0eXBlc18xLnRvVHlwZSkoZWlwMTE5MUNoYWluSWQsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgICAgIHByZWZpeCA9IGNoYWluSWQudG9TdHJpbmcoKSArICcweCc7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSAoMCwgaGFzaF8xLmtlY2Nha0Zyb21TdHJpbmcpKHByZWZpeCArIGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBsZXQgcmV0ID0gJzB4JztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICAgICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gdG9DaGVja3N1bUFkZHJlc3M7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKlxuICogU2VlIHRvQ2hlY2tzdW1BZGRyZXNzJyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzIGFib3V0IHRoZSBlaXAxMTkxQ2hhaW5JZCBwYXJhbWV0ZXIuXG4gKi9cbmNvbnN0IGlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoaGV4QWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MpKGhleEFkZHJlc3MpICYmICgwLCBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKShoZXhBZGRyZXNzLCBlaXAxMTkxQ2hhaW5JZCkgPT09IGhleEFkZHJlc3M7XG59O1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gaXNWYWxpZENoZWNrc3VtQWRkcmVzcztcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0LlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKi9cbmNvbnN0IGdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGZyb20pO1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG5vbmNlKTtcbiAgICBjb25zdCBub25jZUJOID0gbmV3IGV4dGVybmFsc18xLkJOKG5vbmNlKTtcbiAgICBpZiAobm9uY2VCTi5pc1plcm8oKSkge1xuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICAgICAgcmV0dXJuICgwLCBoYXNoXzEucmxwaGFzaCkoW2Zyb20sIG51bGxdKS5zbGljZSgtMjApO1xuICAgIH1cbiAgICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgICByZXR1cm4gKDAsIGhhc2hfMS5ybHBoYXNoKShbZnJvbSwgQnVmZmVyLmZyb20obm9uY2VCTi50b0FycmF5KCkpXSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGdlbmVyYXRlQWRkcmVzcztcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICovXG5jb25zdCBnZW5lcmF0ZUFkZHJlc3MyID0gZnVuY3Rpb24gKGZyb20sIHNhbHQsIGluaXRDb2RlKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoZnJvbSk7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoc2FsdCk7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoaW5pdENvZGUpO1xuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShmcm9tLmxlbmd0aCA9PT0gMjApO1xuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShzYWx0Lmxlbmd0aCA9PT0gMzIpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoMCwgaGFzaF8xLmtlY2NhazI1NikoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oJ2ZmJywgJ2hleCcpLCBmcm9tLCBzYWx0LCAoMCwgaGFzaF8xLmtlY2NhazI1NikoaW5pdENvZGUpXSkpO1xuICAgIHJldHVybiBhZGRyZXNzLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZ2VuZXJhdGVBZGRyZXNzMjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKi9cbmNvbnN0IGlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gKDAsIHNlY3AyNTZrMV8xLnByaXZhdGVLZXlWZXJpZnkpKHByaXZhdGVLZXkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBpc1ZhbGlkUHJpdmF0ZTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuY29uc3QgaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplID0gZmFsc2UpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShwdWJsaWNLZXkpO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgICAgICByZXR1cm4gKDAsIHNlY3AyNTZrMV8xLnB1YmxpY0tleVZlcmlmeSkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICAgIH1cbiAgICBpZiAoIXNhbml0aXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlWZXJpZnkpKHB1YmxpY0tleSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gaXNWYWxpZFB1YmxpYztcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuY29uc3QgcHViVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUgPSBmYWxzZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YktleSk7XG4gICAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YktleSA9IEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KShwdWJLZXksIGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuICgwLCBoYXNoXzEua2VjY2FrKShwdWJLZXkpLnNsaWNlKC0yMCk7XG59O1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBwdWJUb0FkZHJlc3M7XG5leHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5jb25zdCBwcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHByaXZhdGVLZXkpO1xuICAgIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5Q3JlYXRlKShwcml2YXRlS2V5LCBmYWxzZSkpLnNsaWNlKDEpO1xufTtcbmV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gcHJpdmF0ZVRvUHVibGljO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5jb25zdCBwcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKSgoMCwgZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMpKHByaXZhdGVLZXkpKTtcbn07XG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBwcml2YXRlVG9BZGRyZXNzO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqL1xuY29uc3QgaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKHB1YmxpY0tleSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKCgwLCBzZWNwMjU2azFfMS5wdWJsaWNLZXlDb252ZXJ0KShwdWJsaWNLZXksIGZhbHNlKS5zbGljZSgxKSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBpbXBvcnRQdWJsaWM7XG4vKipcbiAqIFJldHVybnMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICAgIGNvbnN0IGFkZHIgPSAoMCwgYnl0ZXNfMS56ZXJvcykoYWRkcmVzc0xlbmd0aCk7XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShhZGRyKTtcbn07XG5leHBvcnRzLnplcm9BZGRyZXNzID0gemVyb0FkZHJlc3M7XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgdGhlIHplcm8gYWRkcmVzcy5cbiAqL1xuY29uc3QgaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChoZXhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc1N0cmluZykoaGV4QWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgemVyb0FkZHIgPSAoMCwgZXhwb3J0cy56ZXJvQWRkcmVzcykoKTtcbiAgICByZXR1cm4gemVyb0FkZHIgPT09IGhleEFkZHJlc3M7XG59O1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gaXNaZXJvQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY291bnQuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzWmVyb0FkZHJlc3MiLCJ6ZXJvQWRkcmVzcyIsImltcG9ydFB1YmxpYyIsInByaXZhdGVUb0FkZHJlc3MiLCJwcml2YXRlVG9QdWJsaWMiLCJwdWJsaWNUb0FkZHJlc3MiLCJwdWJUb0FkZHJlc3MiLCJpc1ZhbGlkUHVibGljIiwiaXNWYWxpZFByaXZhdGUiLCJnZW5lcmF0ZUFkZHJlc3MyIiwiZ2VuZXJhdGVBZGRyZXNzIiwiaXNWYWxpZENoZWNrc3VtQWRkcmVzcyIsInRvQ2hlY2tzdW1BZGRyZXNzIiwiaXNWYWxpZEFkZHJlc3MiLCJBY2NvdW50IiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiZXh0ZXJuYWxzXzEiLCJzZWNwMjU2azFfMSIsImludGVybmFsXzEiLCJjb25zdGFudHNfMSIsImJ5dGVzXzEiLCJoYXNoXzEiLCJoZWxwZXJzXzEiLCJ0eXBlc18xIiwiY29uc3RydWN0b3IiLCJub25jZSIsIkJOIiwiYmFsYW5jZSIsInN0YXRlUm9vdCIsIktFQ0NBSzI1Nl9STFAiLCJjb2RlSGFzaCIsIktFQ0NBSzI1Nl9OVUxMIiwiX3ZhbGlkYXRlIiwiZnJvbUFjY291bnREYXRhIiwiYWNjb3VudERhdGEiLCJ0b0J1ZmZlciIsInVuZGVmaW5lZCIsImZyb21SbHBTZXJpYWxpemVkQWNjb3VudCIsInNlcmlhbGl6ZWQiLCJ2YWx1ZXMiLCJybHAiLCJkZWNvZGUiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImZyb21WYWx1ZXNBcnJheSIsImx0IiwibGVuZ3RoIiwicmF3IiwiYm5Ub1VucGFkZGVkQnVmZmVyIiwic2VyaWFsaXplIiwiZW5jb2RlIiwiaXNDb250cmFjdCIsImVxdWFscyIsImlzRW1wdHkiLCJpc1plcm8iLCJoZXhBZGRyZXNzIiwiYXNzZXJ0SXNTdHJpbmciLCJlIiwidGVzdCIsImVpcDExOTFDaGFpbklkIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJhZGRyZXNzIiwic3RyaXBIZXhQcmVmaXgiLCJ0b0xvd2VyQ2FzZSIsInByZWZpeCIsImNoYWluSWQiLCJ0b1R5cGUiLCJUeXBlT3V0cHV0IiwidG9TdHJpbmciLCJoYXNoIiwia2VjY2FrRnJvbVN0cmluZyIsInJldCIsImkiLCJwYXJzZUludCIsInRvVXBwZXJDYXNlIiwiZnJvbSIsImFzc2VydElzQnVmZmVyIiwibm9uY2VCTiIsInJscGhhc2giLCJzbGljZSIsIkJ1ZmZlciIsInRvQXJyYXkiLCJzYWx0IiwiaW5pdENvZGUiLCJkZWZhdWx0Iiwia2VjY2FrMjU2IiwiY29uY2F0IiwicHJpdmF0ZUtleSIsInByaXZhdGVLZXlWZXJpZnkiLCJwdWJsaWNLZXkiLCJzYW5pdGl6ZSIsInB1YmxpY0tleVZlcmlmeSIsInB1YktleSIsInB1YmxpY0tleUNvbnZlcnQiLCJrZWNjYWsiLCJwdWJsaWNLZXlDcmVhdGUiLCJhZGRyZXNzTGVuZ3RoIiwiYWRkciIsInplcm9zIiwiYnVmZmVyVG9IZXgiLCJ6ZXJvQWRkciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/address.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/address.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Address = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/ethereumjs-util/dist/account.js\");\nclass Address {\n    constructor(buf){\n        (0, assert_1.default)(buf.length === 20, \"Invalid address length\");\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */ static zero() {\n        return new Address((0, bytes_1.zeros)(20));\n    }\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */ static fromString(str) {\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), \"Invalid address\");\n        return new Address((0, bytes_1.toBuffer)(str));\n    }\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */ static fromPublicKey(pubKey) {\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), \"Public key should be Buffer\");\n        const buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    }\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */ static fromPrivateKey(privateKey) {\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), \"Private key should be Buffer\");\n        const buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    }\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */ static generate(from, nonce) {\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n    }\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */ static generate2(from, salt, initCode) {\n        (0, assert_1.default)(Buffer.isBuffer(salt));\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    }\n    /**\n     * Is address equal to another.\n     */ equals(address) {\n        return this.buf.equals(address.buf);\n    }\n    /**\n     * Is address zero.\n     */ isZero() {\n        return this.equals(Address.zero());\n    }\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */ isPrecompileOrSystemAddress() {\n        const addressBN = new externals_1.BN(this.buf);\n        const rangeMin = new externals_1.BN(0);\n        const rangeMax = new externals_1.BN(\"ffff\", \"hex\");\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    }\n    /**\n     * Returns hex encoding of address.\n     */ toString() {\n        return \"0x\" + this.buf.toString(\"hex\");\n    }\n    /**\n     * Returns Buffer representation of address.\n     */ toBuffer() {\n        return Buffer.from(this.buf);\n    }\n}\nexports.Address = Address; //# sourceMappingURL=address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsTUFBTUcsV0FBV1IsZ0JBQWdCUyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQyx1RUFBVztBQUNyQyxNQUFNRjtJQUNGTSxZQUFZQyxHQUFHLENBQUU7UUFDWixJQUFHTixTQUFTTyxPQUFPLEVBQUVELElBQUlFLE1BQU0sS0FBSyxJQUFJO1FBQ3pDLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtJQUNmO0lBQ0E7O0tBRUMsR0FDRCxPQUFPRyxPQUFPO1FBQ1YsT0FBTyxJQUFJVixRQUFRLENBQUMsR0FBR0ksUUFBUU8sS0FBSyxFQUFFO0lBQzFDO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0MsV0FBV0MsR0FBRyxFQUFFO1FBQ2xCLElBQUdaLFNBQVNPLE9BQU8sRUFBRSxDQUFDLEdBQUdILFVBQVVTLGNBQWMsRUFBRUQsTUFBTTtRQUMxRCxPQUFPLElBQUliLFFBQVEsQ0FBQyxHQUFHSSxRQUFRVyxRQUFRLEVBQUVGO0lBQzdDO0lBQ0E7OztLQUdDLEdBQ0QsT0FBT0csY0FBY0MsTUFBTSxFQUFFO1FBQ3hCLElBQUdoQixTQUFTTyxPQUFPLEVBQUVVLE9BQU9DLFFBQVEsQ0FBQ0YsU0FBUztRQUMvQyxNQUFNVixNQUFNLENBQUMsR0FBR0YsVUFBVWUsWUFBWSxFQUFFSDtRQUN4QyxPQUFPLElBQUlqQixRQUFRTztJQUN2QjtJQUNBOzs7S0FHQyxHQUNELE9BQU9jLGVBQWVDLFVBQVUsRUFBRTtRQUM3QixJQUFHckIsU0FBU08sT0FBTyxFQUFFVSxPQUFPQyxRQUFRLENBQUNHLGFBQWE7UUFDbkQsTUFBTWYsTUFBTSxDQUFDLEdBQUdGLFVBQVVrQixnQkFBZ0IsRUFBRUQ7UUFDNUMsT0FBTyxJQUFJdEIsUUFBUU87SUFDdkI7SUFDQTs7OztLQUlDLEdBQ0QsT0FBT2lCLFNBQVNDLElBQUksRUFBRUMsS0FBSyxFQUFFO1FBQ3hCLElBQUd6QixTQUFTTyxPQUFPLEVBQUVMLFlBQVl3QixFQUFFLENBQUNDLElBQUksQ0FBQ0Y7UUFDMUMsT0FBTyxJQUFJMUIsUUFBUSxDQUFDLEdBQUdLLFVBQVV3QixlQUFlLEVBQUVKLEtBQUtsQixHQUFHLEVBQUVtQixNQUFNSSxXQUFXLENBQUNaO0lBQ2xGO0lBQ0E7Ozs7O0tBS0MsR0FDRCxPQUFPYSxVQUFVTixJQUFJLEVBQUVPLElBQUksRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLElBQUdoQyxTQUFTTyxPQUFPLEVBQUVVLE9BQU9DLFFBQVEsQ0FBQ2E7UUFDckMsSUFBRy9CLFNBQVNPLE9BQU8sRUFBRVUsT0FBT0MsUUFBUSxDQUFDYztRQUN0QyxPQUFPLElBQUlqQyxRQUFRLENBQUMsR0FBR0ssVUFBVTZCLGdCQUFnQixFQUFFVCxLQUFLbEIsR0FBRyxFQUFFeUIsTUFBTUM7SUFDdkU7SUFDQTs7S0FFQyxHQUNERSxPQUFPQyxPQUFPLEVBQUU7UUFDWixPQUFPLElBQUksQ0FBQzdCLEdBQUcsQ0FBQzRCLE1BQU0sQ0FBQ0MsUUFBUTdCLEdBQUc7SUFDdEM7SUFDQTs7S0FFQyxHQUNEOEIsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDRixNQUFNLENBQUNuQyxRQUFRVSxJQUFJO0lBQ25DO0lBQ0E7OztLQUdDLEdBQ0Q0Qiw4QkFBOEI7UUFDMUIsTUFBTUMsWUFBWSxJQUFJcEMsWUFBWXdCLEVBQUUsQ0FBQyxJQUFJLENBQUNwQixHQUFHO1FBQzdDLE1BQU1pQyxXQUFXLElBQUlyQyxZQUFZd0IsRUFBRSxDQUFDO1FBQ3BDLE1BQU1jLFdBQVcsSUFBSXRDLFlBQVl3QixFQUFFLENBQUMsUUFBUTtRQUM1QyxPQUFPWSxVQUFVRyxHQUFHLENBQUNGLGFBQWFELFVBQVVJLEdBQUcsQ0FBQ0Y7SUFDcEQ7SUFDQTs7S0FFQyxHQUNERyxXQUFXO1FBQ1AsT0FBTyxPQUFPLElBQUksQ0FBQ3JDLEdBQUcsQ0FBQ3FDLFFBQVEsQ0FBQztJQUNwQztJQUNBOztLQUVDLEdBQ0Q3QixXQUFXO1FBQ1AsT0FBT0csT0FBT08sSUFBSSxDQUFDLElBQUksQ0FBQ2xCLEdBQUc7SUFDL0I7QUFDSjtBQUNBVCxlQUFlLEdBQUdFLFNBQ2xCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9hZGRyZXNzLmpzPzM0MzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuY29uc3QgYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzXCIpO1xuY29uc3QgYWNjb3VudF8xID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcbmNsYXNzIEFkZHJlc3Mge1xuICAgIGNvbnN0cnVjdG9yKGJ1Zikge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoYnVmLmxlbmd0aCA9PT0gMjAsICdJbnZhbGlkIGFkZHJlc3MgbGVuZ3RoJyk7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB6ZXJvIGFkZHJlc3MuXG4gICAgICovXG4gICAgc3RhdGljIHplcm8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYnl0ZXNfMS56ZXJvcykoMjApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBBZGRyZXNzIG9iamVjdCBmcm9tIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBzdHIgLSBIZXgtZW5jb2RlZCBhZGRyZXNzXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KSgoMCwgYWNjb3VudF8xLmlzVmFsaWRBZGRyZXNzKShzdHIpLCAnSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYnl0ZXNfMS50b0J1ZmZlcikoc3RyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYWRkcmVzcyBmb3IgYSBnaXZlbiBwdWJsaWMga2V5LlxuICAgICAqIEBwYXJhbSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUHVibGljS2V5KHB1YktleSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKHB1YktleSksICdQdWJsaWMga2V5IHNob3VsZCBiZSBCdWZmZXInKTtcbiAgICAgICAgY29uc3QgYnVmID0gKDAsIGFjY291bnRfMS5wdWJUb0FkZHJlc3MpKHB1YktleSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhidWYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFkZHJlc3MgZm9yIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXkpLCAnUHJpdmF0ZSBrZXkgc2hvdWxkIGJlIEJ1ZmZlcicpO1xuICAgICAgICBjb25zdCBidWYgPSAoMCwgYWNjb3VudF8xLnByaXZhdGVUb0FkZHJlc3MpKHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIG5vbmNlIFRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlKGZyb20sIG5vbmNlKSB7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShleHRlcm5hbHNfMS5CTi5pc0JOKG5vbmNlKSk7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcygoMCwgYWNjb3VudF8xLmdlbmVyYXRlQWRkcmVzcykoZnJvbS5idWYsIG5vbmNlLnRvQXJyYXlMaWtlKEJ1ZmZlcikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gc2FsdCBBIHNhbHRcbiAgICAgKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZTIoZnJvbSwgc2FsdCwgaW5pdENvZGUpIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmRlZmF1bHQpKEJ1ZmZlci5pc0J1ZmZlcihzYWx0KSk7XG4gICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShCdWZmZXIuaXNCdWZmZXIoaW5pdENvZGUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKCgwLCBhY2NvdW50XzEuZ2VuZXJhdGVBZGRyZXNzMikoZnJvbS5idWYsIHNhbHQsIGluaXRDb2RlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIGFkZHJlc3MgZXF1YWwgdG8gYW5vdGhlci5cbiAgICAgKi9cbiAgICBlcXVhbHMoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuZXF1YWxzKGFkZHJlc3MuYnVmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgYWRkcmVzcyB6ZXJvLlxuICAgICAqL1xuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKEFkZHJlc3MuemVybygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBhZGRyZXNzIGlzIGluIHRoZSBhZGRyZXNzIHJhbmdlIGRlZmluZWRcbiAgICAgKiBieSBFSVAtMTM1MlxuICAgICAqL1xuICAgIGlzUHJlY29tcGlsZU9yU3lzdGVtQWRkcmVzcygpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzc0JOID0gbmV3IGV4dGVybmFsc18xLkJOKHRoaXMuYnVmKTtcbiAgICAgICAgY29uc3QgcmFuZ2VNaW4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4oMCk7XG4gICAgICAgIGNvbnN0IHJhbmdlTWF4ID0gbmV3IGV4dGVybmFsc18xLkJOKCdmZmZmJywgJ2hleCcpO1xuICAgICAgICByZXR1cm4gYWRkcmVzc0JOLmd0ZShyYW5nZU1pbikgJiYgYWRkcmVzc0JOLmx0ZShyYW5nZU1heCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGV4IGVuY29kaW5nIG9mIGFkZHJlc3MuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgdGhpcy5idWYudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5idWYpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzcyA9IEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBZGRyZXNzIiwiYXNzZXJ0XzEiLCJyZXF1aXJlIiwiZXh0ZXJuYWxzXzEiLCJieXRlc18xIiwiYWNjb3VudF8xIiwiY29uc3RydWN0b3IiLCJidWYiLCJkZWZhdWx0IiwibGVuZ3RoIiwiemVybyIsInplcm9zIiwiZnJvbVN0cmluZyIsInN0ciIsImlzVmFsaWRBZGRyZXNzIiwidG9CdWZmZXIiLCJmcm9tUHVibGljS2V5IiwicHViS2V5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJwdWJUb0FkZHJlc3MiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJwcml2YXRlVG9BZGRyZXNzIiwiZ2VuZXJhdGUiLCJmcm9tIiwibm9uY2UiLCJCTiIsImlzQk4iLCJnZW5lcmF0ZUFkZHJlc3MiLCJ0b0FycmF5TGlrZSIsImdlbmVyYXRlMiIsInNhbHQiLCJpbml0Q29kZSIsImdlbmVyYXRlQWRkcmVzczIiLCJlcXVhbHMiLCJhZGRyZXNzIiwiaXNaZXJvIiwiaXNQcmVjb21waWxlT3JTeXN0ZW1BZGRyZXNzIiwiYWRkcmVzc0JOIiwicmFuZ2VNaW4iLCJyYW5nZU1heCIsImd0ZSIsImx0ZSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/bytes.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/bytes.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.bufArrToArr = exports.arrToBufArr = exports.validateNoLeadingZeroes = exports.baToJSON = exports.toUtf8 = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.unpadHexString = exports.unpadArray = exports.unpadBuffer = exports.setLengthRight = exports.setLengthLeft = exports.zeros = exports.intToBuffer = exports.intToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Converts a `Number` into a hex `String`\n * @param {Number} i\n * @return {String}\n */ const intToHex = function(i) {\n    if (!Number.isSafeInteger(i) || i < 0) {\n        throw new Error(`Received an invalid integer type: ${i}`);\n    }\n    return `0x${i.toString(16)}`;\n};\nexports.intToHex = intToHex;\n/**\n * Converts an `Number` to a `Buffer`\n * @param {Number} i\n * @return {Buffer}\n */ const intToBuffer = function(i) {\n    const hex = (0, exports.intToHex)(i);\n    return Buffer.from((0, internal_1.padToEven)(hex.slice(2)), \"hex\");\n};\nexports.intToBuffer = intToBuffer;\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */ const zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\nexports.zeros = zeros;\n/**\n * Pads a `Buffer` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer)\n */ const setLength = function(msg, length, right) {\n    const buf = (0, exports.zeros)(length);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Left Pads a `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthLeft = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, false);\n};\nexports.setLengthLeft = setLengthLeft;\n/**\n * Right Pads a `Buffer` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param msg the value to pad (Buffer)\n * @param length the number of bytes the output should be\n * @return (Buffer)\n */ const setLengthRight = function(msg, length) {\n    (0, helpers_1.assertIsBuffer)(msg);\n    return setLength(msg, length, true);\n};\nexports.setLengthRight = setLengthRight;\n/**\n * Trims leading zeros from a `Buffer`, `String` or `Number[]`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */ const stripZeros = function(a) {\n    let first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Trims leading zeros from a `Buffer`.\n * @param a (Buffer)\n * @return (Buffer)\n */ const unpadBuffer = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return stripZeros(a);\n};\nexports.unpadBuffer = unpadBuffer;\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param a (number[])\n * @return (number[])\n */ const unpadArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return stripZeros(a);\n};\nexports.unpadArray = unpadArray;\n/**\n * Trims leading zeros from a hex-prefixed `String`.\n * @param a (String)\n * @return (String)\n */ const unpadHexString = function(a) {\n    (0, helpers_1.assertIsHexString)(a);\n    a = (0, internal_1.stripHexPrefix)(a);\n    return stripZeros(a);\n};\nexports.unpadHexString = unpadHexString;\n/**\n * Attempts to turn a value into a `Buffer`.\n * Inputs supported: `Buffer`, `String` (hex-prefixed), `Number`, null/undefined, `BN` and other objects\n * with a `toArray()` or `toBuffer()` method.\n * @param v the value\n */ const toBuffer = function(v) {\n    if (v === null || v === undefined) {\n        return Buffer.allocUnsafe(0);\n    }\n    if (Buffer.isBuffer(v)) {\n        return Buffer.from(v);\n    }\n    if (Array.isArray(v) || v instanceof Uint8Array) {\n        return Buffer.from(v);\n    }\n    if (typeof v === \"string\") {\n        if (!(0, internal_1.isHexString)(v)) {\n            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);\n        }\n        return Buffer.from((0, internal_1.padToEven)((0, internal_1.stripHexPrefix)(v)), \"hex\");\n    }\n    if (typeof v === \"number\") {\n        return (0, exports.intToBuffer)(v);\n    }\n    if (externals_1.BN.isBN(v)) {\n        if (v.isNeg()) {\n            throw new Error(`Cannot convert negative BN to buffer. Given: ${v}`);\n        }\n        return v.toArrayLike(Buffer);\n    }\n    if (v.toArray) {\n        // converts a BN to a Buffer\n        return Buffer.from(v.toArray());\n    }\n    if (v.toBuffer) {\n        return Buffer.from(v.toBuffer());\n    }\n    throw new Error(\"invalid type\");\n};\nexports.toBuffer = toBuffer;\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */ const bufferToInt = function(buf) {\n    return new externals_1.BN((0, exports.toBuffer)(buf)).toNumber();\n};\nexports.bufferToInt = bufferToInt;\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */ const bufferToHex = function(buf) {\n    buf = (0, exports.toBuffer)(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\nexports.bufferToHex = bufferToHex;\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */ const fromSigned = function(num) {\n    return new externals_1.BN(num).fromTwos(256);\n};\nexports.fromSigned = fromSigned;\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */ const toUnsigned = function(num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\nexports.toUnsigned = toUnsigned;\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */ const addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return (0, internal_1.isHexPrefixed)(str) ? str : \"0x\" + str;\n};\nexports.addHexPrefix = addHexPrefix;\n/**\n * Returns the utf8 string representation from a hex string.\n *\n * Examples:\n *\n * Input 1: '657468657265756d000000000000000000000000000000000000000000000000'\n * Input 2: '657468657265756d'\n * Input 3: '000000000000000000000000000000000000000000000000657468657265756d'\n *\n * Output (all 3 input variants): 'ethereum'\n *\n * Note that this method is not intended to be used with hex strings\n * representing quantities in both big endian or little endian notation.\n *\n * @param string Hex string, should be `0x` prefixed\n * @return Utf8 string\n */ const toUtf8 = function(hex) {\n    const zerosRegexp = /^(00)+|(00)+$/g;\n    hex = (0, internal_1.stripHexPrefix)(hex);\n    if (hex.length % 2 !== 0) {\n        throw new Error(\"Invalid non-even hex string input for toUtf8() provided\");\n    }\n    const bufferVal = Buffer.from(hex.replace(zerosRegexp, \"\"), \"hex\");\n    return bufferVal.toString(\"utf8\");\n};\nexports.toUtf8 = toUtf8;\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */ const baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return `0x${ba.toString(\"hex\")}`;\n    } else if (ba instanceof Array) {\n        const array = [];\n        for(let i = 0; i < ba.length; i++){\n            array.push((0, exports.baToJSON)(ba[i]));\n        }\n        return array;\n    }\n};\nexports.baToJSON = baToJSON;\n/**\n * Checks provided Buffers for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Buffer values\n * @throws if any provided value is found to have leading zero bytes\n */ const validateNoLeadingZeroes = function(values) {\n    for (const [k, v] of Object.entries(values)){\n        if (v !== undefined && v.length > 0 && v[0] === 0) {\n            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString(\"hex\")}`);\n        }\n    }\n};\nexports.validateNoLeadingZeroes = validateNoLeadingZeroes;\nfunction arrToBufArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Buffer.from(arr);\n    }\n    return arr.map((a)=>arrToBufArr(a));\n}\nexports.arrToBufArr = arrToBufArr;\nfunction bufArrToArr(arr) {\n    if (!Array.isArray(arr)) {\n        return Uint8Array.from(arr !== null && arr !== void 0 ? arr : []);\n    }\n    return arr.map((a)=>bufArrToArr(a));\n}\nexports.bufArrToArr = bufArrToArr; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYnl0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsK0JBQStCLEdBQUdBLGdCQUFnQixHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUdBLHNCQUFzQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxtQkFBbUIsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyYSxNQUFNcUIsY0FBY0MsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMseUVBQVk7QUFDdkMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsdUVBQVc7QUFDckM7Ozs7Q0FJQyxHQUNELE1BQU1GLFdBQVcsU0FBVUssQ0FBQztJQUN4QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUFHO1FBQ25DLE1BQU0sSUFBSUcsTUFBTSxDQUFDLGtDQUFrQyxFQUFFSCxFQUFFLENBQUM7SUFDNUQ7SUFDQSxPQUFPLENBQUMsRUFBRSxFQUFFQSxFQUFFSSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ2hDO0FBQ0E3QixnQkFBZ0IsR0FBR29CO0FBQ25COzs7O0NBSUMsR0FDRCxNQUFNRCxjQUFjLFNBQVVNLENBQUM7SUFDM0IsTUFBTUssTUFBTSxDQUFDLEdBQUc5QixRQUFRb0IsUUFBUSxFQUFFSztJQUNsQyxPQUFPTSxPQUFPQyxJQUFJLENBQUMsQ0FBQyxHQUFHVCxXQUFXVSxTQUFTLEVBQUVILElBQUlJLEtBQUssQ0FBQyxLQUFLO0FBQ2hFO0FBQ0FsQyxtQkFB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Z0QsTUFBTUMsSUFBSSxDQUFDLENBQUMsR0FBRzFFLFFBQVFLLFFBQVEsRUFBRW1FLEVBQUUsQ0FBQy9DLEVBQUU7UUFDMUM7UUFDQSxPQUFPZ0Q7SUFDWDtBQUNKO0FBQ0F6RSxnQkFBZ0IsR0FBR0s7QUFDbkI7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsTUFBTUQsMEJBQTBCLFNBQVV1RSxNQUFNO0lBQzVDLEtBQUssTUFBTSxDQUFDQyxHQUFHekIsRUFBRSxJQUFJckQsT0FBTytFLE9BQU8sQ0FBQ0YsUUFBUztRQUN6QyxJQUFJeEIsTUFBTUMsYUFBYUQsRUFBRVgsTUFBTSxHQUFHLEtBQUtXLENBQUMsQ0FBQyxFQUFFLEtBQUssR0FBRztZQUMvQyxNQUFNLElBQUl2QixNQUFNLENBQUMsRUFBRWdELEVBQUUsdUNBQXVDLEVBQUV6QixFQUFFdEIsUUFBUSxDQUFDLE9BQU8sQ0FBQztRQUNyRjtJQUNKO0FBQ0o7QUFDQTdCLCtCQUErQixHQUFHSTtBQUNsQyxTQUFTRCxZQUFZMkUsR0FBRztJQUNwQixJQUFJLENBQUN4QixNQUFNQyxPQUFPLENBQUN1QixNQUFNO1FBQ3JCLE9BQU8vQyxPQUFPQyxJQUFJLENBQUM4QztJQUN2QjtJQUNBLE9BQU9BLElBQUlDLEdBQUcsQ0FBQyxDQUFDakMsSUFBTTNDLFlBQVkyQztBQUN0QztBQUNBOUMsbUJBQW1CLEdBQUdHO0FBQ3RCLFNBQVNELFlBQVk0RSxHQUFHO0lBQ3BCLElBQUksQ0FBQ3hCLE1BQU1DLE9BQU8sQ0FBQ3VCLE1BQU07UUFDckIsT0FBT3RCLFdBQVd4QixJQUFJLENBQUM4QyxRQUFRLFFBQVFBLFFBQVEsS0FBSyxJQUFJQSxNQUFNLEVBQUU7SUFDcEU7SUFDQSxPQUFPQSxJQUFJQyxHQUFHLENBQUMsQ0FBQ2pDLElBQU01QyxZQUFZNEM7QUFDdEM7QUFDQTlDLG1CQUFtQixHQUFHRSxhQUN0QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYnl0ZXMuanM/MWI0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVmQXJyVG9BcnIgPSBleHBvcnRzLmFyclRvQnVmQXJyID0gZXhwb3J0cy52YWxpZGF0ZU5vTGVhZGluZ1plcm9lcyA9IGV4cG9ydHMuYmFUb0pTT04gPSBleHBvcnRzLnRvVXRmOCA9IGV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZXhwb3J0cy50b1Vuc2lnbmVkID0gZXhwb3J0cy5mcm9tU2lnbmVkID0gZXhwb3J0cy5idWZmZXJUb0hleCA9IGV4cG9ydHMuYnVmZmVyVG9JbnQgPSBleHBvcnRzLnRvQnVmZmVyID0gZXhwb3J0cy51bnBhZEhleFN0cmluZyA9IGV4cG9ydHMudW5wYWRBcnJheSA9IGV4cG9ydHMudW5wYWRCdWZmZXIgPSBleHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy56ZXJvcyA9IGV4cG9ydHMuaW50VG9CdWZmZXIgPSBleHBvcnRzLmludFRvSGV4ID0gdm9pZCAwO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IGludFRvSGV4ID0gZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGkpIHx8IGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgYW4gaW52YWxpZCBpbnRlZ2VyIHR5cGU6ICR7aX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAweCR7aS50b1N0cmluZygxNil9YDtcbn07XG5leHBvcnRzLmludFRvSGV4ID0gaW50VG9IZXg7XG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmNvbnN0IGludFRvQnVmZmVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICBjb25zdCBoZXggPSAoMCwgZXhwb3J0cy5pbnRUb0hleCkoaSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCBpbnRlcm5hbF8xLnBhZFRvRXZlbikoaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufTtcbmV4cG9ydHMuaW50VG9CdWZmZXIgPSBpbnRUb0J1ZmZlcjtcbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKi9cbmNvbnN0IHplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5leHBvcnRzLnplcm9zID0gemVyb3M7XG4vKipcbiAqIFBhZHMgYSBgQnVmZmVyYCB3aXRoIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogVHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGlucHV0IGlmIGl0cyBsZW5ndGggZXhjZWVkcyBgbGVuZ3RoYC5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyKVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0gcmlnaHQgd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICAgIGNvbnN0IGJ1ZiA9ICgwLCBleHBvcnRzLnplcm9zKShsZW5ndGgpO1xuICAgIGlmIChyaWdodCkge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gICAgfVxufTtcbi8qKlxuICogTGVmdCBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSBtc2cgdGhlIHZhbHVlIHRvIHBhZCAoQnVmZmVyKVxuICogQHBhcmFtIGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIChCdWZmZXIpXG4gKi9cbmNvbnN0IHNldExlbmd0aExlZnQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShtc2cpO1xuICAgIHJldHVybiBzZXRMZW5ndGgobXNnLCBsZW5ndGgsIGZhbHNlKTtcbn07XG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBzZXRMZW5ndGhMZWZ0O1xuLyoqXG4gKiBSaWdodCBQYWRzIGEgYEJ1ZmZlcmAgd2l0aCB0cmFpbGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIGl0IHRydW5jYXRlcyB0aGUgZW5kIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcilcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiAoQnVmZmVyKVxuICovXG5jb25zdCBzZXRMZW5ndGhSaWdodCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1zZyk7XG4gICAgcmV0dXJuIHNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IHNldExlbmd0aFJpZ2h0O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYCwgYFN0cmluZ2Agb3IgYE51bWJlcltdYC5cbiAqIEBwYXJhbSBhIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICogQHJldHVybiAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqL1xuY29uc3Qgc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgbGV0IGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgLlxuICogQHBhcmFtIGEgKEJ1ZmZlcilcbiAqIEByZXR1cm4gKEJ1ZmZlcilcbiAqL1xuY29uc3QgdW5wYWRCdWZmZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xuICAgIHJldHVybiBzdHJpcFplcm9zKGEpO1xufTtcbmV4cG9ydHMudW5wYWRCdWZmZXIgPSB1bnBhZEJ1ZmZlcjtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGFuIGBBcnJheWAgKG9mIG51bWJlcnMpLlxuICogQHBhcmFtIGEgKG51bWJlcltdKVxuICogQHJldHVybiAobnVtYmVyW10pXG4gKi9cbmNvbnN0IHVucGFkQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNBcnJheSkoYSk7XG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XG59O1xuZXhwb3J0cy51bnBhZEFycmF5ID0gdW5wYWRBcnJheTtcbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgaGV4LXByZWZpeGVkIGBTdHJpbmdgLlxuICogQHBhcmFtIGEgKFN0cmluZylcbiAqIEByZXR1cm4gKFN0cmluZylcbiAqL1xuY29uc3QgdW5wYWRIZXhTdHJpbmcgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNIZXhTdHJpbmcpKGEpO1xuICAgIGEgPSAoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkoYSk7XG4gICAgcmV0dXJuIHN0cmlwWmVyb3MoYSk7XG59O1xuZXhwb3J0cy51bnBhZEhleFN0cmluZyA9IHVucGFkSGV4U3RyaW5nO1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLlxuICogSW5wdXRzIHN1cHBvcnRlZDogYEJ1ZmZlcmAsIGBTdHJpbmdgIChoZXgtcHJlZml4ZWQpLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHNcbiAqIHdpdGggYSBgdG9BcnJheSgpYCBvciBgdG9CdWZmZXIoKWAgbWV0aG9kLlxuICogQHBhcmFtIHYgdGhlIHZhbHVlXG4gKi9cbmNvbnN0IHRvQnVmZmVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHYpIHx8IHYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKSh2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCBzdHJpbmcgdG8gYnVmZmVyLiB0b0J1ZmZlciBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGFuZCB0aGlzIHN0cmluZyB3YXMgZ2l2ZW46ICR7dn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIGludGVybmFsXzEucGFkVG9FdmVuKSgoMCwgaW50ZXJuYWxfMS5zdHJpcEhleFByZWZpeCkodikpLCAnaGV4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmludFRvQnVmZmVyKSh2KTtcbiAgICB9XG4gICAgaWYgKGV4dGVybmFsc18xLkJOLmlzQk4odikpIHtcbiAgICAgICAgaWYgKHYuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCBuZWdhdGl2ZSBCTiB0byBidWZmZXIuIEdpdmVuOiAke3Z9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHYudG9BcnJheSkge1xuICAgICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgfVxuICAgIGlmICh2LnRvQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2LnRvQnVmZmVyKCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xufTtcbmV4cG9ydHMudG9CdWZmZXIgPSB0b0J1ZmZlcjtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgLlxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuY29uc3QgYnVmZmVyVG9JbnQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbHNfMS5CTigoMCwgZXhwb3J0cy50b0J1ZmZlcikoYnVmKSkudG9OdW1iZXIoKTtcbn07XG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gYnVmZmVyVG9JbnQ7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGAweGAtcHJlZml4ZWQgaGV4IGBTdHJpbmdgLlxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxuICovXG5jb25zdCBidWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBidWYgPSAoMCwgZXhwb3J0cy50b0J1ZmZlcikoYnVmKTtcbiAgICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGJ1ZmZlclRvSGV4O1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bSBTaWduZWQgaW50ZWdlciB2YWx1ZVxuICovXG5jb25zdCBmcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWxzXzEuQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZyb21TaWduZWQ7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bVxuICovXG5jb25zdCB0b1Vuc2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG5leHBvcnRzLnRvVW5zaWduZWQgPSB0b1Vuc2lnbmVkO1xuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKi9cbmNvbnN0IGFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBpbnRlcm5hbF8xLmlzSGV4UHJlZml4ZWQpKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gYWRkSGV4UHJlZml4O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB1dGY4IHN0cmluZyByZXByZXNlbnRhdGlvbiBmcm9tIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiBJbnB1dCAxOiAnNjU3NDY4NjU3MjY1NzU2ZDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqIElucHV0IDI6ICc2NTc0Njg2NTcyNjU3NTZkJ1xuICogSW5wdXQgMzogJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDY1NzQ2ODY1NzI2NTc1NmQnXG4gKlxuICogT3V0cHV0IChhbGwgMyBpbnB1dCB2YXJpYW50cyk6ICdldGhlcmV1bSdcbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgbm90IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aCBoZXggc3RyaW5nc1xuICogcmVwcmVzZW50aW5nIHF1YW50aXRpZXMgaW4gYm90aCBiaWcgZW5kaWFuIG9yIGxpdHRsZSBlbmRpYW4gbm90YXRpb24uXG4gKlxuICogQHBhcmFtIHN0cmluZyBIZXggc3RyaW5nLCBzaG91bGQgYmUgYDB4YCBwcmVmaXhlZFxuICogQHJldHVybiBVdGY4IHN0cmluZ1xuICovXG5jb25zdCB0b1V0ZjggPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgY29uc3QgemVyb3NSZWdleHAgPSAvXigwMCkrfCgwMCkrJC9nO1xuICAgIGhleCA9ICgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShoZXgpO1xuICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbm9uLWV2ZW4gaGV4IHN0cmluZyBpbnB1dCBmb3IgdG9VdGY4KCkgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyVmFsID0gQnVmZmVyLmZyb20oaGV4LnJlcGxhY2UoemVyb3NSZWdleHAsICcnKSwgJ2hleCcpO1xuICAgIHJldHVybiBidWZmZXJWYWwudG9TdHJpbmcoJ3V0ZjgnKTtcbn07XG5leHBvcnRzLnRvVXRmOCA9IHRvVXRmODtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT04uXG4gKiBAcGFyYW0gYmEgKEJ1ZmZlcnxBcnJheSlcbiAqIEByZXR1cm4gKEFycmF5fFN0cmluZ3xudWxsKVxuICovXG5jb25zdCBiYVRvSlNPTiA9IGZ1bmN0aW9uIChiYSkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgICAgIHJldHVybiBgMHgke2JhLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5LnB1c2goKDAsIGV4cG9ydHMuYmFUb0pTT04pKGJhW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG5leHBvcnRzLmJhVG9KU09OID0gYmFUb0pTT047XG4vKipcbiAqIENoZWNrcyBwcm92aWRlZCBCdWZmZXJzIGZvciBsZWFkaW5nIHplcm9lcyBhbmQgdGhyb3dzIGlmIGZvdW5kLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIFZhbGlkIHZhbHVlczogMHgxLCAweCwgMHgwMSwgMHgxMjM0XG4gKiBJbnZhbGlkIHZhbHVlczogMHgwLCAweDAwLCAweDAwMSwgMHgwMDAxXG4gKlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciB2YWxpZGF0aW5nIHRoYXQgUkxQIGVuY29kZWQgaW50ZWdlcnMgY29tcGx5IHdpdGggdGhlIHJ1bGUgdGhhdCBhbGxcbiAqIGludGVnZXIgdmFsdWVzIGVuY29kZWQgdG8gUkxQIG11c3QgYmUgaW4gdGhlIG1vc3QgY29tcGFjdCBmb3JtIGFuZCBjb250YWluIG5vIGxlYWRpbmcgemVybyBieXRlc1xuICogQHBhcmFtIHZhbHVlcyBBbiBvYmplY3QgY29udGFpbmluZyBzdHJpbmcga2V5cyBhbmQgQnVmZmVyIHZhbHVlc1xuICogQHRocm93cyBpZiBhbnkgcHJvdmlkZWQgdmFsdWUgaXMgZm91bmQgdG8gaGF2ZSBsZWFkaW5nIHplcm8gYnl0ZXNcbiAqL1xuY29uc3QgdmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsdWVzKSkge1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmIHYubGVuZ3RoID4gMCAmJiB2WzBdID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a30gY2Fubm90IGhhdmUgbGVhZGluZyB6ZXJvZXMsIHJlY2VpdmVkOiAke3YudG9TdHJpbmcoJ2hleCcpfWApO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMudmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMgPSB2YWxpZGF0ZU5vTGVhZGluZ1plcm9lcztcbmZ1bmN0aW9uIGFyclRvQnVmQXJyKGFycikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyLm1hcCgoYSkgPT4gYXJyVG9CdWZBcnIoYSkpO1xufVxuZXhwb3J0cy5hcnJUb0J1ZkFyciA9IGFyclRvQnVmQXJyO1xuZnVuY3Rpb24gYnVmQXJyVG9BcnIoYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhcnIgIT09IG51bGwgJiYgYXJyICE9PSB2b2lkIDAgPyBhcnIgOiBbXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnIubWFwKChhKSA9PiBidWZBcnJUb0FycihhKSk7XG59XG5leHBvcnRzLmJ1ZkFyclRvQXJyID0gYnVmQXJyVG9BcnI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJidWZBcnJUb0FyciIsImFyclRvQnVmQXJyIiwidmFsaWRhdGVOb0xlYWRpbmdaZXJvZXMiLCJiYVRvSlNPTiIsInRvVXRmOCIsImFkZEhleFByZWZpeCIsInRvVW5zaWduZWQiLCJmcm9tU2lnbmVkIiwiYnVmZmVyVG9IZXgiLCJidWZmZXJUb0ludCIsInRvQnVmZmVyIiwidW5wYWRIZXhTdHJpbmciLCJ1bnBhZEFycmF5IiwidW5wYWRCdWZmZXIiLCJzZXRMZW5ndGhSaWdodCIsInNldExlbmd0aExlZnQiLCJ6ZXJvcyIsImludFRvQnVmZmVyIiwiaW50VG9IZXgiLCJleHRlcm5hbHNfMSIsInJlcXVpcmUiLCJpbnRlcm5hbF8xIiwiaGVscGVyc18xIiwiaSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsInRvU3RyaW5nIiwiaGV4IiwiQnVmZmVyIiwiZnJvbSIsInBhZFRvRXZlbiIsInNsaWNlIiwiYnl0ZXMiLCJhbGxvY1Vuc2FmZSIsImZpbGwiLCJzZXRMZW5ndGgiLCJtc2ciLCJsZW5ndGgiLCJyaWdodCIsImJ1ZiIsImNvcHkiLCJhc3NlcnRJc0J1ZmZlciIsInN0cmlwWmVyb3MiLCJhIiwiZmlyc3QiLCJhc3NlcnRJc0FycmF5IiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJzdHJpcEhleFByZWZpeCIsInYiLCJ1bmRlZmluZWQiLCJpc0J1ZmZlciIsIkFycmF5IiwiaXNBcnJheSIsIlVpbnQ4QXJyYXkiLCJpc0hleFN0cmluZyIsIkJOIiwiaXNCTiIsImlzTmVnIiwidG9BcnJheUxpa2UiLCJ0b0FycmF5IiwidG9OdW1iZXIiLCJudW0iLCJmcm9tVHdvcyIsInRvVHdvcyIsInN0ciIsImlzSGV4UHJlZml4ZWQiLCJ6ZXJvc1JlZ2V4cCIsImJ1ZmZlclZhbCIsInJlcGxhY2UiLCJiYSIsImFycmF5IiwicHVzaCIsInZhbHVlcyIsImsiLCJlbnRyaWVzIiwiYXJyIiwibWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/constants.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = exports.MAX_UINT64 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\n/**\n * 2^64-1\n */ exports.MAX_UINT64 = new externals_1.BN(\"ffffffffffffffff\", 16);\n/**\n * The max integer that the evm can handle (2^256-1)\n */ exports.MAX_INTEGER = new externals_1.BN(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n/**\n * 2^256\n */ exports.TWO_POW256 = new externals_1.BN(\"10000000000000000000000000000000000000000000000000000000000000000\", 16);\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL = buffer_1.Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY = buffer_1.Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP = buffer_1.Buffer.from(exports.KECCAK256_RLP_S, \"hex\"); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDek8sTUFBTVcsV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQWE7QUFDekM7O0NBRUMsR0FDRFosa0JBQWtCLEdBQUcsSUFBSWEsWUFBWUMsRUFBRSxDQUFDLG9CQUFvQjtBQUM1RDs7Q0FFQyxHQUNEZCxtQkFBbUIsR0FBRyxJQUFJYSxZQUFZQyxFQUFFLENBQUMsb0VBQW9FO0FBQzdHOztDQUVDLEdBQ0RkLGtCQUFrQixHQUFHLElBQUlhLFlBQVlDLEVBQUUsQ0FBQyxxRUFBcUU7QUFDN0c7O0NBRUMsR0FDRGQsd0JBQXdCLEdBQUc7QUFDM0I7O0NBRUMsR0FDREEsc0JBQXNCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUU8sZ0JBQWdCLEVBQUU7QUFDeEU7O0NBRUMsR0FDRFAsNkJBQTZCLEdBQUc7QUFDaEM7O0NBRUMsR0FDREEsMkJBQTJCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUUsscUJBQXFCLEVBQUU7QUFDbEY7O0NBRUMsR0FDREwsdUJBQXVCLEdBQUc7QUFDMUI7O0NBRUMsR0FDREEscUJBQXFCLEdBQUdXLFNBQVNJLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDaEIsUUFBUUcsZUFBZSxFQUFFLFFBQ3RFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9jb25zdGFudHMuanM/YzE0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gZXhwb3J0cy5UV09fUE9XMjU2ID0gZXhwb3J0cy5NQVhfSU5URUdFUiA9IGV4cG9ydHMuTUFYX1VJTlQ2NCA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmNvbnN0IGV4dGVybmFsc18xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpO1xuLyoqXG4gKiAyXjY0LTFcbiAqL1xuZXhwb3J0cy5NQVhfVUlOVDY0ID0gbmV3IGV4dGVybmFsc18xLkJOKCdmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuLyoqXG4gKiBUaGUgbWF4IGludGVnZXIgdGhhdCB0aGUgZXZtIGNhbiBoYW5kbGUgKDJeMjU2LTEpXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG4vKipcbiAqIDJeMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBleHRlcm5hbHNfMS5CTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3Jztcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIktFQ0NBSzI1Nl9STFAiLCJLRUNDQUsyNTZfUkxQX1MiLCJLRUNDQUsyNTZfUkxQX0FSUkFZIiwiS0VDQ0FLMjU2X1JMUF9BUlJBWV9TIiwiS0VDQ0FLMjU2X05VTEwiLCJLRUNDQUsyNTZfTlVMTF9TIiwiVFdPX1BPVzI1NiIsIk1BWF9JTlRFR0VSIiwiTUFYX1VJTlQ2NCIsImJ1ZmZlcl8xIiwicmVxdWlyZSIsImV4dGVybmFsc18xIiwiQk4iLCJCdWZmZXIiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/externals.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/externals.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Re-exports commonly used modules:\n * * Exports [`BN`](https://github.com/indutny/bn.js), [`rlp`](https://github.com/ethereumjs/rlp).\n * @packageDocumentation\n */ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlp = exports.BN = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\"));\nexports.BN = bn_js_1.default;\nconst rlp = __importStar(__webpack_require__(/*! rlp */ \"(ssr)/./node_modules/rlp/dist/index.js\"));\nexports.rlp = rlp; //# sourceMappingURL=externals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvZXh0ZXJuYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Q0FJQyxHQUNELElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFVQyxHQUFHO0lBQzNELElBQUlBLE9BQU9BLElBQUlWLFVBQVUsRUFBRSxPQUFPVTtJQUNsQyxJQUFJQyxTQUFTLENBQUM7SUFDZCxJQUFJRCxPQUFPLE1BQU07UUFBQSxJQUFLLElBQUlmLEtBQUtlLElBQUssSUFBSWYsTUFBTSxhQUFhSixPQUFPcUIsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osS0FBS2YsSUFBSUwsZ0JBQWdCcUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0EsSUFBSUksa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVMLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJVixVQUFVLEdBQUlVLE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FuQiw4Q0FBNkM7SUFBRWlCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RRLFdBQVcsR0FBR0EsVUFBVSxHQUFHLEtBQUs7QUFDaEMsTUFBTUcsVUFBVUosZ0JBQWdCSyxtQkFBT0EsQ0FBQyxtREFBTztBQUMvQ0osVUFBVSxHQUFHRyxRQUFRRSxPQUFPO0FBQzVCLE1BQU1KLE1BQU1SLGFBQWFXLG1CQUFPQSxDQUFDLG1EQUFLO0FBQ3RDSixXQUFXLEdBQUdDLEtBQ2QscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2V4dGVybmFscy5qcz9jODQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBSZS1leHBvcnRzIGNvbW1vbmx5IHVzZWQgbW9kdWxlczpcbiAqICogRXhwb3J0cyBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpLCBbYHJscGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscCkuXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJscCA9IGV4cG9ydHMuQk4gPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5leHBvcnRzLkJOID0gYm5fanNfMS5kZWZhdWx0O1xuY29uc3QgcmxwID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJybHBcIikpO1xuZXhwb3J0cy5ybHAgPSBybHA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlcm5hbHMuanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJybHAiLCJCTiIsImJuX2pzXzEiLCJyZXF1aXJlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/externals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/hash.js":
/*!***************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/hash.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlphash = exports.ripemd160FromArray = exports.ripemd160FromString = exports.ripemd160 = exports.sha256FromArray = exports.sha256FromString = exports.sha256 = exports.keccakFromArray = exports.keccakFromHexString = exports.keccakFromString = exports.keccak256 = exports.keccak = void 0;\nconst keccak_1 = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\");\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\n/**\n * Creates Keccak hash of a Buffer input\n * @param a The input data (Buffer)\n * @param bits (number = 256) The Keccak width\n */ const keccak = function(a, bits = 256) {\n    (0, helpers_1.assertIsBuffer)(a);\n    switch(bits){\n        case 224:\n            {\n                return (0, keccak_1.keccak224)(a);\n            }\n        case 256:\n            {\n                return (0, keccak_1.keccak256)(a);\n            }\n        case 384:\n            {\n                return (0, keccak_1.keccak384)(a);\n            }\n        case 512:\n            {\n                return (0, keccak_1.keccak512)(a);\n            }\n        default:\n            {\n                throw new Error(`Invald algorithm: keccak${bits}`);\n            }\n    }\n};\nexports.keccak = keccak;\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer)\n */ const keccak256 = function(a) {\n    return (0, exports.keccak)(a);\n};\nexports.keccak256 = keccak256;\n/**\n * Creates Keccak hash of a utf-8 string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromString = function(a, bits = 256) {\n    (0, helpers_1.assertIsString)(a);\n    const buf = Buffer.from(a, \"utf8\");\n    return (0, exports.keccak)(buf, bits);\n};\nexports.keccakFromString = keccakFromString;\n/**\n * Creates Keccak hash of an 0x-prefixed string input\n * @param a The input data (String)\n * @param bits (number = 256) The Keccak width\n */ const keccakFromHexString = function(a, bits = 256) {\n    (0, helpers_1.assertIsHexString)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromHexString = keccakFromHexString;\n/**\n * Creates Keccak hash of a number array input\n * @param a The input data (number[])\n * @param bits (number = 256) The Keccak width\n */ const keccakFromArray = function(a, bits = 256) {\n    (0, helpers_1.assertIsArray)(a);\n    return (0, exports.keccak)((0, bytes_1.toBuffer)(a), bits);\n};\nexports.keccakFromArray = keccakFromArray;\n/**\n * Creates SHA256 hash of an input.\n * @param  a The input data (Buffer|Array|String)\n */ const _sha256 = function(a) {\n    a = (0, bytes_1.toBuffer)(a);\n    return createHash(\"sha256\").update(a).digest();\n};\n/**\n * Creates SHA256 hash of a Buffer input.\n * @param a The input data (Buffer)\n */ const sha256 = function(a) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _sha256(a);\n};\nexports.sha256 = sha256;\n/**\n * Creates SHA256 hash of a string input.\n * @param a The input data (string)\n */ const sha256FromString = function(a) {\n    (0, helpers_1.assertIsString)(a);\n    return _sha256(a);\n};\nexports.sha256FromString = sha256FromString;\n/**\n * Creates SHA256 hash of a number[] input.\n * @param a The input data (number[])\n */ const sha256FromArray = function(a) {\n    (0, helpers_1.assertIsArray)(a);\n    return _sha256(a);\n};\nexports.sha256FromArray = sha256FromArray;\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */ const _ripemd160 = function(a, padded) {\n    a = (0, bytes_1.toBuffer)(a);\n    const hash = createHash(\"rmd160\").update(a).digest();\n    if (padded === true) {\n        return (0, bytes_1.setLengthLeft)(hash, 32);\n    } else {\n        return hash;\n    }\n};\n/**\n * Creates RIPEMD160 hash of a Buffer input.\n * @param a The input data (Buffer)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160 = function(a, padded) {\n    (0, helpers_1.assertIsBuffer)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160 = ripemd160;\n/**\n * Creates RIPEMD160 hash of a string input.\n * @param a The input data (String)\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromString = function(a, padded) {\n    (0, helpers_1.assertIsString)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromString = ripemd160FromString;\n/**\n * Creates RIPEMD160 hash of a number[] input.\n * @param a The input data (number[])\n * @param padded Whether it should be padded to 256 bits or not\n */ const ripemd160FromArray = function(a, padded) {\n    (0, helpers_1.assertIsArray)(a);\n    return _ripemd160(a, padded);\n};\nexports.ripemd160FromArray = ripemd160FromArray;\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */ const rlphash = function(a) {\n    return (0, exports.keccak)(externals_1.rlp.encode(a));\n};\nexports.rlphash = rlphash; //# sourceMappingURL=hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHQSwwQkFBMEIsR0FBR0EsMkJBQTJCLEdBQUdBLGlCQUFpQixHQUFHQSx1QkFBdUIsR0FBR0Esd0JBQXdCLEdBQUdBLGNBQWMsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ3BTLE1BQU1jLFdBQVdDLG1CQUFPQSxDQUFDLDBGQUE4QjtBQUN2RCxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQywyRUFBYTtBQUN6QyxNQUFNRyxVQUFVSCxtQkFBT0EsQ0FBQyxtRUFBUztBQUNqQyxNQUFNSSxZQUFZSixtQkFBT0EsQ0FBQyx1RUFBVztBQUNyQzs7OztDQUlDLEdBQ0QsTUFBTUYsU0FBUyxTQUFVTyxDQUFDLEVBQUVDLE9BQU8sR0FBRztJQUNqQyxJQUFHRixVQUFVRyxjQUFjLEVBQUVGO0lBQzlCLE9BQVFDO1FBQ0osS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHUCxTQUFTUyxTQUFTLEVBQUVIO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTRixTQUFTLEVBQUVRO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTVSxTQUFTLEVBQUVKO1lBQ25DO1FBQ0EsS0FBSztZQUFLO2dCQUNOLE9BQU8sQ0FBQyxHQUFHTixTQUFTVyxTQUFTLEVBQUVMO1lBQ25DO1FBQ0E7WUFBUztnQkFDTCxNQUFNLElBQUlNLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUwsS0FBSyxDQUFDO1lBQ3JEO0lBQ0o7QUFDSjtBQUNBckIsY0FBYyxHQUFHYTtBQUNq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Q0F0QywwQkFBMEIsR0FBR0c7QUFDN0I7OztDQUdDLEdBQ0QsTUFBTUQsVUFBVSxTQUFVa0IsQ0FBQztJQUN2QixPQUFPLENBQUMsR0FBR3BCLFFBQVFhLE1BQU0sRUFBRUksWUFBWXdCLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDdEI7QUFDdEQ7QUFDQXBCLGVBQWUsR0FBR0UsU0FDbEIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2hhc2guanM/YzlhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmxwaGFzaCA9IGV4cG9ydHMucmlwZW1kMTYwRnJvbUFycmF5ID0gZXhwb3J0cy5yaXBlbWQxNjBGcm9tU3RyaW5nID0gZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLnNoYTI1NkZyb21BcnJheSA9IGV4cG9ydHMuc2hhMjU2RnJvbVN0cmluZyA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5rZWNjYWtGcm9tQXJyYXkgPSBleHBvcnRzLmtlY2Nha0Zyb21IZXhTdHJpbmcgPSBleHBvcnRzLmtlY2Nha0Zyb21TdHJpbmcgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrID0gdm9pZCAwO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIGEgQnVmZmVyIGlucHV0XG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyKVxuICogQHBhcmFtIGJpdHMgKG51bWJlciA9IDI1NikgVGhlIEtlY2NhayB3aWR0aFxuICovXG5jb25zdCBrZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cyA9IDI1Nikge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKGEpO1xuICAgIHN3aXRjaCAoYml0cykge1xuICAgICAgICBjYXNlIDIyNDoge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBrZWNjYWtfMS5rZWNjYWsyMjQpKGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjU2OiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGtlY2Nha18xLmtlY2NhazI1NikoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzODQ6IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwga2VjY2FrXzEua2VjY2FrMzg0KShhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDUxMjoge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBrZWNjYWtfMS5rZWNjYWs1MTIpKGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxkIGFsZ29yaXRobToga2VjY2FrJHtiaXRzfWApO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMua2VjY2FrID0ga2VjY2FrO1xuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KS5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXIpXG4gKi9cbmNvbnN0IGtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmtlY2NhaykoYSk7XG59O1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBrZWNjYWsyNTY7XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgYSB1dGYtOCBzdHJpbmcgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChTdHJpbmcpXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmNvbnN0IGtlY2Nha0Zyb21TdHJpbmcgPSBmdW5jdGlvbiAoYSwgYml0cyA9IDI1Nikge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGEpO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKGEsICd1dGY4Jyk7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmtlY2NhaykoYnVmLCBiaXRzKTtcbn07XG5leHBvcnRzLmtlY2Nha0Zyb21TdHJpbmcgPSBrZWNjYWtGcm9tU3RyaW5nO1xuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIGFuIDB4LXByZWZpeGVkIHN0cmluZyBpbnB1dFxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKFN0cmluZylcbiAqIEBwYXJhbSBiaXRzIChudW1iZXIgPSAyNTYpIFRoZSBLZWNjYWsgd2lkdGhcbiAqL1xuY29uc3Qga2VjY2FrRnJvbUhleFN0cmluZyA9IGZ1bmN0aW9uIChhLCBiaXRzID0gMjU2KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0hleFN0cmluZykoYSk7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmtlY2NhaykoKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGEpLCBiaXRzKTtcbn07XG5leHBvcnRzLmtlY2Nha0Zyb21IZXhTdHJpbmcgPSBrZWNjYWtGcm9tSGV4U3RyaW5nO1xuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIGEgbnVtYmVyIGFycmF5IGlucHV0XG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAobnVtYmVyW10pXG4gKiBAcGFyYW0gYml0cyAobnVtYmVyID0gMjU2KSBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmNvbnN0IGtlY2Nha0Zyb21BcnJheSA9IGZ1bmN0aW9uIChhLCBiaXRzID0gMjU2KSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KShhKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMua2VjY2FrKSgoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYSksIGJpdHMpO1xufTtcbmV4cG9ydHMua2VjY2FrRnJvbUFycmF5ID0ga2VjY2FrRnJvbUFycmF5O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGFuIGlucHV0LlxuICogQHBhcmFtICBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICovXG5jb25zdCBfc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBhID0gKDAsIGJ5dGVzXzEudG9CdWZmZXIpKGEpO1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIGEgQnVmZmVyIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqL1xuY29uc3Qgc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQnVmZmVyKShhKTtcbiAgICByZXR1cm4gX3NoYTI1NihhKTtcbn07XG5leHBvcnRzLnNoYTI1NiA9IHNoYTI1Njtcbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiBhIHN0cmluZyBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChzdHJpbmcpXG4gKi9cbmNvbnN0IHNoYTI1NkZyb21TdHJpbmcgPSBmdW5jdGlvbiAoYSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNTdHJpbmcpKGEpO1xuICAgIHJldHVybiBfc2hhMjU2KGEpO1xufTtcbmV4cG9ydHMuc2hhMjU2RnJvbVN0cmluZyA9IHNoYTI1NkZyb21TdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgYSBudW1iZXJbXSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcbiAqL1xuY29uc3Qgc2hhMjU2RnJvbUFycmF5ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzQXJyYXkpKGEpO1xuICAgIHJldHVybiBfc2hhMjU2KGEpO1xufTtcbmV4cG9ydHMuc2hhMjU2RnJvbUFycmF5ID0gc2hhMjU2RnJvbUFycmF5O1xuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcilcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5jb25zdCBfcmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICAgIGEgPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoYSk7XG4gICAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiAoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShoYXNoLCAzMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIGEgQnVmZmVyIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcilcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5jb25zdCByaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0J1ZmZlcikoYSk7XG4gICAgcmV0dXJuIF9yaXBlbWQxNjAoYSwgcGFkZGVkKTtcbn07XG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiBhIHN0cmluZyBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChTdHJpbmcpXG4gKiBAcGFyYW0gcGFkZGVkIFdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqL1xuY29uc3QgcmlwZW1kMTYwRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICAoMCwgaGVscGVyc18xLmFzc2VydElzU3RyaW5nKShhKTtcbiAgICByZXR1cm4gX3JpcGVtZDE2MChhLCBwYWRkZWQpO1xufTtcbmV4cG9ydHMucmlwZW1kMTYwRnJvbVN0cmluZyA9IHJpcGVtZDE2MEZyb21TdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgYSBudW1iZXJbXSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChudW1iZXJbXSlcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5jb25zdCByaXBlbWQxNjBGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gICAgKDAsIGhlbHBlcnNfMS5hc3NlcnRJc0FycmF5KShhKTtcbiAgICByZXR1cm4gX3JpcGVtZDE2MChhLCBwYWRkZWQpO1xufTtcbmV4cG9ydHMucmlwZW1kMTYwRnJvbUFycmF5ID0gcmlwZW1kMTYwRnJvbUFycmF5O1xuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGFcbiAqL1xuY29uc3QgcmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmtlY2NhaykoZXh0ZXJuYWxzXzEucmxwLmVuY29kZShhKSk7XG59O1xuZXhwb3J0cy5ybHBoYXNoID0gcmxwaGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmxwaGFzaCIsInJpcGVtZDE2MEZyb21BcnJheSIsInJpcGVtZDE2MEZyb21TdHJpbmciLCJyaXBlbWQxNjAiLCJzaGEyNTZGcm9tQXJyYXkiLCJzaGEyNTZGcm9tU3RyaW5nIiwic2hhMjU2Iiwia2VjY2FrRnJvbUFycmF5Iiwia2VjY2FrRnJvbUhleFN0cmluZyIsImtlY2Nha0Zyb21TdHJpbmciLCJrZWNjYWsyNTYiLCJrZWNjYWsiLCJrZWNjYWtfMSIsInJlcXVpcmUiLCJjcmVhdGVIYXNoIiwiZXh0ZXJuYWxzXzEiLCJieXRlc18xIiwiaGVscGVyc18xIiwiYSIsImJpdHMiLCJhc3NlcnRJc0J1ZmZlciIsImtlY2NhazIyNCIsImtlY2NhazM4NCIsImtlY2NhazUxMiIsIkVycm9yIiwiYXNzZXJ0SXNTdHJpbmciLCJidWYiLCJCdWZmZXIiLCJmcm9tIiwiYXNzZXJ0SXNIZXhTdHJpbmciLCJ0b0J1ZmZlciIsImFzc2VydElzQXJyYXkiLCJfc2hhMjU2IiwidXBkYXRlIiwiZGlnZXN0IiwiX3JpcGVtZDE2MCIsInBhZGRlZCIsImhhc2giLCJzZXRMZW5ndGhMZWZ0IiwicmxwIiwiZW5jb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/helpers.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/helpers.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertIsString = exports.assertIsArray = exports.assertIsBuffer = exports.assertIsHexString = void 0;\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */ const assertIsHexString = function(input) {\n    if (!(0, internal_1.isHexString)(input)) {\n        const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsHexString = assertIsHexString;\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */ const assertIsBuffer = function(input) {\n    if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsBuffer = assertIsBuffer;\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */ const assertIsArray = function(input) {\n    if (!Array.isArray(input)) {\n        const msg = `This method only supports number arrays but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsArray = assertIsArray;\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */ const assertIsString = function(input) {\n    if (typeof input !== \"string\") {\n        const msg = `This method only supports strings but input was: ${input}`;\n        throw new Error(msg);\n    }\n};\nexports.assertIsString = assertIsString; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMzRyxNQUFNTSxhQUFhQyxtQkFBT0EsQ0FBQyx5RUFBWTtBQUN2Qzs7O0NBR0MsR0FDRCxNQUFNRixvQkFBb0IsU0FBVUcsS0FBSztJQUNyQyxJQUFJLENBQUMsQ0FBQyxHQUFHRixXQUFXRyxXQUFXLEVBQUVELFFBQVE7UUFDckMsTUFBTUUsTUFBTSxDQUFDLGlFQUFpRSxFQUFFRixNQUFNLENBQUM7UUFDdkYsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHlCQUF5QixHQUFHSztBQUM1Qjs7O0NBR0MsR0FDRCxNQUFNRCxpQkFBaUIsU0FBVUksS0FBSztJQUNsQyxJQUFJLENBQUNJLE9BQU9DLFFBQVEsQ0FBQ0wsUUFBUTtRQUN6QixNQUFNRSxNQUFNLENBQUMsZ0RBQWdELEVBQUVGLE1BQU0sQ0FBQztRQUN0RSxNQUFNLElBQUlHLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQVYsc0JBQXNCLEdBQUdJO0FBQ3pCOzs7Q0FHQyxHQUNELE1BQU1ELGdCQUFnQixTQUFVSyxLQUFLO0lBQ2pDLElBQUksQ0FBQ00sTUFBTUMsT0FBTyxDQUFDUCxRQUFRO1FBQ3ZCLE1BQU1FLE1BQU0sQ0FBQyx1REFBdUQsRUFBRUYsTUFBTSxDQUFDO1FBQzdFLE1BQU0sSUFBSUcsTUFBTUQ7SUFDcEI7QUFDSjtBQUNBVixxQkFBcUIsR0FBR0c7QUFDeEI7OztDQUdDLEdBQ0QsTUFBTUQsaUJBQWlCLFNBQVVNLEtBQUs7SUFDbEMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsTUFBTUUsTUFBTSxDQUFDLGlEQUFpRCxFQUFFRixNQUFNLENBQUM7UUFDdkUsTUFBTSxJQUFJRyxNQUFNRDtJQUNwQjtBQUNKO0FBQ0FWLHNCQUFzQixHQUFHRSxnQkFDekIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2hlbHBlcnMuanM/NGJlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0SXNTdHJpbmcgPSBleHBvcnRzLmFzc2VydElzQXJyYXkgPSBleHBvcnRzLmFzc2VydElzQnVmZmVyID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbi8qKlxuICogVGhyb3dzIGlmIGEgc3RyaW5nIGlzIG5vdCBoZXggcHJlZml4ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBzdHJpbmcgdG8gY2hlY2sgaGV4IHByZWZpeCBvZlxuICovXG5jb25zdCBhc3NlcnRJc0hleFN0cmluZyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghKDAsIGludGVybmFsXzEuaXNIZXhTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyAweC1wcmVmaXhlZCBoZXggc3RyaW5ncyBidXQgaW5wdXQgd2FzOiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn07XG5leHBvcnRzLmFzc2VydElzSGV4U3RyaW5nID0gYXNzZXJ0SXNIZXhTdHJpbmc7XG4vKipcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYSBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dCB2YWx1ZSB0byBjaGVja1xuICovXG5jb25zdCBhc3NlcnRJc0J1ZmZlciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBCdWZmZXIgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc0J1ZmZlciA9IGFzc2VydElzQnVmZmVyO1xuLyoqXG4gKiBUaHJvd3MgaWYgaW5wdXQgaXMgbm90IGFuIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcltdfSBpbnB1dCB2YWx1ZSB0byBjaGVja1xuICovXG5jb25zdCBhc3NlcnRJc0FycmF5ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyBudW1iZXIgYXJyYXlzIGJ1dCBpbnB1dCB3YXM6ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0SXNBcnJheSA9IGFzc2VydElzQXJyYXk7XG4vKipcbiAqIFRocm93cyBpZiBpbnB1dCBpcyBub3QgYSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCB2YWx1ZSB0byBjaGVja1xuICovXG5jb25zdCBhc3NlcnRJc1N0cmluZyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIHN0cmluZ3MgYnV0IGlucHV0IHdhczogJHtpbnB1dH1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRJc1N0cmluZyA9IGFzc2VydElzU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhc3NlcnRJc1N0cmluZyIsImFzc2VydElzQXJyYXkiLCJhc3NlcnRJc0J1ZmZlciIsImFzc2VydElzSGV4U3RyaW5nIiwiaW50ZXJuYWxfMSIsInJlcXVpcmUiLCJpbnB1dCIsImlzSGV4U3RyaW5nIiwibXNnIiwiRXJyb3IiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5IiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Constants\n */ __exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethereumjs-util/dist/constants.js\"), exports);\n/**\n * Account class and helper functions\n */ __exportStar(__webpack_require__(/*! ./account */ \"(ssr)/./node_modules/ethereumjs-util/dist/account.js\"), exports);\n/**\n * Address type\n */ __exportStar(__webpack_require__(/*! ./address */ \"(ssr)/./node_modules/ethereumjs-util/dist/address.js\"), exports);\n/**\n * Hash functions\n */ __exportStar(__webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\"), exports);\n/**\n * ECDSA signature\n */ __exportStar(__webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/ethereumjs-util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */ __exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\"), exports);\n/**\n * Function for definining properties on an object\n */ __exportStar(__webpack_require__(/*! ./object */ \"(ssr)/./node_modules/ethereumjs-util/dist/object.js\"), exports);\n/**\n * External exports (BN, rlp)\n */ __exportStar(__webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\"), exports);\n/**\n * Helpful TypeScript types\n */ __exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\"), exports);\n/**\n * Export ethjs-util methods\n */ var internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nObject.defineProperty(exports, \"isHexPrefixed\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexPrefixed;\n    }\n}));\nObject.defineProperty(exports, \"stripHexPrefix\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.stripHexPrefix;\n    }\n}));\nObject.defineProperty(exports, \"padToEven\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.padToEven;\n    }\n}));\nObject.defineProperty(exports, \"getBinarySize\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getBinarySize;\n    }\n}));\nObject.defineProperty(exports, \"arrayContainsArray\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.arrayContainsArray;\n    }\n}));\nObject.defineProperty(exports, \"toAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.toAscii;\n    }\n}));\nObject.defineProperty(exports, \"fromUtf8\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromUtf8;\n    }\n}));\nObject.defineProperty(exports, \"fromAscii\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.fromAscii;\n    }\n}));\nObject.defineProperty(exports, \"getKeys\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.getKeys;\n    }\n}));\nObject.defineProperty(exports, \"isHexString\", ({\n    enumerable: true,\n    get: function() {\n        return internal_1.isHexString;\n    }\n})); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RMLG1CQUFtQixHQUFHQSxlQUFlLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZUFBZSxHQUFHQSwwQkFBMEIsR0FBR0EscUJBQXFCLEdBQUdBLGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUNoTzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsMkVBQWEsR0FBR2hCO0FBQ3JDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQyx1RUFBVyxHQUFHaEI7QUFDbkM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLHVFQUFXLEdBQUdoQjtBQUNuQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMsaUVBQVEsR0FBR2hCO0FBQ2hDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQywyRUFBYSxHQUFHaEI7QUFDckM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLG1FQUFTLEdBQUdoQjtBQUNqQzs7Q0FFQyxHQUNERCxhQUFhaUIsbUJBQU9BLENBQUMscUVBQVUsR0FBR2hCO0FBQ2xDOztDQUVDLEdBQ0RELGFBQWFpQixtQkFBT0EsQ0FBQywyRUFBYSxHQUFHaEI7QUFDckM7O0NBRUMsR0FDREQsYUFBYWlCLG1CQUFPQSxDQUFDLG1FQUFTLEdBQUdoQjtBQUNqQzs7Q0FFQyxHQUNELElBQUlpQixhQUFhRCxtQkFBT0EsQ0FBQyx5RUFBWTtBQUNyQ2hDLGlEQUFnRDtJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0YsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVIL0Isa0RBQWlEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXSCxjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUg5Qiw2Q0FBNEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdKLFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNwSDdCLGlEQUFnRDtJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV0wsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzVINUIsc0RBQXFEO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXTixrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN0STNCLDJDQUEwQztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1AsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hIMUIsNENBQTJDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXUixRQUFRO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEh6Qiw2Q0FBNEM7SUFBRVksWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFdBQVdULFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNwSHhCLDJDQUEwQztJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPb0IsV0FBV1YsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2hIdkIsK0NBQThDO0lBQUVZLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixXQUFXWCxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDeEgsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2luZGV4LmpzPzA4YmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBleHBvcnRzLmdldEtleXMgPSBleHBvcnRzLmZyb21Bc2NpaSA9IGV4cG9ydHMuZnJvbVV0ZjggPSBleHBvcnRzLnRvQXNjaWkgPSBleHBvcnRzLmFycmF5Q29udGFpbnNBcnJheSA9IGV4cG9ydHMuZ2V0QmluYXJ5U2l6ZSA9IGV4cG9ydHMucGFkVG9FdmVuID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IGV4cG9ydHMuaXNIZXhQcmVmaXhlZCA9IHZvaWQgMDtcbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25zdGFudHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBBY2NvdW50IGNsYXNzIGFuZCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hY2NvdW50XCIpLCBleHBvcnRzKTtcbi8qKlxuICogQWRkcmVzcyB0eXBlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGRyZXNzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogSGFzaCBmdW5jdGlvbnNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hhc2hcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFQ0RTQSBzaWduYXR1cmVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ25hdHVyZVwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIEJ1ZmZlcnMsIGJ5dGUgYXJyYXlzLCBldGMuXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEZ1bmN0aW9uIGZvciBkZWZpbmluaW5nIHByb3BlcnRpZXMgb24gYW4gb2JqZWN0XG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vYmplY3RcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFeHRlcm5hbCBleHBvcnRzIChCTiwgcmxwKVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXh0ZXJuYWxzXCIpLCBleHBvcnRzKTtcbi8qKlxuICogSGVscGZ1bCBUeXBlU2NyaXB0IHR5cGVzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEV4cG9ydCBldGhqcy11dGlsIG1ldGhvZHNcbiAqL1xudmFyIGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSGV4UHJlZml4ZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuaXNIZXhQcmVmaXhlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmlwSGV4UHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFkVG9FdmVuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnBhZFRvRXZlbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJpbmFyeVNpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsXzEuZ2V0QmluYXJ5U2l6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFycmF5Q29udGFpbnNBcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5hcnJheUNvbnRhaW5zQXJyYXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0FzY2lpXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLnRvQXNjaWk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmcm9tVXRmOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5mcm9tVXRmODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZyb21Bc2NpaVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5mcm9tQXNjaWk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRLZXlzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF8xLmdldEtleXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hleFN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfMS5pc0hleFN0cmluZzsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJleHBvcnRzIiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwiaXNIZXhTdHJpbmciLCJnZXRLZXlzIiwiZnJvbUFzY2lpIiwiZnJvbVV0ZjgiLCJ0b0FzY2lpIiwiYXJyYXlDb250YWluc0FycmF5IiwiZ2V0QmluYXJ5U2l6ZSIsInBhZFRvRXZlbiIsInN0cmlwSGV4UHJlZml4IiwiaXNIZXhQcmVmaXhlZCIsInJlcXVpcmUiLCJpbnRlcm5hbF8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/internal.js":
/*!*******************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/internal.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.arrayContainsArray = exports.getBinarySize = exports.padToEven = exports.stripHexPrefix = exports.isHexPrefixed = void 0;\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */ function isHexPrefixed(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n    }\n    return str[0] === \"0\" && str[1] === \"x\";\n}\nexports.isHexPrefixed = isHexPrefixed;\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */ const stripHexPrefix = (str)=>{\n    if (typeof str !== \"string\") throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\nexports.stripHexPrefix = stripHexPrefix;\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */ function padToEven(value) {\n    let a = value;\n    if (typeof a !== \"string\") {\n        throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n    }\n    if (a.length % 2) a = `0${a}`;\n    return a;\n}\nexports.padToEven = padToEven;\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */ function getBinarySize(str) {\n    if (typeof str !== \"string\") {\n        throw new Error(`[getBinarySize] method requires input type 'string', recieved ${typeof str}`);\n    }\n    return Buffer.byteLength(str, \"utf8\");\n}\nexports.getBinarySize = getBinarySize;\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */ function arrayContainsArray(superset, subset, some) {\n    if (Array.isArray(superset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`);\n    }\n    if (Array.isArray(subset) !== true) {\n        throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`);\n    }\n    return subset[some ? \"some\" : \"every\"]((value)=>superset.indexOf(value) >= 0);\n}\nexports.arrayContainsArray = arrayContainsArray;\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */ function toAscii(hex) {\n    let str = \"\";\n    let i = 0;\n    const l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") i = 2;\n    for(; i < l; i += 2){\n        const code = parseInt(hex.substr(i, 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n}\nexports.toAscii = toAscii;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */ function fromUtf8(stringValue) {\n    const str = Buffer.from(stringValue, \"utf8\");\n    return `0x${padToEven(str.toString(\"hex\")).replace(/^0+|0+$/g, \"\")}`;\n}\nexports.fromUtf8 = fromUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */ function fromAscii(stringValue) {\n    let hex = \"\";\n    for(let i = 0; i < stringValue.length; i++){\n        const code = stringValue.charCodeAt(i);\n        const n = code.toString(16);\n        hex += n.length < 2 ? `0${n}` : n;\n    }\n    return `0x${hex}`;\n}\nexports.fromAscii = fromAscii;\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */ function getKeys(params, key, allowEmpty) {\n    if (!Array.isArray(params)) {\n        throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof params}`);\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`);\n    }\n    const result = [];\n    for(let i = 0; i < params.length; i++){\n        let value = params[i][key];\n        if (allowEmpty && !value) {\n            value = \"\";\n        } else if (typeof value !== \"string\") {\n            throw new Error(`invalid abi - expected type 'string', received ${typeof value}`);\n        }\n        result.push(value);\n    }\n    return result;\n}\nexports.getKeys = getKeys;\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */ function isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n    if (length && value.length !== 2 + 2 * length) return false;\n    return true;\n}\nexports.isHexString = isHexString; //# sourceMappingURL=internal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxlQUFlLEdBQUdBLDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBR0EsaUJBQWlCLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ2hPOzs7OztDQUtDLEdBQ0QsU0FBU1csY0FBY0MsR0FBRztJQUN0QixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUN6QixNQUFNLElBQUlDLE1BQU0sQ0FBQywyREFBMkQsRUFBRSxPQUFPRCxJQUFJLENBQUM7SUFDOUY7SUFDQSxPQUFPQSxHQUFHLENBQUMsRUFBRSxLQUFLLE9BQU9BLEdBQUcsQ0FBQyxFQUFFLEtBQUs7QUFDeEM7QUFDQVoscUJBQXFCLEdBQUdXO0FBQ3hCOzs7O0NBSUMsR0FDRCxNQUFNRCxpQkFBaUIsQ0FBQ0U7SUFDcEIsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJQyxNQUFNLENBQUMsdURBQXVELEVBQUUsT0FBT0QsSUFBSSxDQUFDO0lBQzFGLE9BQU9ELGNBQWNDLE9BQU9BLElBQUlFLEtBQUssQ0FBQyxLQUFLRjtBQUMvQztBQUNBWixzQkFBc0IsR0FBR1U7QUFDekI7Ozs7Q0FJQyxHQUNELFNBQVNELFVBQVVSLEtBQUs7SUFDcEIsSUFBSWMsSUFBSWQ7SUFDUixJQUFJLE9BQU9jLE1BQU0sVUFBVTtRQUN2QixNQUFNLElBQUlGLE1BQU0sQ0FBQyxrREFBa0QsRUFBRSxPQUFPRSxFQUFFLENBQUM7SUFDbkY7SUFDQSxJQUFJQSxFQUFFQyxNQUFNLEdBQUcsR0FDWEQsSUFBSSxDQUFDLENBQUMsRUFBRUEsRUFBRSxDQUFDO0lB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YyxDQUFDekMsT0FBTztZQUN0QkEsUUFBUTtRQUNaLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDaEMsTUFBTSxJQUFJWSxNQUFNLENBQUMsK0NBQStDLEVBQUUsT0FBT1osTUFBTSxDQUFDO1FBQ3BGO1FBQ0EwQyxPQUFPQyxJQUFJLENBQUMzQztJQUNoQjtJQUNBLE9BQU8wQztBQUNYO0FBQ0EzQyxlQUFlLEdBQUdHO0FBQ2xCOzs7Ozs7Q0FNQyxHQUNELFNBQVNELFlBQVlELEtBQUssRUFBRWUsTUFBTTtJQUM5QixJQUFJLE9BQU9mLFVBQVUsWUFBWSxDQUFDQSxNQUFNNEMsS0FBSyxDQUFDLHFCQUMxQyxPQUFPO0lBQ1gsSUFBSTdCLFVBQVVmLE1BQU1lLE1BQU0sS0FBSyxJQUFJLElBQUlBLFFBQ25DLE9BQU87SUFDWCxPQUFPO0FBQ1g7QUFDQWhCLG1CQUFtQixHQUFHRSxhQUN0QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW50ZXJuYWwuanM/MGZmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG5UaGUgTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE2IE5pY2sgRG9kc29uLiBuaWNrZG9kc29uLmNvbVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0hleFN0cmluZyA9IGV4cG9ydHMuZ2V0S2V5cyA9IGV4cG9ydHMuZnJvbUFzY2lpID0gZXhwb3J0cy5mcm9tVXRmOCA9IGV4cG9ydHMudG9Bc2NpaSA9IGV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZXhwb3J0cy5wYWRUb0V2ZW4gPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4ID0gZXhwb3J0cy5pc0hleFByZWZpeGVkID0gdm9pZCAwO1xuLyoqXG4gKiBSZXR1cm5zIGEgYEJvb2xlYW5gIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBhIGBTdHJpbmdgIHN0YXJ0cyB3aXRoICcweCdcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyBpbnB1dCB2YWx1ZVxuICogQHJldHVybiBhIGJvb2xlYW4gaWYgaXQgaXMgb3IgaXMgbm90IGhleCBwcmVmaXhlZFxuICogQHRocm93cyBpZiB0aGUgc3RyIGlucHV0IGlzIG5vdCBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtpc0hleFByZWZpeGVkXSBpbnB1dCBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkIHR5cGUgJHt0eXBlb2Ygc3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyWzBdID09PSAnMCcgJiYgc3RyWzFdID09PSAneCc7XG59XG5leHBvcnRzLmlzSGV4UHJlZml4ZWQgPSBpc0hleFByZWZpeGVkO1xuLyoqXG4gKiBSZW1vdmVzICcweCcgZnJvbSBhIGdpdmVuIGBTdHJpbmdgIGlmIHByZXNlbnRcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB2YWx1ZVxuICogQHJldHVybnMgdGhlIHN0cmluZyB3aXRob3V0IDB4IHByZWZpeFxuICovXG5jb25zdCBzdHJpcEhleFByZWZpeCA9IChzdHIpID0+IHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW3N0cmlwSGV4UHJlZml4XSBpbnB1dCBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIHJlY2VpdmVkICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufTtcbmV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBzdHJpcEhleFByZWZpeDtcbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybiBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gICAgbGV0IGEgPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW3BhZFRvRXZlbl0gdmFsdWUgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiBhfWApO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggJSAyKVxuICAgICAgICBhID0gYDAke2F9YDtcbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydHMucGFkVG9FdmVuID0gcGFkVG9FdmVuO1xuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0gc3RyXG4gKiBAcmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtnZXRCaW5hcnlTaXplXSBtZXRob2QgcmVxdWlyZXMgaW5wdXQgdHlwZSAnc3RyaW5nJywgcmVjaWV2ZWQgJHt0eXBlb2Ygc3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuZXhwb3J0cy5nZXRCaW5hcnlTaXplID0gZ2V0QmluYXJ5U2l6ZTtcbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHN1cGVyc2V0XG4gKiBAcGFyYW0gc3Vic2V0XG4gKlxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFthcnJheUNvbnRhaW5zQXJyYXldIG1ldGhvZCByZXF1aXJlcyBpbnB1dCAnc3VwZXJzZXQnIHRvIGJlIGFuIGFycmF5LCBnb3QgdHlwZSAnJHt0eXBlb2Ygc3VwZXJzZXR9J2ApO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2FycmF5Q29udGFpbnNBcnJheV0gbWV0aG9kIHJlcXVpcmVzIGlucHV0ICdzdWJzZXQnIHRvIGJlIGFuIGFycmF5LCBnb3QgdHlwZSAnJHt0eXBlb2Ygc3Vic2V0fSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNldFtzb21lID8gJ3NvbWUnIDogJ2V2ZXJ5J10oKHZhbHVlKSA9PiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwKTtcbn1cbmV4cG9ydHMuYXJyYXlDb250YWluc0FycmF5ID0gYXJyYXlDb250YWluc0FycmF5O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0cyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMgYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgbCA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpXG4gICAgICAgIGkgPSAyO1xuICAgIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZXhwb3J0cy50b0FzY2lpID0gdG9Bc2NpaTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gc3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICAgIGNvbnN0IHN0ciA9IEJ1ZmZlci5mcm9tKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuICAgIHJldHVybiBgMHgke3BhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKX1gO1xufVxuZXhwb3J0cy5mcm9tVXRmOCA9IGZyb21VdGY4O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gIHN0cmluZ1xuICogQHBhcmFtICBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyAgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgY29uc3QgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gYDAke259YCA6IG47XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleH1gO1xufVxuZXhwb3J0cy5mcm9tQXNjaWkgPSBmcm9tQXNjaWk7XG4vKipcbiAqIFJldHVybnMgdGhlIGtleXMgZnJvbSBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBnZXRLZXlzKFt7YTogJzEnLCBiOiAnMid9LCB7YTogJzMnLCBiOiAnNCd9XSwgJ2EnKSA9PiBbJzEnLCAnMyddXG4gKmBgYGBcbiAqIEBwYXJhbSAgcGFyYW1zXG4gKiBAcGFyYW0gIGtleVxuICogQHBhcmFtICBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbZ2V0S2V5c10gbWV0aG9kIGV4cGVjdHMgaW5wdXQgJ3BhcmFtcycgdG8gYmUgYW4gYXJyYXksIGdvdCAke3R5cGVvZiBwYXJhbXN9YCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtnZXRLZXlzXSBtZXRob2QgZXhwZWN0cyBpbnB1dCAna2V5JyB0byBiZSB0eXBlICdzdHJpbmcnLCBnb3QgJHt0eXBlb2YgcGFyYW1zfWApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTtcbiAgICAgICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhYmkgLSBleHBlY3RlZCB0eXBlICdzdHJpbmcnLCByZWNlaXZlZCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmdldEtleXMgPSBnZXRLZXlzO1xuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHZhbHVlXG4gKiBAcGFyYW0gIGxlbmd0aFxuICogQHJldHVybnMgIG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNIZXhTdHJpbmcgPSBpc0hleFN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzSGV4U3RyaW5nIiwiZ2V0S2V5cyIsImZyb21Bc2NpaSIsImZyb21VdGY4IiwidG9Bc2NpaSIsImFycmF5Q29udGFpbnNBcnJheSIsImdldEJpbmFyeVNpemUiLCJwYWRUb0V2ZW4iLCJzdHJpcEhleFByZWZpeCIsImlzSGV4UHJlZml4ZWQiLCJzdHIiLCJFcnJvciIsInNsaWNlIiwiYSIsImxlbmd0aCIsIkJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJzdXBlcnNldCIsInN1YnNldCIsInNvbWUiLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIiwiaGV4IiwiaSIsImwiLCJzdWJzdHJpbmciLCJjb2RlIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdHJpbmdWYWx1ZSIsImZyb20iLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJjaGFyQ29kZUF0IiwibiIsInBhcmFtcyIsImtleSIsImFsbG93RW1wdHkiLCJyZXN1bHQiLCJwdXNoIiwibWF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/object.js":
/*!*****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/object.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defineProperties = void 0;\nconst assert_1 = __importDefault(__webpack_require__(/*! assert */ \"assert\"));\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */ const defineProperties = function(self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function(label = false) {\n        if (label) {\n            const obj = {};\n            self._fields.forEach((field)=>{\n                obj[field] = `0x${self[field].toString(\"hex\")}`;\n            });\n            return obj;\n        }\n        return (0, bytes_1.baToJSON)(self.raw);\n    };\n    self.serialize = function serialize() {\n        return externals_1.rlp.encode(self.raw);\n    };\n    fields.forEach((field, i)=>{\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = (0, bytes_1.toBuffer)(v);\n            if (v.toString(\"hex\") === \"00\" && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = (0, bytes_1.unpadBuffer)(v);\n                (0, assert_1.default)(field.length >= v.length, `The field ${field.name} must not have more ${field.length} bytes`);\n            } else if (!(field.allowZero && v.length === 0) && field.length) {\n                (0, assert_1.default)(field.length === v.length, `The field ${field.name} must have byte length of ${field.length}`);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === \"string\") {\n            data = Buffer.from((0, internal_1.stripHexPrefix)(data), \"hex\");\n        }\n        if (Buffer.isBuffer(data)) {\n            data = externals_1.rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error(\"wrong number of fields in data\");\n            }\n            // make sure all the items are buffers\n            data.forEach((d, i)=>{\n                self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n            });\n        } else if (typeof data === \"object\") {\n            const keys = Object.keys(data);\n            fields.forEach((field)=>{\n                if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n                if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n            });\n        } else {\n            throw new Error(\"invalid data\");\n        }\n    }\n};\nexports.defineProperties = defineProperties; //# sourceMappingURL=object.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDLE1BQU1HLFdBQVdSLGdCQUFnQlMsbUJBQU9BLENBQUMsc0JBQVE7QUFDakQsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMseUVBQVk7QUFDdkMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUcsVUFBVUgsbUJBQU9BLENBQUMsbUVBQVM7QUFDakM7Ozs7Ozs7Ozs7Q0FVQyxHQUNELE1BQU1GLG1CQUFtQixTQUFVTSxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsSUFBSTtJQUNqREYsS0FBS0csR0FBRyxHQUFHLEVBQUU7SUFDYkgsS0FBS0ksT0FBTyxHQUFHLEVBQUU7SUFDakIsc0JBQXNCO0lBQ3RCSixLQUFLSyxNQUFNLEdBQUcsU0FBVUMsUUFBUSxLQUFLO1FBQ2pDLElBQUlBLE9BQU87WUFDUCxNQUFNQyxNQUFNLENBQUM7WUFDYlAsS0FBS0ksT0FBTyxDQUFDSSxPQUFPLENBQUMsQ0FBQ0M7Z0JBQ2xCRixHQUFHLENBQUNFLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRVQsSUFBSSxDQUFDUyxNQUFNLENBQUNDLFFBQVEsQ0FBQyxPQUFPLENBQUM7WUFDbkQ7WUFDQSxPQUFPSDtRQUNYO1FBQ0EsT0FBTyxDQUFDLEdBQUdSLFFBQVFZLFFBQVEsRUFBRVgsS0FBS0csR0FBRztJQUN6QztJQUNBSCxLQUFLWSxTQUFTLEdBQUcsU0FBU0E7UUFDdEIsT0FBT2QsWUFBWWUsR0FB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QUNTLE1BQU1RLElBQUksQ0FBQyxHQUFHZixJQUFJLENBQUNPLE1BQU1RLElBQUksQ0FBQztnQkFDdkMsSUFBSXlCLEtBQUtDLE9BQU8sQ0FBQ2xDLE1BQU13QixLQUFLLE1BQU0sQ0FBQyxHQUMvQmpDLElBQUksQ0FBQ1MsTUFBTXdCLEtBQUssQ0FBQyxHQUFHL0IsSUFBSSxDQUFDTyxNQUFNd0IsS0FBSyxDQUFDO1lBQzdDO1FBQ0osT0FDSztZQUNELE1BQU0sSUFBSU8sTUFBTTtRQUNwQjtJQUNKO0FBQ0o7QUFDQWhELHdCQUF3QixHQUFHRSxrQkFDM0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L29iamVjdC5qcz80ZDU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBpbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxcIik7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3QgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgICBzZWxmLnJhdyA9IFtdO1xuICAgIHNlbGYuX2ZpZWxkcyA9IFtdO1xuICAgIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBvYmpbZmllbGRdID0gYDB4JHtzZWxmW2ZpZWxkXS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYmFUb0pTT04pKHNlbGYucmF3KTtcbiAgICB9O1xuICAgIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWxzXzEucmxwLmVuY29kZShzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQsIGkpID0+IHtcbiAgICAgICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgICAgICAgdiA9ICgwLCBieXRlc18xLnRvQnVmZmVyKSh2KTtcbiAgICAgICAgICAgIGlmICh2LnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwJyAmJiAhZmllbGQuYWxsb3daZXJvKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZC5hbGxvd0xlc3MgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdiA9ICgwLCBieXRlc18xLnVucGFkQnVmZmVyKSh2KTtcbiAgICAgICAgICAgICAgICAoMCwgYXNzZXJ0XzEuZGVmYXVsdCkoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCBgVGhlIGZpZWxkICR7ZmllbGQubmFtZX0gbXVzdCBub3QgaGF2ZSBtb3JlICR7ZmllbGQubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfMS5kZWZhdWx0KShmaWVsZC5sZW5ndGggPT09IHYubGVuZ3RoLCBgVGhlIGZpZWxkICR7ZmllbGQubmFtZX0gbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICR7ZmllbGQubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhdHRhY2ggYWxpYXNcbiAgICAgICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKCgwLCBpbnRlcm5hbF8xLnN0cmlwSGV4UHJlZml4KShkYXRhKSwgJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBleHRlcm5hbHNfMS5ybHAuZGVjb2RlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiBzZWxmLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGl0ZW1zIGFyZSBidWZmZXJzXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSAoMCwgYnl0ZXNfMS50b0J1ZmZlcikoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQubmFtZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRhJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZGVmaW5lUHJvcGVydGllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmaW5lUHJvcGVydGllcyIsImFzc2VydF8xIiwicmVxdWlyZSIsImludGVybmFsXzEiLCJleHRlcm5hbHNfMSIsImJ5dGVzXzEiLCJzZWxmIiwiZmllbGRzIiwiZGF0YSIsInJhdyIsIl9maWVsZHMiLCJ0b0pTT04iLCJsYWJlbCIsIm9iaiIsImZvckVhY2giLCJmaWVsZCIsInRvU3RyaW5nIiwiYmFUb0pTT04iLCJzZXJpYWxpemUiLCJybHAiLCJlbmNvZGUiLCJpIiwicHVzaCIsIm5hbWUiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJ2IiwidG9CdWZmZXIiLCJhbGxvd1plcm8iLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImFsbG93TGVzcyIsImxlbmd0aCIsInVucGFkQnVmZmVyIiwiZGVmYXVsdCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJzZXQiLCJhbGlhcyIsImZyb20iLCJzdHJpcEhleFByZWZpeCIsImlzQnVmZmVyIiwiZGVjb2RlIiwiQXJyYXkiLCJpc0FycmF5IiwiRXJyb3IiLCJkIiwia2V5cyIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/signature.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/signature.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toCompactSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nconst secp256k1_1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-util/dist/hash.js\");\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/ethereumjs-util/dist/helpers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/ethereumjs-util/dist/types.js\");\nfunction ecsign(msgHash, privateKey, chainId) {\n    const { signature, recid: recovery } = (0, secp256k1_1.ecdsaSign)(msgHash, privateKey);\n    const r = Buffer.from(signature.slice(0, 32));\n    const s = Buffer.from(signature.slice(32, 64));\n    if (!chainId || typeof chainId === \"number\") {\n        // return legacy type ECDSASignature (deprecated in favor of ECDSASignatureBuffer to handle large chainIds)\n        if (chainId && !Number.isSafeInteger(chainId)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n        }\n        const v = chainId ? recovery + (chainId * 2 + 35) : recovery + 27;\n        return {\n            r,\n            s,\n            v\n        };\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    const v = chainIdBN.muln(2).addn(35).addn(recovery).toArrayLike(Buffer);\n    return {\n        r,\n        s,\n        v\n    };\n}\nexports.ecsign = ecsign;\nfunction calculateSigRecovery(v, chainId) {\n    const vBN = (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (vBN.eqn(0) || vBN.eqn(1)) return (0, types_1.toType)(v, types_1.TypeOutput.BN);\n    if (!chainId) {\n        return vBN.subn(27);\n    }\n    const chainIdBN = (0, types_1.toType)(chainId, types_1.TypeOutput.BN);\n    return vBN.sub(chainIdBN.muln(2).addn(35));\n}\nfunction isValidSigRecovery(recovery) {\n    const rec = new externals_1.BN(recovery);\n    return rec.eqn(0) || rec.eqn(1);\n}\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Recovered public key\n */ const ecrecover = function(msgHash, v, r, s, chainId) {\n    const signature = Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32)\n    ], 64);\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const senderPubKey = (0, secp256k1_1.ecdsaRecover)(signature, recovery.toNumber(), msgHash);\n    return Buffer.from((0, secp256k1_1.publicKeyConvert)(senderPubKey, false).slice(1));\n};\nexports.ecrecover = ecrecover;\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toRpcSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(s, 32),\n        (0, bytes_1.toBuffer)(v)\n    ]));\n};\nexports.toRpcSig = toRpcSig;\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @returns Signature\n */ const toCompactSig = function(v, r, s, chainId) {\n    const recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    const vn = (0, types_1.toType)(v, types_1.TypeOutput.Number);\n    let ss = s;\n    if (vn > 28 && vn % 2 === 1 || vn === 1 || vn === 28) {\n        ss = Buffer.from(s);\n        ss[0] |= 0x80;\n    }\n    return (0, bytes_1.bufferToHex)(Buffer.concat([\n        (0, bytes_1.setLengthLeft)(r, 32),\n        (0, bytes_1.setLengthLeft)(ss, 32)\n    ]));\n};\nexports.toCompactSig = toCompactSig;\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */ const fromRpcSig = function(sig) {\n    const buf = (0, bytes_1.toBuffer)(sig);\n    let r;\n    let s;\n    let v;\n    if (buf.length >= 65) {\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(64));\n    } else if (buf.length === 64) {\n        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n        r = buf.slice(0, 32);\n        s = buf.slice(32, 64);\n        v = (0, bytes_1.bufferToInt)(buf.slice(32, 33)) >> 7;\n        s[0] &= 0x7f;\n    } else {\n        throw new Error(\"Invalid signature length\");\n    }\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v,\n        r,\n        s\n    };\n};\nexports.fromRpcSig = fromRpcSig;\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v == 0 | v == 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */ const isValidSignature = function(v, r, s, homesteadOrLater = true, chainId) {\n    const SECP256K1_N_DIV_2 = new externals_1.BN(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\", 16);\n    const SECP256K1_N = new externals_1.BN(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    const rBN = new externals_1.BN(r);\n    const sBN = new externals_1.BN(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\nexports.isValidSignature = isValidSignature;\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */ const hashPersonalMessage = function(message) {\n    (0, helpers_1.assertIsBuffer)(message);\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${message.length}`, \"utf-8\");\n    return (0, hash_1.keccak)(Buffer.concat([\n        prefix,\n        message\n    ]));\n};\nexports.hashPersonalMessage = hashPersonalMessage; //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0Esd0JBQXdCLEdBQUdBLGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUNsSyxNQUFNUyxjQUFjQyxtQkFBT0EsQ0FBQyxnR0FBaUM7QUFDN0QsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQWE7QUFDekMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsaUVBQVE7QUFDL0IsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsdUVBQVc7QUFDckMsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsbUVBQVM7QUFDakMsU0FBU0YsT0FBT1EsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLE9BQU87SUFDeEMsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLE9BQU9DLFFBQVEsRUFBRSxHQUFHLENBQUMsR0FBR1osWUFBWWEsU0FBUyxFQUFFTixTQUFTQztJQUMzRSxNQUFNTSxJQUFJQyxPQUFPQyxJQUFJLENBQUNOLFVBQVVPLEtBQUssQ0FBQyxHQUFHO0lBQ3pDLE1BQU1DLElBQUlILE9BQU9DLElBQUksQ0FBQ04sVUFBVU8sS0FBSyxDQUFDLElBQUk7SUFDMUMsSUFBSSxDQUFDUixXQUFXLE9BQU9BLFlBQVksVUFBVTtRQUN6QywyR0FBMkc7UUFDM0csSUFBSUEsV0FBVyxDQUFDVSxPQUFPQyxhQUFhLENBQUNYLFVBQVU7WUFDM0MsTUFBTSxJQUFJWSxNQUFNO1FBQ3BCO1FBQ0EsTUFBTUMsSUFBSWIsVUFBVUcsV0FBWUgsQ0FBQUEsVUFBVSxJQUFJLEVBQUMsSUFBS0csV0FBVztRQUMvRCxPQUFPO1lBQUVFO1lBQUdJO1lB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UVYsTUFBTSxDQUFDLENBQUMsRUFBRTtJQUNoRixPQUFPLENBQUMsR0FBRzdDLE9BQU8wRCxNQUFNLEVBQUUvQyxPQUFPc0IsTUFBTSxDQUFDO1FBQUN3QjtRQUFRRjtLQUFRO0FBQzdEO0FBQ0FwRSwyQkFBMkIsR0FBR0UscUJBQzlCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zaWduYXR1cmUuanM/ZmIyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGV4cG9ydHMuZnJvbVJwY1NpZyA9IGV4cG9ydHMudG9Db21wYWN0U2lnID0gZXhwb3J0cy50b1JwY1NpZyA9IGV4cG9ydHMuZWNyZWNvdmVyID0gZXhwb3J0cy5lY3NpZ24gPSB2b2lkIDA7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxXCIpO1xuY29uc3QgZXh0ZXJuYWxzXzEgPSByZXF1aXJlKFwiLi9leHRlcm5hbHNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuY29uc3QgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmZ1bmN0aW9uIGVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5LCBjaGFpbklkKSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUsIHJlY2lkOiByZWNvdmVyeSB9ID0gKDAsIHNlY3AyNTZrMV8xLmVjZHNhU2lnbikobXNnSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgY29uc3QgciA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpO1xuICAgIGNvbnN0IHMgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSk7XG4gICAgaWYgKCFjaGFpbklkIHx8IHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyByZXR1cm4gbGVnYWN5IHR5cGUgRUNEU0FTaWduYXR1cmUgKGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgRUNEU0FTaWduYXR1cmVCdWZmZXIgdG8gaGFuZGxlIGxhcmdlIGNoYWluSWRzKVxuICAgICAgICBpZiAoY2hhaW5JZCAmJiAhTnVtYmVyLmlzU2FmZUludGVnZXIoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIG51bWJlciBpcyBncmVhdGVyIHRoYW4gTUFYX1NBRkVfSU5URUdFUiAocGxlYXNlIHVzZSBhbiBhbHRlcm5hdGl2ZSBpbnB1dCB0eXBlKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYgPSBjaGFpbklkID8gcmVjb3ZlcnkgKyAoY2hhaW5JZCAqIDIgKyAzNSkgOiByZWNvdmVyeSArIDI3O1xuICAgICAgICByZXR1cm4geyByLCBzLCB2IH07XG4gICAgfVxuICAgIGNvbnN0IGNoYWluSWRCTiA9ICgwLCB0eXBlc18xLnRvVHlwZSkoY2hhaW5JZCwgdHlwZXNfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICBjb25zdCB2ID0gY2hhaW5JZEJOLm11bG4oMikuYWRkbigzNSkuYWRkbihyZWNvdmVyeSkudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICByZXR1cm4geyByLCBzLCB2IH07XG59XG5leHBvcnRzLmVjc2lnbiA9IGVjc2lnbjtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpIHtcbiAgICBjb25zdCB2Qk4gPSAoMCwgdHlwZXNfMS50b1R5cGUpKHYsIHR5cGVzXzEuVHlwZU91dHB1dC5CTik7XG4gICAgaWYgKHZCTi5lcW4oMCkgfHwgdkJOLmVxbigxKSlcbiAgICAgICAgcmV0dXJuICgwLCB0eXBlc18xLnRvVHlwZSkodiwgdHlwZXNfMS5UeXBlT3V0cHV0LkJOKTtcbiAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIHZCTi5zdWJuKDI3KTtcbiAgICB9XG4gICAgY29uc3QgY2hhaW5JZEJOID0gKDAsIHR5cGVzXzEudG9UeXBlKShjaGFpbklkLCB0eXBlc18xLlR5cGVPdXRwdXQuQk4pO1xuICAgIHJldHVybiB2Qk4uc3ViKGNoYWluSWRCTi5tdWxuKDIpLmFkZG4oMzUpKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkge1xuICAgIGNvbnN0IHJlYyA9IG5ldyBleHRlcm5hbHNfMS5CTihyZWNvdmVyeSk7XG4gICAgcmV0dXJuIHJlYy5lcW4oMCkgfHwgcmVjLmVxbigxKTtcbn1cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZS5cbiAqIE5PVEU6IEFjY2VwdHMgYHYgPT0gMCB8IHYgPT0gMWAgZm9yIEVJUDE1NTkgdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyBSZWNvdmVyZWQgcHVibGljIGtleVxuICovXG5jb25zdCBlY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoWygwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHIsIDMyKSwgKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkocywgMzIpXSwgNjQpO1xuICAgIGNvbnN0IHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICBjb25zdCBzZW5kZXJQdWJLZXkgPSAoMCwgc2VjcDI1NmsxXzEuZWNkc2FSZWNvdmVyKShzaWduYXR1cmUsIHJlY292ZXJ5LnRvTnVtYmVyKCksIG1zZ0hhc2gpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2VjcDI1NmsxXzEucHVibGljS2V5Q29udmVydCkoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSkpO1xufTtcbmV4cG9ydHMuZWNyZWNvdmVyID0gZWNyZWNvdmVyO1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2QuXG4gKiBOT1RFOiBBY2NlcHRzIGB2ID09IDAgfCB2ID09IDFgIGZvciBFSVAxNTU5IHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMgU2lnbmF0dXJlXG4gKi9cbmNvbnN0IHRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICBjb25zdCByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgICByZXR1cm4gKDAsIGJ5dGVzXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5jb25jYXQoWygwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHIsIDMyKSwgKDAsIGJ5dGVzXzEuc2V0TGVuZ3RoTGVmdCkocywgMzIpLCAoMCwgYnl0ZXNfMS50b0J1ZmZlcikodildKSk7XG59O1xuZXhwb3J0cy50b1JwY1NpZyA9IHRvUnBjU2lnO1xuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBDb21wYWN0IFNpZ25hdHVyZSBSZXByZXNlbnRhdGlvbiAoRUlQLTIwOTgpLlxuICogTk9URTogQWNjZXB0cyBgdiA9PSAwIHwgdiA9PSAxYCBmb3IgRUlQMTU1OSB0cmFuc2FjdGlvbnNcbiAqIEByZXR1cm5zIFNpZ25hdHVyZVxuICovXG5jb25zdCB0b0NvbXBhY3RTaWcgPSBmdW5jdGlvbiAodiwgciwgcywgY2hhaW5JZCkge1xuICAgIGNvbnN0IHJlY292ZXJ5ID0gY2FsY3VsYXRlU2lnUmVjb3ZlcnkodiwgY2hhaW5JZCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnUmVjb3ZlcnkocmVjb3ZlcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICAgIH1cbiAgICBjb25zdCB2biA9ICgwLCB0eXBlc18xLnRvVHlwZSkodiwgdHlwZXNfMS5UeXBlT3V0cHV0Lk51bWJlcik7XG4gICAgbGV0IHNzID0gcztcbiAgICBpZiAoKHZuID4gMjggJiYgdm4gJSAyID09PSAxKSB8fCB2biA9PT0gMSB8fCB2biA9PT0gMjgpIHtcbiAgICAgICAgc3MgPSBCdWZmZXIuZnJvbShzKTtcbiAgICAgICAgc3NbMF0gfD0gMHg4MDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBieXRlc18xLmJ1ZmZlclRvSGV4KShCdWZmZXIuY29uY2F0KFsoMCwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KShyLCAzMiksICgwLCBieXRlc18xLnNldExlbmd0aExlZnQpKHNzLCAzMildKSk7XG59O1xuZXhwb3J0cy50b0NvbXBhY3RTaWcgPSB0b0NvbXBhY3RTaWc7XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqIE5PVEU6IEFmdGVyIEVJUDE1NTksIGB2YCBjb3VsZCBiZSBgMGAgb3IgYDFgIGJ1dCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXNcbiAqIGl0J3MgYSBzaWduZWQgbWVzc2FnZSAoRUlQLTE5MSBvciBFSVAtNzEyKSBhZGRpbmcgYDI3YCBhdCB0aGUgZW5kLiBSZW1vdmUgaWYgbmVlZGVkLlxuICovXG5jb25zdCBmcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICAgIGNvbnN0IGJ1ZiA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShzaWcpO1xuICAgIGxldCByO1xuICAgIGxldCBzO1xuICAgIGxldCB2O1xuICAgIGlmIChidWYubGVuZ3RoID49IDY1KSB7XG4gICAgICAgIHIgPSBidWYuc2xpY2UoMCwgMzIpO1xuICAgICAgICBzID0gYnVmLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIHYgPSAoMCwgYnl0ZXNfMS5idWZmZXJUb0ludCkoYnVmLnNsaWNlKDY0KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIC8vIENvbXBhY3QgU2lnbmF0dXJlIFJlcHJlc2VudGF0aW9uIChodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTIwOTgpXG4gICAgICAgIHIgPSBidWYuc2xpY2UoMCwgMzIpO1xuICAgICAgICBzID0gYnVmLnNsaWNlKDMyLCA2NCk7XG4gICAgICAgIHYgPSAoMCwgYnl0ZXNfMS5idWZmZXJUb0ludCkoYnVmLnNsaWNlKDMyLCAzMykpID4+IDc7XG4gICAgICAgIHNbMF0gJj0gMHg3ZjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgfVxuICAgIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICAgIGlmICh2IDwgMjcpIHtcbiAgICAgICAgdiArPSAyNztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdixcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICB9O1xufTtcbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZyb21ScGNTaWc7XG4vKipcbiAqIFZhbGlkYXRlIGEgRUNEU0Egc2lnbmF0dXJlLlxuICogTk9URTogQWNjZXB0cyBgdiA9PSAwIHwgdiA9PSAxYCBmb3IgRUlQMTU1OSB0cmFuc2FjdGlvbnNcbiAqIEBwYXJhbSBob21lc3RlYWRPckxhdGVyIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYmVpbmcgdXNlZCBvbiBlaXRoZXIgdGhlIGhvbWVzdGVhZCBoYXJkZm9yayBvciBhIGxhdGVyIG9uZVxuICovXG5jb25zdCBpc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZE9yTGF0ZXIgPSB0cnVlLCBjaGFpbklkKSB7XG4gICAgY29uc3QgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gICAgY29uc3QgU0VDUDI1NksxX04gPSBuZXcgZXh0ZXJuYWxzXzEuQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnLCAxNik7XG4gICAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByQk4gPSBuZXcgZXh0ZXJuYWxzXzEuQk4ocik7XG4gICAgY29uc3Qgc0JOID0gbmV3IGV4dGVybmFsc18xLkJOKHMpO1xuICAgIGlmIChyQk4uaXNaZXJvKCkgfHwgckJOLmd0KFNFQ1AyNTZLMV9OKSB8fCBzQk4uaXNaZXJvKCkgfHwgc0JOLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChob21lc3RlYWRPckxhdGVyICYmIHNCTi5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gaXNWYWxpZFNpZ25hdHVyZTtcbi8qKlxuICogUmV0dXJucyB0aGUga2VjY2FrLTI1NiBoYXNoIG9mIGBtZXNzYWdlYCwgcHJlZml4ZWQgd2l0aCB0aGUgaGVhZGVyIHVzZWQgYnkgdGhlIGBldGhfc2lnbmAgUlBDIGNhbGwuXG4gKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGZlZCBpbnRvIGBlY3NpZ25gIHRvIHByb2R1Y2UgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIHRoZSBgZXRoX3NpZ25gXG4gKiBjYWxsIGZvciBhIGdpdmVuIGBtZXNzYWdlYCwgb3IgZmVkIHRvIGBlY3JlY292ZXJgIGFsb25nIHdpdGggYSBzaWduYXR1cmUgdG8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICogdXNlZCB0byBwcm9kdWNlIHRoZSBzaWduYXR1cmUuXG4gKi9cbmNvbnN0IGhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICgwLCBoZWxwZXJzXzEuYXNzZXJ0SXNCdWZmZXIpKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHByZWZpeCA9IEJ1ZmZlci5mcm9tKGBcXHUwMDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJHttZXNzYWdlLmxlbmd0aH1gLCAndXRmLTgnKTtcbiAgICByZXR1cm4gKDAsIGhhc2hfMS5rZWNjYWspKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBoYXNoUGVyc29uYWxNZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhhc2hQZXJzb25hbE1lc3NhZ2UiLCJpc1ZhbGlkU2lnbmF0dXJlIiwiZnJvbVJwY1NpZyIsInRvQ29tcGFjdFNpZyIsInRvUnBjU2lnIiwiZWNyZWNvdmVyIiwiZWNzaWduIiwic2VjcDI1NmsxXzEiLCJyZXF1aXJlIiwiZXh0ZXJuYWxzXzEiLCJieXRlc18xIiwiaGFzaF8xIiwiaGVscGVyc18xIiwidHlwZXNfMSIsIm1zZ0hhc2giLCJwcml2YXRlS2V5IiwiY2hhaW5JZCIsInNpZ25hdHVyZSIsInJlY2lkIiwicmVjb3ZlcnkiLCJlY2RzYVNpZ24iLCJyIiwiQnVmZmVyIiwiZnJvbSIsInNsaWNlIiwicyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsInYiLCJjaGFpbklkQk4iLCJ0b1R5cGUiLCJUeXBlT3V0cHV0IiwiQk4iLCJtdWxuIiwiYWRkbiIsInRvQXJyYXlMaWtlIiwiY2FsY3VsYXRlU2lnUmVjb3ZlcnkiLCJ2Qk4iLCJlcW4iLCJzdWJuIiwic3ViIiwiaXNWYWxpZFNpZ1JlY292ZXJ5IiwicmVjIiwiY29uY2F0Iiwic2V0TGVuZ3RoTGVmdCIsInNlbmRlclB1YktleSIsImVjZHNhUmVjb3ZlciIsInRvTnVtYmVyIiwicHVibGljS2V5Q29udmVydCIsImJ1ZmZlclRvSGV4IiwidG9CdWZmZXIiLCJ2biIsInNzIiwic2lnIiwiYnVmIiwibGVuZ3RoIiwiYnVmZmVyVG9JbnQiLCJob21lc3RlYWRPckxhdGVyIiwiU0VDUDI1NksxX05fRElWXzIiLCJTRUNQMjU2SzFfTiIsInJCTiIsInNCTiIsImlzWmVybyIsImd0IiwiY21wIiwibWVzc2FnZSIsImFzc2VydElzQnVmZmVyIiwicHJlZml4Iiwia2VjY2FrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/types.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.bnToHex = void 0;\nconst externals_1 = __webpack_require__(/*! ./externals */ \"(ssr)/./node_modules/ethereumjs-util/dist/externals.js\");\nconst internal_1 = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/ethereumjs-util/dist/internal.js\");\nconst bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Convert BN to 0x-prefixed hex string.\n */ function bnToHex(value) {\n    return `0x${value.toString(16)}`;\n}\nexports.bnToHex = bnToHex;\n/**\n * Convert value from BN to an unpadded Buffer\n * (useful for RLP transport)\n * @param value value to convert\n */ function bnToUnpaddedBuffer(value) {\n    // Using `bn.toArrayLike(Buffer)` instead of `bn.toBuffer()`\n    // for compatibility with browserify and similar tools\n    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));\n}\nexports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;\n/**\n * Deprecated alias for {@link bnToUnpaddedBuffer}\n * @deprecated\n */ function bnToRlp(value) {\n    return bnToUnpaddedBuffer(value);\n}\nexports.bnToRlp = bnToRlp;\n/**\n * Type output options\n */ var TypeOutput;\n(function(TypeOutput) {\n    TypeOutput[TypeOutput[\"Number\"] = 0] = \"Number\";\n    TypeOutput[TypeOutput[\"BN\"] = 1] = \"BN\";\n    TypeOutput[TypeOutput[\"Buffer\"] = 2] = \"Buffer\";\n    TypeOutput[TypeOutput[\"PrefixedHexString\"] = 3] = \"PrefixedHexString\";\n})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));\nfunction toType(input, outputType) {\n    if (input === null) {\n        return null;\n    }\n    if (input === undefined) {\n        return undefined;\n    }\n    if (typeof input === \"string\" && !(0, internal_1.isHexString)(input)) {\n        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);\n    } else if (typeof input === \"number\" && !Number.isSafeInteger(input)) {\n        throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)\");\n    }\n    const output = (0, bytes_1.toBuffer)(input);\n    if (outputType === TypeOutput.Buffer) {\n        return output;\n    } else if (outputType === TypeOutput.BN) {\n        return new externals_1.BN(output);\n    } else if (outputType === TypeOutput.Number) {\n        const bn = new externals_1.BN(output);\n        const max = new externals_1.BN(Number.MAX_SAFE_INTEGER.toString());\n        if (bn.gt(max)) {\n            throw new Error(\"The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)\");\n        }\n        return bn.toNumber();\n    } else {\n        // outputType === TypeOutput.PrefixedHexString\n        return `0x${output.toString(\"hex\")}`;\n    }\n}\nexports.toType = toType; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBR0Esa0JBQWtCLEdBQUdBLGVBQWUsR0FBR0EsMEJBQTBCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzVHLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLDJFQUFhO0FBQ3pDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHlFQUFZO0FBQ3ZDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLG1FQUFTO0FBQ2pDOztDQUVDLEdBQ0QsU0FBU0YsUUFBUUwsS0FBSztJQUNsQixPQUFPLENBQUMsRUFBRSxFQUFFQSxNQUFNVSxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ3BDO0FBQ0FYLGVBQWUsR0FBR007QUFDbEI7Ozs7Q0FJQyxHQUNELFNBQVNELG1CQUFtQkosS0FBSztJQUM3Qiw0REFBNEQ7SUFDNUQsc0RBQXNEO0lBQ3RELE9BQU8sQ0FBQyxHQUFHUyxRQUFRRSxXQUFXLEVBQUVYLE1BQU1ZLFdBQVcsQ0FBQ0M7QUFDdEQ7QUFDQWQsMEJBQTBCLEdBQUdLO0FBQzdCOzs7Q0FHQyxHQUNELFNBQVNELFFBQVFILEtBQUs7SUFDbEIsT0FBT0ksbUJBQW1CSjtBQUM5QjtBQUNBRCxlQUFlLEdBQUdJO0FBQ2xCOztDQUVDLEdBQ0QsSUFBSUQ7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHO0lBQ25DQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDdEQsR0FBR0EsYUFBYUgsUUFBUUcsVUFBVSxJQUFLSCxDQUFBQSxrQkFBa0IsR0FBRyxDQUFDO0FBQzdELFNBQVNFLE9BQU9hLEtBQUssRUFBRUMsVUFBVTtJQUM3QixJQUFJRCxVQUFVLE1BQU07UUFDaEIsT0FBTztJQUNYO0lBQ0EsSUFBSUEsVUFBVUUsV0FBVztRQUNyQixPQUFPQTtJQUNYO0lBQ0EsSUFBSSxPQUFPRixVQUFVLFlBQVksQ0FBQyxDQUFDLEdBQUdOLFdBQVdTLFdBQVcsRUFBRUgsUUFBUTtRQUNsRSxNQUFNLElBQUlJLE1BQU0sQ0FBQyxtREFBbUQsRUFBRUosTUFBTSxDQUFDO0lBQ2pGLE9BQ0ssSUFBSSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0ssT0FBT0MsYUFBYSxDQUFDTixRQUFRO1FBQ2hFLE1BQU0sSUFBSUksTUFBTTtJQUNwQjtJQUNBLE1BQU1HLFNBQVMsQ0FBQyxHQUFHWixRQUFRYSxRQUFRLEVBQUVSO0lBQ3JDLElBQUlDLGVBQWViLFdBQVdXLE1BQU0sRUFBRTtRQUNsQyxPQUFPUTtJQUNYLE9BQ0ssSUFBSU4sZUFBZWIsV0FBV3FCLEVBQUUsRUFBRTtRQUNuQyxPQUFPLElBQUlqQixZQUFZaUIsRUFBRSxDQUFDRjtJQUM5QixPQUNLLElBQUlOLGVBQWViLFdBQVdpQixNQUFNLEVBQUU7UUFDdkMsTUFBTUssS0FBSyxJQUFJbEIsWUFBWWlCLEVBQUUsQ0FBQ0Y7UUFDOUIsTUFBTUksTUFBTSxJQUFJbkIsWUFBWWlCLEVBQUUsQ0FBQ0osT0FBT08sZ0JBQWdCLENBQUNoQixRQUFRO1FBQy9ELElBQUljLEdBQUdHLEVBQUUsQ0FBQ0YsTUFBTTtZQUNaLE1BQU0sSUFBSVAsTUFBTTtRQUNwQjtRQUNBLE9BQU9NLEdBQUdJLFFBQVE7SUFDdEIsT0FDSztRQUNELDhDQUE4QztRQUM5QyxPQUFPLENBQUMsRUFBRSxFQUFFUCxPQUFPWCxRQUFRLENBQUMsT0FBTyxDQUFDO0lBQ3hDO0FBQ0o7QUFDQVgsY0FBYyxHQUFHRSxRQUNqQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvdHlwZXMuanM/M2FmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9UeXBlID0gZXhwb3J0cy5UeXBlT3V0cHV0ID0gZXhwb3J0cy5iblRvUmxwID0gZXhwb3J0cy5iblRvVW5wYWRkZWRCdWZmZXIgPSBleHBvcnRzLmJuVG9IZXggPSB2b2lkIDA7XG5jb25zdCBleHRlcm5hbHNfMSA9IHJlcXVpcmUoXCIuL2V4dGVybmFsc1wiKTtcbmNvbnN0IGludGVybmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbFwiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogQ29udmVydCBCTiB0byAweC1wcmVmaXhlZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiblRvSGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIGAweCR7dmFsdWUudG9TdHJpbmcoMTYpfWA7XG59XG5leHBvcnRzLmJuVG9IZXggPSBiblRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IHZhbHVlIGZyb20gQk4gdG8gYW4gdW5wYWRkZWQgQnVmZmVyXG4gKiAodXNlZnVsIGZvciBSTFAgdHJhbnNwb3J0KVxuICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIGNvbnZlcnRcbiAqL1xuZnVuY3Rpb24gYm5Ub1VucGFkZGVkQnVmZmVyKHZhbHVlKSB7XG4gICAgLy8gVXNpbmcgYGJuLnRvQXJyYXlMaWtlKEJ1ZmZlcilgIGluc3RlYWQgb2YgYGJuLnRvQnVmZmVyKClgXG4gICAgLy8gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBicm93c2VyaWZ5IGFuZCBzaW1pbGFyIHRvb2xzXG4gICAgcmV0dXJuICgwLCBieXRlc18xLnVucGFkQnVmZmVyKSh2YWx1ZS50b0FycmF5TGlrZShCdWZmZXIpKTtcbn1cbmV4cG9ydHMuYm5Ub1VucGFkZGVkQnVmZmVyID0gYm5Ub1VucGFkZGVkQnVmZmVyO1xuLyoqXG4gKiBEZXByZWNhdGVkIGFsaWFzIGZvciB7QGxpbmsgYm5Ub1VucGFkZGVkQnVmZmVyfVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gYm5Ub1JscCh2YWx1ZSkge1xuICAgIHJldHVybiBiblRvVW5wYWRkZWRCdWZmZXIodmFsdWUpO1xufVxuZXhwb3J0cy5iblRvUmxwID0gYm5Ub1JscDtcbi8qKlxuICogVHlwZSBvdXRwdXQgb3B0aW9uc1xuICovXG52YXIgVHlwZU91dHB1dDtcbihmdW5jdGlvbiAoVHlwZU91dHB1dCkge1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIk51bWJlclwiXSA9IDBdID0gXCJOdW1iZXJcIjtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJCTlwiXSA9IDFdID0gXCJCTlwiO1xuICAgIFR5cGVPdXRwdXRbVHlwZU91dHB1dFtcIkJ1ZmZlclwiXSA9IDJdID0gXCJCdWZmZXJcIjtcbiAgICBUeXBlT3V0cHV0W1R5cGVPdXRwdXRbXCJQcmVmaXhlZEhleFN0cmluZ1wiXSA9IDNdID0gXCJQcmVmaXhlZEhleFN0cmluZ1wiO1xufSkoVHlwZU91dHB1dCA9IGV4cG9ydHMuVHlwZU91dHB1dCB8fCAoZXhwb3J0cy5UeXBlT3V0cHV0ID0ge30pKTtcbmZ1bmN0aW9uIHRvVHlwZShpbnB1dCwgb3V0cHV0VHlwZSkge1xuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgISgwLCBpbnRlcm5hbF8xLmlzSGV4U3RyaW5nKShpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIHN0cmluZyBtdXN0IGJlIHByb3ZpZGVkIHdpdGggYSAweC1wcmVmaXgsIGdpdmVuOiAke2lucHV0fWApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNTYWZlSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBNQVhfU0FGRV9JTlRFR0VSIChwbGVhc2UgdXNlIGFuIGFsdGVybmF0aXZlIGlucHV0IHR5cGUpJyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9ICgwLCBieXRlc18xLnRvQnVmZmVyKShpbnB1dCk7XG4gICAgaWYgKG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dHB1dFR5cGUgPT09IFR5cGVPdXRwdXQuQk4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbHNfMS5CTihvdXRwdXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRwdXRUeXBlID09PSBUeXBlT3V0cHV0Lk51bWJlcikge1xuICAgICAgICBjb25zdCBibiA9IG5ldyBleHRlcm5hbHNfMS5CTihvdXRwdXQpO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgZXh0ZXJuYWxzXzEuQk4oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChibi5ndChtYXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIE1BWF9TQUZFX0lOVEVHRVIgKHBsZWFzZSB1c2UgYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IHR5cGUpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJuLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvdXRwdXRUeXBlID09PSBUeXBlT3V0cHV0LlByZWZpeGVkSGV4U3RyaW5nXG4gICAgICAgIHJldHVybiBgMHgke291dHB1dC50b1N0cmluZygnaGV4Jyl9YDtcbiAgICB9XG59XG5leHBvcnRzLnRvVHlwZSA9IHRvVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRvVHlwZSIsIlR5cGVPdXRwdXQiLCJiblRvUmxwIiwiYm5Ub1VucGFkZGVkQnVmZmVyIiwiYm5Ub0hleCIsImV4dGVybmFsc18xIiwicmVxdWlyZSIsImludGVybmFsXzEiLCJieXRlc18xIiwidG9TdHJpbmciLCJ1bnBhZEJ1ZmZlciIsInRvQXJyYXlMaWtlIiwiQnVmZmVyIiwiaW5wdXQiLCJvdXRwdXRUeXBlIiwidW5kZWZpbmVkIiwiaXNIZXhTdHJpbmciLCJFcnJvciIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJvdXRwdXQiLCJ0b0J1ZmZlciIsIkJOIiwiYm4iLCJtYXgiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZ3QiLCJ0b051bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/types.js\n");

/***/ })

};
;