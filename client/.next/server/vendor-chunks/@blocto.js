"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@blocto";
exports.ids = ["vendor-chunks/@blocto"];
exports.modules = {

/***/ "(ssr)/./node_modules/@blocto/sdk/dist/blocto-sdk.module.js":
/*!************************************************************!*\
  !*** ./node_modules/@blocto/sdk/dist/blocto-sdk.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* Version: 0.5.5 - August 14, 2023 10:23:52 */ /******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ \nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: function() {\n        return BloctoSDK;\n    }\n});\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// instead invariant from package, since all error will throw on production\nfunction invariant(condition, format) {\n    if (!condition) {\n        throw new Error(format);\n    }\n}\n// local storage version naming rule: [milestone].[patch]\nvar KEY_SESSION;\n(function(KEY_SESSION) {\n    KEY_SESSION[\"prod\"] = \"BLOCTO_SDK\";\n    KEY_SESSION[\"dev\"] = \"BLOCTO_SDK_DEV\";\n    KEY_SESSION[\"staging\"] = \"BLOCTO_SDK_STAGING\";\n})(KEY_SESSION || (KEY_SESSION = {}));\nvar CHAIN;\n(function(CHAIN) {\n    CHAIN[\"ETHEREUM\"] = \"ethereum\";\n    CHAIN[\"SOLANA\"] = \"solana\";\n    CHAIN[\"APTOS\"] = \"aptos\";\n})(CHAIN || (CHAIN = {}));\nclass MemoryStorage {\n    constructor(){\n        this.storage = {};\n    }\n    getItem(key) {\n        return this[key] || null;\n    }\n    setItem(key, value) {\n        this.storage[key] = value;\n    }\n    removeItem(key) {\n        delete this.storage[key];\n    }\n}\nconst memoryStorage =  false ? 0 : new MemoryStorage();\nconst isSupported = ()=>{\n    if (true) {\n        return false;\n    }\n    try {\n        window.sessionStorage.setItem(\"local_storage_supported\", \"1\");\n        const result = window.sessionStorage.getItem(\"local_storage_supported\");\n        window.sessionStorage.removeItem(\"local_storage_supported\");\n        return result === \"1\";\n    } catch (error) {\n        return false;\n    }\n};\nconst storage = isSupported() ? window.sessionStorage : memoryStorage;\nconst getItem = (key, defaultValue = null)=>{\n    const value = storage.getItem(key);\n    try {\n        return value && JSON.parse(value) || defaultValue;\n    } catch (SyntaxError) {\n        return value || defaultValue;\n    }\n};\nconst setItem = (key, value)=>storage.setItem(key, typeof value === \"string\" ? value : JSON.stringify(value));\nconst removeItem = (key)=>{\n    setItem(key, \"\"); // Due to some versions of browser bug can't removeItem correctly.\n    storage.removeItem(key);\n};\n/**\n * @param {keys.KEY_SESSION} key - key to retrieve the data\n * @returns {ProviderSession | null} ProviderSession | null\n * @description\n * Get ProviderSession from storage.\n * If the data is expired, will remove the data and return null\n */ const getAccountStorage = (key)=>{\n    const rawAccountStorage = getItem(key, null);\n    if (!rawAccountStorage) return null;\n    // compare the expiry time of the item with the current time\n    if (new Date().getTime() > rawAccountStorage.expiry || rawAccountStorage.v !== SDK_VERSION) {\n        removeItem(key);\n        return null;\n    }\n    return rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data;\n};\n/**\n  @param {keys.KEY_SESSION} key - key to store the data\n  @param {ProviderSession} data - Only the part of ProviderSession that needs to be updated\n  {\n    connected?: boolean;\n    code?: string | null;\n    accounts: Record<string, string[] | undefined>;\n  }\n  @param {number} expiry - expiry time of the data\n*/ const setAccountStorage = (key, data, expiry)=>{\n    var _a, _b, _c;\n    const rawAccountStorage = getItem(key);\n    const newAccountStorage = {\n        data: {\n            code: (data === null || data === void 0 ? void 0 : data.code) || ((_a = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _a === void 0 ? void 0 : _a.code),\n            connected: !!((data === null || data === void 0 ? void 0 : data.code) || ((_b = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _b === void 0 ? void 0 : _b.code)),\n            accounts: Object.assign(Object.assign({}, (_c = rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.data) === null || _c === void 0 ? void 0 : _c.accounts), data === null || data === void 0 ? void 0 : data.accounts)\n        },\n        expiry: expiry || (rawAccountStorage === null || rawAccountStorage === void 0 ? void 0 : rawAccountStorage.expiry) || new Date().getTime() + LOGIN_PERSISTING_TIME,\n        v: SDK_VERSION\n    };\n    setItem(key, newAccountStorage);\n    return;\n};\nconst getChainAddress = (key, chain)=>{\n    var _a, _b;\n    if (!((_a = getAccountStorage(key)) === null || _a === void 0 ? void 0 : _a.code)) {\n        removeItem(key);\n        return null;\n    }\n    return ((_b = getAccountStorage(key)) === null || _b === void 0 ? void 0 : _b.accounts[chain]) || null;\n};\nconst setChainAddress = (key, chain, account)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: account\n        }\n    });\n    return;\n};\nconst removeChainAddress = (key, chain)=>{\n    setAccountStorage(key, {\n        accounts: {\n            [chain]: undefined\n        }\n    });\n    return;\n};\n/* eth series constants begin */ const ETH_RPC_LIST = {\n    // This is the list of public RPC endpoints that we known to be working\n    // Used to help developers did not set up their own RPC endpoints\n    // BSC mainnet\n    56: \"https://bsc-dataseed1.binance.org\",\n    // BSC testnet\n    97: \"https://data-seed-prebsc-1-s1.binance.org:8545\",\n    // Polygon Mainnet\n    137: \"https://rpc-mainnet.maticvigil.com/\",\n    // Polygon Testnet\n    80001: \"https://rpc-mumbai.matic.today/\",\n    // Avalanche Mainnet\n    43114: \"https://api.avax.network/ext/bc/C/rpc\",\n    // Avalanche Fuji Testnet\n    43113: \"https://api.avax-test.network/ext/bc/C/rpc\",\n    // Arbitrum Mainnet\n    42161: \"https://arb1.arbitrum.io/rpc\",\n    // Arbitrum Testnet\n    421613: \"https://endpoints.omniatech.io/v1/arbitrum/goerli/public\",\n    // Optimism Mainnet\n    10: \"https://mainnet.optimism.io\",\n    // Optimism Goerli Testnet\n    420: \"https://goerli.optimism.io\"\n};\nconst ETH_ENV_WALLET_SERVER_MAPPING = {\n    prod: \"https://wallet-v2.blocto.app\",\n    staging: \"https://wallet-v2-staging.blocto.app\",\n    dev: \"https://wallet-v2-dev.blocto.app\"\n};\nconst ETH_SESSION_KEY_MAPPING = {\n    prod: KEY_SESSION.prod,\n    staging: KEY_SESSION.staging,\n    dev: KEY_SESSION.dev\n};\n/* eth series constants end */ /* sol constants begin */ const SOL_NET = {\n    MainnetBeta: \"mainnet-beta\",\n    Testnet: \"testnet\",\n    Devnet: \"devnet\"\n};\nconst SOL_NET_SERVER_MAPPING = {\n    [SOL_NET.MainnetBeta]: \"https://wallet-v2.blocto.app\",\n    [SOL_NET.Devnet]: \"https://wallet-v2-dev.blocto.app\",\n    [SOL_NET.Testnet]: \"https://wallet-v2-dev.blocto.app\"\n};\nconst SOL_SESSION_KEY_MAPPING = {\n    [SOL_NET.MainnetBeta]: KEY_SESSION.prod,\n    [SOL_NET.Devnet]: KEY_SESSION.dev,\n    [SOL_NET.Testnet]: KEY_SESSION.dev\n};\n/* sol constants end */ /* aptos constants begin */ const APT_SESSION_KEY_MAPPING = {\n    1: KEY_SESSION.prod,\n    2: KEY_SESSION.dev,\n    3: KEY_SESSION.dev,\n    4: KEY_SESSION.dev,\n    5: KEY_SESSION.staging\n};\nconst APT_CHAIN_ID_SERVER_MAPPING = {\n    // MAINNET\n    1: \"https://wallet-v2.blocto.app\",\n    // TESTNET\n    2: \"https://wallet-v2-dev.blocto.app\",\n    // DEVNET\n    3: \"https://wallet-v2-dev.blocto.app\",\n    // TESTING\n    4: \"https://wallet-v2-dev.blocto.app\",\n    // PREMAINNET\n    5: \"https://wallet-v2-staging.blocto.app\"\n};\nvar WalletAdapterNetwork;\n(function(WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n    WalletAdapterNetwork[\"Testing\"] = \"testing\";\n    WalletAdapterNetwork[\"Premainnet\"] = \"premainnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\nconst APT_CHAIN_ID_NAME_MAPPING = {\n    1: WalletAdapterNetwork.Mainnet,\n    2: WalletAdapterNetwork.Testnet,\n    3: WalletAdapterNetwork.Devnet,\n    4: WalletAdapterNetwork.Testing,\n    5: WalletAdapterNetwork.Premainnet\n};\nconst APT_CHAIN_ID_RPC_MAPPING = {\n    1: \"https://fullnode.mainnet.aptoslabs.com/v1\",\n    2: \"https://fullnode.testnet.aptoslabs.com/v1\",\n    3: \"https://fullnode.devnet.aptoslabs.com/v1\",\n    4: \"\",\n    5: \"https://premainnet.aptosdev.com/v1\"\n};\n/* aptos constants end */ const EIP1193_EVENTS = [\n    \"connect\",\n    \"disconnect\",\n    \"message\",\n    \"chainChanged\",\n    \"accountsChanged\"\n];\n// Preserve login for 1 day\nconst LOGIN_PERSISTING_TIME = 86400 * 1000;\nconst DEFAULT_APP_ID = \"00000000-0000-0000-0000-000000000000\";\n// Will inject the version of the SDK by rollup versionInjector during build time\nconst SDK_VERSION = \"0.5.5\";\n// The root class for all providers\nclass BloctoProvider {\n    constructor(){\n        this.isBlocto = true;\n        this.isConnecting = false;\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.eventListeners = {};\n        // alias removeListener\n        this.off = this.removeListener;\n        // init event listeners\n        EIP1193_EVENTS.forEach((event)=>{\n            this.eventListeners[event] = [];\n        });\n        this.appId = DEFAULT_APP_ID;\n    }\n    // implement by children\n    // eslint-disable-next-line\n    request(payload) {\n        return __awaiter(this, void 0, void 0, function*() {});\n    }\n    on(event, listener) {\n        if (!EIP1193_EVENTS.includes(event)) return;\n        this.eventListeners[event].push(listener);\n    }\n    // @todo: implement it\n    // eslint-disable-next-line\n    once() {}\n    removeListener(event, listener) {\n        const listeners = this.eventListeners[event];\n        const index = listeners.findIndex((item)=>item === listener);\n        if (index !== -1) {\n            this.eventListeners[event].splice(index, 1);\n        }\n    }\n}\nconst IFRAME_STYLE = \"width:100vw;height:100%;position:fixed;top:0;left:0;z-index:2147483646;border:none;box-sizing:border-box;color-scheme:light;inset:0px;display:block;pointer-events:auto;\";\nfunction createFrame(url) {\n    const frame = document.createElement(\"iframe\");\n    frame.setAttribute(\"src\", url);\n    frame.setAttribute(\"style\", IFRAME_STYLE);\n    return frame;\n}\nfunction attachFrame(frame) {\n    document.body.appendChild(frame);\n}\nfunction detatchFrame(frame) {\n    const parentNode = frame && frame.parentNode;\n    if (parentNode && parentNode.removeChild instanceof Function) {\n        parentNode.removeChild(frame);\n    }\n}\nvar addSelfRemovableHandler = (eventType, handler, target = window)=>{\n    function listener(e) {\n        const removeEventListener = ()=>target.removeEventListener(eventType, listener);\n        handler(e, removeEventListener);\n    }\n    target.addEventListener(eventType, listener);\n};\nfunction responseSessionGuard(response, key, disconnectHandler) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (response.status === 403 || response.status === 401) {\n            if (disconnectHandler) {\n                disconnectHandler();\n            }\n            removeItem(key);\n        }\n        if (!response.ok) {\n            const data = yield response.json();\n            const e = new Error((data === null || data === void 0 ? void 0 : data.message) || \"unknown error\");\n            e.error_code = data === null || data === void 0 ? void 0 : data.error_code;\n            throw e;\n        }\n        return response.json();\n    });\n}\nconst isEmail = (value)=>/\\S+@\\S+\\.\\S+/.test(value);\nconst isValidTransaction = (transaction)=>typeof transaction === \"object\" && transaction !== null && \"from\" in transaction;\nconst isValidTransactions = (transactions)=>Array.isArray(transactions) && transactions.every((tx)=>isValidTransaction(tx));\nfunction getEvmSupport() {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { networks } = yield fetch(\"https://api.blocto.app/networks/evm\").then((response)=>response.json());\n        const evmSupportMap = networks.reduce((a, v)=>Object.assign(Object.assign({}, a), {\n                [v.chain_id]: v\n            }), {});\n        return evmSupportMap;\n    });\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar dist = {};\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n        writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _assertThisInitialized(self1) {\n    if (self1 === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self1;\n}\nfunction _possibleConstructorReturn(self1, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    } else if (call !== void 0) {\n        throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self1);\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _isNativeReflectConstruct$1() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct$1()) {\n        _construct = Reflect.construct.bind();\n    } else {\n        _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (Class === null || !_isNativeFunction(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n}\nvar classes = {};\nvar fastSafeStringify = stringify;\nstringify[\"default\"] = stringify;\nstringify.stable = deterministicStringify;\nstringify.stableStringify = deterministicStringify;\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(obj, replacer, spacer);\n        } else {\n            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (_typeof(val) === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty(classes, \"__esModule\", {\n    value: true\n});\nclasses.EthereumProviderError = classes.EthereumRpcError = void 0;\nvar fast_safe_stringify_1 = fastSafeStringify;\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n * Permits any integer error code.\n */ var EthereumRpcError = /*#__PURE__*/ function(_Error) {\n    _inherits(EthereumRpcError, _Error);\n    var _super = _createSuper(EthereumRpcError);\n    function EthereumRpcError(code, message, data) {\n        var _this;\n        _classCallCheck(this, EthereumRpcError);\n        if (!Number.isInteger(code)) {\n            throw new Error('\"code\" must be an integer.');\n        }\n        if (!message || typeof message !== \"string\") {\n            throw new Error('\"message\" must be a nonempty string.');\n        }\n        _this = _super.call(this, message);\n        _this.code = code;\n        if (data !== undefined) {\n            _this.data = data;\n        }\n        return _this;\n    }\n    /**\n   * Returns a plain object with all public class properties.\n   */ _createClass(EthereumRpcError, [\n        {\n            key: \"serialize\",\n            value: function serialize() {\n                var serialized = {\n                    code: this.code,\n                    message: this.message\n                };\n                if (this.data !== undefined) {\n                    serialized.data = this.data;\n                }\n                if (this.stack) {\n                    serialized.stack = this.stack;\n                }\n                return serialized;\n            }\n        },\n        {\n            key: \"toString\",\n            value: function toString() {\n                return fast_safe_stringify_1[\"default\"](this.serialize(), stringifyReplacer, 2);\n            }\n        }\n    ]);\n    return EthereumRpcError;\n}(/*#__PURE__*/ _wrapNativeSuper(Error));\nclasses.EthereumRpcError = EthereumRpcError;\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */ var EthereumProviderError = /*#__PURE__*/ function(_EthereumRpcError) {\n    _inherits(EthereumProviderError, _EthereumRpcError);\n    var _super2 = _createSuper(EthereumProviderError);\n    /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */ function EthereumProviderError(code, message, data) {\n        _classCallCheck(this, EthereumProviderError);\n        if (!isValidEthProviderCode(code)) {\n            throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        }\n        return _super2.call(this, code, message, data);\n    }\n    return _createClass(EthereumProviderError);\n}(EthereumRpcError);\nclasses.EthereumProviderError = EthereumProviderError;\n// Internal\nfunction isValidEthProviderCode(code) {\n    return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n    if (value === \"[Circular]\") {\n        return undefined;\n    }\n    return value;\n}\nvar utils = {};\nvar errorConstants = {};\nObject.defineProperty(errorConstants, \"__esModule\", {\n    value: true\n});\nerrorConstants.errorValues = errorConstants.errorCodes = void 0;\nerrorConstants.errorCodes = {\n    rpc: {\n        invalidInput: -32000,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n};\nerrorConstants.errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    \"4001\": {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    \"4100\": {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    \"4200\": {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    \"4900\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    \"4901\": {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\n(function(exports1) {\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.serializeError = exports1.isValidCode = exports1.getMessageFromCode = exports1.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\n    var error_constants_1 = errorConstants;\n    var classes_1 = classes;\n    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;\n    var FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\n    var FALLBACK_ERROR = {\n        code: FALLBACK_ERROR_CODE,\n        message: getMessageFromCode(FALLBACK_ERROR_CODE)\n    };\n    exports1.JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\n    /**\n   * Gets the message for a given code, or a fallback message if the code has\n   * no corresponding message.\n   */ function getMessageFromCode(code) {\n        var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;\n        if (Number.isInteger(code)) {\n            var codeString = code.toString();\n            if (hasKey(error_constants_1.errorValues, codeString)) {\n                return error_constants_1.errorValues[codeString].message;\n            }\n            if (isJsonRpcServerError(code)) {\n                return exports1.JSON_RPC_SERVER_ERROR_MESSAGE;\n            }\n        }\n        return fallbackMessage;\n    }\n    exports1.getMessageFromCode = getMessageFromCode;\n    /**\n   * Returns whether the given code is valid.\n   * A code is only valid if it has a message.\n   */ function isValidCode(code) {\n        if (!Number.isInteger(code)) {\n            return false;\n        }\n        var codeString = code.toString();\n        if (error_constants_1.errorValues[codeString]) {\n            return true;\n        }\n        if (isJsonRpcServerError(code)) {\n            return true;\n        }\n        return false;\n    }\n    exports1.isValidCode = isValidCode;\n    /**\n   * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n   * Merely copies the given error's values if it is already compatible.\n   * If the given error is not fully compatible, it will be preserved on the\n   * returned object's data.originalError property.\n   */ function serializeError(error) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$fallbackError = _ref.fallbackError, fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError, _ref$shouldIncludeSta = _ref.shouldIncludeStack, shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;\n        var _a, _b;\n        if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== \"string\") {\n            throw new Error(\"Must provide fallback error with integer number code and string message.\");\n        }\n        if (error instanceof classes_1.EthereumRpcError) {\n            return error.serialize();\n        }\n        var serialized = {};\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error) && hasKey(error, \"code\") && isValidCode(error.code)) {\n            var _error = error;\n            serialized.code = _error.code;\n            if (_error.message && typeof _error.message === \"string\") {\n                serialized.message = _error.message;\n                if (hasKey(_error, \"data\")) {\n                    serialized.data = _error.data;\n                }\n            } else {\n                serialized.message = getMessageFromCode(serialized.code);\n                serialized.data = {\n                    originalError: assignOriginalError(error)\n                };\n            }\n        } else {\n            serialized.code = fallbackError.code;\n            var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;\n            serialized.message = message && typeof message === \"string\" ? message : fallbackError.message;\n            serialized.data = {\n                originalError: assignOriginalError(error)\n            };\n        }\n        var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;\n        if (shouldIncludeStack && error && stack && typeof stack === \"string\") {\n            serialized.stack = stack;\n        }\n        return serialized;\n    }\n    exports1.serializeError = serializeError;\n    // Internal\n    function isJsonRpcServerError(code) {\n        return code >= -32099 && code <= -32000;\n    }\n    function assignOriginalError(error) {\n        if (error && _typeof(error) === \"object\" && !Array.isArray(error)) {\n            return Object.assign({}, error);\n        }\n        return error;\n    }\n    function hasKey(obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n    }\n})(utils);\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;\n        try {\n            if (_x = (_i = _i.call(arr)).next, 0 === i) {\n                if (Object(_i) !== _i) return;\n                _n = !1;\n            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n        } catch (err) {\n            _d = !0, _e = err;\n        } finally{\n            try {\n                if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nvar errors = {};\nObject.defineProperty(errors, \"__esModule\", {\n    value: true\n});\nerrors.ethErrors = void 0;\nvar classes_1 = classes;\nvar utils_1 = utils;\nvar error_constants_1 = errorConstants;\nerrors.ethErrors = {\n    rpc: {\n        /**\n     * Get a JSON RPC 2.0 Parse (-32700) error.\n     */ parse: function parse(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n     */ invalidRequest: function invalidRequest(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n     */ invalidParams: function invalidParams(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n     */ methodNotFound: function methodNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Internal (-32603) error.\n     */ internal: function internal(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);\n        },\n        /**\n     * Get a JSON RPC 2.0 Server error.\n     * Permits integer error codes in the [ -32099 <= -32005 ] range.\n     * Codes -32000 through -32004 are reserved by EIP-1474.\n     */ server: function server(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n            }\n            var code = opts.code;\n            if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n                throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n            }\n            return getEthJsonRpcError(code, opts);\n        },\n        /**\n     * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n     */ invalidInput: function invalidInput(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n     */ resourceNotFound: function resourceNotFound(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n     */ resourceUnavailable: function resourceUnavailable(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n     */ transactionRejected: function transactionRejected(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n     */ methodNotSupported: function methodNotSupported(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);\n        },\n        /**\n     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n     */ limitExceeded: function limitExceeded(arg) {\n            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);\n        }\n    },\n    provider: {\n        /**\n     * Get an Ethereum Provider User Rejected Request (4001) error.\n     */ userRejectedRequest: function userRejectedRequest(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unauthorized (4100) error.\n     */ unauthorized: function unauthorized(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);\n        },\n        /**\n     * Get an Ethereum Provider Unsupported Method (4200) error.\n     */ unsupportedMethod: function unsupportedMethod(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);\n        },\n        /**\n     * Get an Ethereum Provider Not Connected (4900) error.\n     */ disconnected: function disconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);\n        },\n        /**\n     * Get an Ethereum Provider Chain Not Connected (4901) error.\n     */ chainDisconnected: function chainDisconnected(arg) {\n            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);\n        },\n        /**\n     * Get a custom Ethereum Provider error.\n     */ custom: function custom(opts) {\n            if (!opts || _typeof(opts) !== \"object\" || Array.isArray(opts)) {\n                throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n            }\n            var code = opts.code, message = opts.message, data = opts.data;\n            if (!message || typeof message !== \"string\") {\n                throw new Error('\"message\" must be a nonempty string');\n            }\n            return new classes_1.EthereumProviderError(code, message, data);\n        }\n    }\n};\n// Internal\nfunction getEthJsonRpcError(code, arg) {\n    var _parseOpts = parseOpts(arg), _parseOpts2 = _slicedToArray(_parseOpts, 2), message = _parseOpts2[0], data = _parseOpts2[1];\n    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n    var _parseOpts3 = parseOpts(arg), _parseOpts4 = _slicedToArray(_parseOpts3, 2), message = _parseOpts4[0], data = _parseOpts4[1];\n    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);\n}\nfunction parseOpts(arg) {\n    if (arg) {\n        if (typeof arg === \"string\") {\n            return [\n                arg\n            ];\n        } else if (_typeof(arg) === \"object\" && !Array.isArray(arg)) {\n            var message = arg.message, data = arg.data;\n            if (message && typeof message !== \"string\") {\n                throw new Error(\"Must specify string message.\");\n            }\n            return [\n                message || undefined,\n                data\n            ];\n        }\n    }\n    return [];\n}\n(function(exports1) {\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.getMessageFromCode = exports1.serializeError = exports1.EthereumProviderError = exports1.EthereumRpcError = exports1.ethErrors = exports1.errorCodes = void 0;\n    var classes_1 = classes;\n    Object.defineProperty(exports1, \"EthereumRpcError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumRpcError;\n        }\n    });\n    Object.defineProperty(exports1, \"EthereumProviderError\", {\n        enumerable: true,\n        get: function get() {\n            return classes_1.EthereumProviderError;\n        }\n    });\n    var utils_1 = utils;\n    Object.defineProperty(exports1, \"serializeError\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.serializeError;\n        }\n    });\n    Object.defineProperty(exports1, \"getMessageFromCode\", {\n        enumerable: true,\n        get: function get() {\n            return utils_1.getMessageFromCode;\n        }\n    });\n    var errors_1 = errors;\n    Object.defineProperty(exports1, \"ethErrors\", {\n        enumerable: true,\n        get: function get() {\n            return errors_1.ethErrors;\n        }\n    });\n    var error_constants_1 = errorConstants;\n    Object.defineProperty(exports1, \"errorCodes\", {\n        enumerable: true,\n        get: function get() {\n            return error_constants_1.errorCodes;\n        }\n    });\n})(dist);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self :  false ? 0 : {};\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\nvar inited = false;\nfunction init() {\n    inited = true;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for(var i = 0, len = code.length; i < len; ++i){\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n    }\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n}\nfunction toByteArray(b64) {\n    if (!inited) {\n        init();\n    }\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n    if (len % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n    placeHolders = b64[len - 2] === \"=\" ? 2 : b64[len - 1] === \"=\" ? 1 : 0;\n    // base64 is 4/3 + up to two characters of the original data\n    arr = new Arr(len * 3 / 4 - placeHolders);\n    // if there are placeholders, only get up to the last complete 4 chars\n    l = placeHolders > 0 ? len - 4 : len;\n    var L = 0;\n    for(i = 0, j = 0; i < l; i += 4, j += 3){\n        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n        arr[L++] = tmp >> 16 & 0xFF;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    if (placeHolders === 2) {\n        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[L++] = tmp >> 8 & 0xFF;\n        arr[L++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\nfunction encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n        output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n}\nfunction fromByteArray(uint8) {\n    if (!inited) {\n        init();\n    }\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n    var output = \"\";\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){\n        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    }\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        output += lookup[tmp >> 2];\n        output += lookup[tmp << 4 & 0x3F];\n        output += \"==\";\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        output += lookup[tmp >> 10];\n        output += lookup[tmp >> 4 & 0x3F];\n        output += lookup[tmp << 2 & 0x3F];\n        output += \"=\";\n    }\n    parts.push(output);\n    return parts.join(\"\");\n}\nfunction read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}\n    if (e === 0) {\n        e = 1 - eBias;\n    } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n}\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) {\n            value += rt / c;\n        } else {\n            value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}\n    buffer[offset + i - d] |= s * 128;\n}\nvar toString = {}.toString;\nvar isArray = Array.isArray || function(arr) {\n    return toString.call(arr) == \"[object Array]\";\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */ var INSPECT_MAX_BYTES = 50;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */ Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n/*\n * Export kMaxLength after typed array support is determined.\n */ kMaxLength();\nfunction kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\nfunction createBuffer(that, length) {\n    if (kMaxLength() < length) {\n        throw new RangeError(\"Invalid typed array length\");\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = new Uint8Array(length);\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        if (that === null) {\n            that = new Buffer(length);\n        }\n        that.length = length;\n    }\n    return that;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n        return new Buffer(arg, encodingOrOffset, length);\n    }\n    // Common case.\n    if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n            throw new Error(\"If encoding is specified then the first argument must be a string\");\n        }\n        return allocUnsafe(this, arg);\n    }\n    return from(this, arg, encodingOrOffset, length);\n}\nBuffer.poolSize = 8192; // not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function(arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n};\nfunction from(that, value, encodingOrOffset, length) {\n    if (typeof value === \"number\") {\n        throw new TypeError('\"value\" argument must not be a number');\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer) {\n        return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n    if (typeof value === \"string\") {\n        return fromString(that, value, encodingOrOffset);\n    }\n    return fromObject(that, value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ Buffer.from = function(value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n};\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n    if (typeof Symbol !== \"undefined\" && Symbol.species && Buffer[Symbol.species] === Buffer) ;\n}\nfunction assertSize(size) {\n    if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be a number');\n    } else if (size < 0) {\n        throw new RangeError('\"size\" argument must not be negative');\n    }\n}\nfunction alloc(that, size, fill, encoding) {\n    assertSize(size);\n    if (size <= 0) {\n        return createBuffer(that, size);\n    }\n    if (fill !== undefined) {\n        // Only pay attention to encoding if it's a string. This\n        // prevents accidentally sending in a number that would\n        // be interpretted as a start offset.\n        return typeof encoding === \"string\" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n    return createBuffer(that, size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ Buffer.alloc = function(size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n};\nfunction allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n        for(var i = 0; i < size; ++i){\n            that[i] = 0;\n        }\n    }\n    return that;\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ Buffer.allocUnsafe = function(size) {\n    return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ Buffer.allocUnsafeSlow = function(size) {\n    return allocUnsafe(null, size);\n};\nfunction fromString(that, string, encoding) {\n    if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n    }\n    if (!Buffer.isEncoding(encoding)) {\n        throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n    if (actual !== length) {\n        // Writing a hex string, for example, that contains invalid characters will\n        // cause everything after the first invalid character to be ignored. (e.g.\n        // 'abxxcd' will be treated as 'ab')\n        that = that.slice(0, actual);\n    }\n    return that;\n}\nfunction fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n    for(var i = 0; i < length; i += 1){\n        that[i] = array[i] & 255;\n    }\n    return that;\n}\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError(\"'offset' is out of bounds\");\n    }\n    if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError(\"'length' is out of bounds\");\n    }\n    if (byteOffset === undefined && length === undefined) {\n        array = new Uint8Array(array);\n    } else if (length === undefined) {\n        array = new Uint8Array(array, byteOffset);\n    } else {\n        array = new Uint8Array(array, byteOffset, length);\n    }\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        // Return an augmented `Uint8Array` instance, for best performance\n        that = array;\n        that.__proto__ = Buffer.prototype;\n    } else {\n        // Fallback: Return an object instance of the Buffer class\n        that = fromArrayLike(that, array);\n    }\n    return that;\n}\nfunction fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        that = createBuffer(that, len);\n        if (that.length === 0) {\n            return that;\n        }\n        obj.copy(that, 0, 0, len);\n        return that;\n    }\n    if (obj) {\n        if (typeof ArrayBuffer !== \"undefined\" && obj.buffer instanceof ArrayBuffer || \"length\" in obj) {\n            if (typeof obj.length !== \"number\" || isnan(obj.length)) {\n                return createBuffer(that, 0);\n            }\n            return fromArrayLike(that, obj);\n        }\n        if (obj.type === \"Buffer\" && isArray(obj.data)) {\n            return fromArrayLike(that, obj.data);\n        }\n    }\n    throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n}\nfunction checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + kMaxLength().toString(16) + \" bytes\");\n    }\n    return length | 0;\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer);\n}\nBuffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n        throw new TypeError(\"Arguments must be Buffers\");\n    }\n    if (a === b) return 0;\n    var x = a.length;\n    var y = b.length;\n    for(var i = 0, len = Math.min(x, y); i < len; ++i){\n        if (a[i] !== b[i]) {\n            x = a[i];\n            y = b[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\nBuffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return true;\n        default:\n            return false;\n    }\n};\nBuffer.concat = function concat(list, length) {\n    if (!isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    if (list.length === 0) {\n        return Buffer.alloc(0);\n    }\n    var i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i){\n            length += list[i].length;\n        }\n    }\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n    for(i = 0; i < list.length; ++i){\n        var buf = list[i];\n        if (!internalIsBuffer(buf)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n        }\n        buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n        return string.length;\n    }\n    if (typeof ArrayBuffer !== \"undefined\" && typeof ArrayBuffer.isView === \"function\" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n        return string.byteLength;\n    }\n    if (typeof string !== \"string\") {\n        string = \"\" + string;\n    }\n    var len = string.length;\n    if (len === 0) return 0;\n    // Use a for loop to avoid recursion\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"ascii\":\n            case \"latin1\":\n            case \"binary\":\n                return len;\n            case \"utf8\":\n            case \"utf-8\":\n            case undefined:\n                return utf8ToBytes(string).length;\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return len * 2;\n            case \"hex\":\n                return len >>> 1;\n            case \"base64\":\n                return base64ToBytes(string).length;\n            default:\n                if (loweredCase) return utf8ToBytes(string).length // assume utf8\n                ;\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\nBuffer.byteLength = byteLength;\nfunction slowToString(encoding, start, end) {\n    var loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) {\n        start = 0;\n    }\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) {\n        return \"\";\n    }\n    if (end === undefined || end > this.length) {\n        end = this.length;\n    }\n    if (end <= 0) {\n        return \"\";\n    }\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) {\n        return \"\";\n    }\n    if (!encoding) encoding = \"utf8\";\n    while(true){\n        switch(encoding){\n            case \"hex\":\n                return hexSlice(this, start, end);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Slice(this, start, end);\n            case \"ascii\":\n                return asciiSlice(this, start, end);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Slice(this, start, end);\n            case \"base64\":\n                return base64Slice(this, start, end);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return utf16leSlice(this, start, end);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (encoding + \"\").toLowerCase();\n                loweredCase = true;\n        }\n    }\n}\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\nfunction swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\nBuffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n    if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    }\n    for(var i = 0; i < len; i += 2){\n        swap(this, i, i + 1);\n    }\n    return this;\n};\nBuffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n    if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    }\n    for(var i = 0; i < len; i += 4){\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n    }\n    return this;\n};\nBuffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n    if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    }\n    for(var i = 0; i < len; i += 8){\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n    }\n    return this;\n};\nBuffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0) return \"\";\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n};\nBuffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n};\nBuffer.prototype.inspect = function inspect() {\n    var str = \"\";\n    var max = INSPECT_MAX_BYTES;\n    if (this.length > 0) {\n        str = this.toString(\"hex\", 0, max).match(/.{2}/g).join(\" \");\n        if (this.length > max) str += \" ... \";\n    }\n    return \"<Buffer \" + str + \">\";\n};\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n        throw new TypeError(\"Argument must be a Buffer\");\n    }\n    if (start === undefined) {\n        start = 0;\n    }\n    if (end === undefined) {\n        end = target ? target.length : 0;\n    }\n    if (thisStart === undefined) {\n        thisStart = 0;\n    }\n    if (thisEnd === undefined) {\n        thisEnd = this.length;\n    }\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n    }\n    if (thisStart >= thisEnd && start >= end) {\n        return 0;\n    }\n    if (thisStart >= thisEnd) {\n        return -1;\n    }\n    if (start >= end) {\n        return 1;\n    }\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n    for(var i = 0; i < len; ++i){\n        if (thisCopy[i] !== targetCopy[i]) {\n            x = thisCopy[i];\n            y = targetCopy[i];\n            break;\n        }\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n        byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n        byteOffset = -0x80000000;\n    }\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (isNaN(byteOffset)) {\n        // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n        byteOffset = dir ? 0 : buffer.length - 1;\n    }\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === \"string\") {\n        val = Buffer.from(val, encoding);\n    }\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (internalIsBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) {\n            return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === \"number\") {\n        val = val & 0xFF; // Search for a byte value [0-255]\n        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === \"function\") {\n            if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n            }\n        }\n        return arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n            if (arr.length < 2 || val.length < 2) {\n                return -1;\n            }\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) {\n            return buf[i];\n        } else {\n            return buf.readUInt16BE(i * indexSize);\n        }\n    }\n    var i;\n    if (dir) {\n        var foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++){\n            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n            } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n            }\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            var found = true;\n            for(var j = 0; j < valLength; j++){\n                if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n    if (!length) {\n        length = remaining;\n    } else {\n        length = Number(length);\n        if (length > remaining) {\n            length = remaining;\n        }\n    }\n    // must be an even number of digits\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError(\"Invalid hex string\");\n    if (length > strLen / 2) {\n        length = strLen / 2;\n    }\n    for(var i = 0; i < length; ++i){\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (isNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\nfunction latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n}\nfunction base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\nfunction ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset | 0;\n        if (isFinite(length)) {\n            length = length | 0;\n            if (encoding === undefined) encoding = \"utf8\";\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n    } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n    }\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n    }\n    if (!encoding) encoding = \"utf8\";\n    var loweredCase = false;\n    for(;;){\n        switch(encoding){\n            case \"hex\":\n                return hexWrite(this, string, offset, length);\n            case \"utf8\":\n            case \"utf-8\":\n                return utf8Write(this, string, offset, length);\n            case \"ascii\":\n                return asciiWrite(this, string, offset, length);\n            case \"latin1\":\n            case \"binary\":\n                return latin1Write(this, string, offset, length);\n            case \"base64\":\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n                return ucs2Write(this, string, offset, length);\n            default:\n                if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n                encoding = (\"\" + encoding).toLowerCase();\n                loweredCase = true;\n        }\n    }\n};\nBuffer.prototype.toJSON = function toJSON() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n        return fromByteArray(buf);\n    } else {\n        return fromByteArray(buf.slice(start, end));\n    }\n}\nfunction utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n    while(i < end){\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            var secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) {\n                        codePoint = firstByte;\n                    }\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                            codePoint = tempCodePoint;\n                        }\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n        ;\n    }\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    var res = \"\";\n    var i = 0;\n    while(i < len){\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n    return res;\n}\nfunction asciiSlice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n    return ret;\n}\nfunction latin1Slice(buf, start, end) {\n    var ret = \"\";\n    end = Math.min(buf.length, end);\n    for(var i = start; i < end; ++i){\n        ret += String.fromCharCode(buf[i]);\n    }\n    return ret;\n}\nfunction hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = \"\";\n    for(var i = start; i < end; ++i){\n        out += toHex(buf[i]);\n    }\n    return out;\n}\nfunction utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = \"\";\n    for(var i = 0; i < bytes.length; i += 2){\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n    return res;\n}\nBuffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) {\n        start = len;\n    }\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) {\n        end = len;\n    }\n    if (end < start) end = start;\n    var newBuf;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        newBuf = this.subarray(start, end);\n        newBuf.__proto__ = Buffer.prototype;\n    } else {\n        var sliceLen = end - start;\n        newBuf = new Buffer(sliceLen, undefined);\n        for(var i = 0; i < sliceLen; ++i){\n            newBuf[i] = this[i + start];\n        }\n    }\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n    if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n}\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        checkOffset(offset, byteLength, this.length);\n    }\n    var val = this[offset + --byteLength];\n    var mul = 1;\n    while(byteLength > 0 && (mul *= 0x100)){\n        val += this[offset + --byteLength] * mul;\n    }\n    return val;\n};\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n};\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n    while(++i < byteLength && (mul *= 0x100)){\n        val += this[offset + i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100)){\n        val += this[offset + --i] * mul;\n    }\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4);\n};\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4);\n};\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8);\n};\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8);\n};\nfunction checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n}\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        this[offset + i] = value / mul & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i){\n        buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n    }\n}\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i){\n        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n    }\n}\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset + 3] = value >>> 24;\n        this[offset + 2] = value >>> 16;\n        this[offset + 1] = value >>> 8;\n        this[offset] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength - 1);\n        checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n            sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n    } else {\n        objectWriteUInt16(this, value, offset, true);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 8;\n        this[offset + 1] = value & 0xff;\n    } else {\n        objectWriteUInt16(this, value, offset, false);\n    }\n    return offset + 2;\n};\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value & 0xff;\n        this[offset + 1] = value >>> 8;\n        this[offset + 2] = value >>> 16;\n        this[offset + 3] = value >>> 24;\n    } else {\n        objectWriteUInt32(this, value, offset, true);\n    }\n    return offset + 4;\n};\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n        this[offset] = value >>> 24;\n        this[offset + 1] = value >>> 16;\n        this[offset + 2] = value >>> 8;\n        this[offset + 3] = value & 0xff;\n    } else {\n        objectWriteUInt32(this, value, offset, false);\n    }\n    return offset + 4;\n};\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    if (offset < 0) throw new RangeError(\"Index out of range\");\n}\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4);\n    }\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n};\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8);\n    }\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n};\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n    }\n    if (start < 0 || start >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n    if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n    }\n    var len = end - start;\n    var i;\n    if (this === target && start < targetStart && targetStart < end) {\n        // descending copy from end\n        for(i = len - 1; i >= 0; --i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n        // ascending copy from start\n        for(i = 0; i < len; ++i){\n            target[i + targetStart] = this[i + start];\n        }\n    } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === \"string\") {\n            encoding = end;\n            end = this.length;\n        }\n        if (val.length === 1) {\n            var code = val.charCodeAt(0);\n            if (code < 256) {\n                val = code;\n            }\n        }\n        if (encoding !== undefined && typeof encoding !== \"string\") {\n            throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer.isEncoding(encoding)) {\n            throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n    } else if (typeof val === \"number\") {\n        val = val & 255;\n    }\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n    }\n    if (end <= start) {\n        return this;\n    }\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    var i;\n    if (typeof val === \"number\") {\n        for(i = start; i < end; ++i){\n            this[i] = val;\n        }\n    } else {\n        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n        var len = bytes.length;\n        for(i = 0; i < end - start; ++i){\n            this[i + start] = bytes[i % len];\n        }\n    }\n    return this;\n};\n// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\nfunction base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, \"\");\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return \"\";\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0){\n        str = str + \"=\";\n    }\n    return str;\n}\nfunction stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction toHex(n) {\n    if (n < 16) return \"0\" + n.toString(16);\n    return n.toString(16);\n}\nfunction utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n    for(var i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) {\n            // valid bmp char, but last char was a lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else {\n            throw new Error(\"Invalid code point\");\n        }\n    }\n    return bytes;\n}\nfunction asciiToBytes(str) {\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        // Node's code seems to be doing this and not & 0x7F..\n        byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n    return byteArray;\n}\nfunction utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n    for(var i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction base64ToBytes(str) {\n    return toByteArray(base64clean(str));\n}\nfunction blitBuffer(src, dst, offset, length) {\n    for(var i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\nfunction isnan(val) {\n    return val !== val // eslint-disable-line no-self-compare\n    ;\n}\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n}\nfunction isFastBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isFastBuffer(obj.slice(0, 0));\n}\nconst isHexString = (hex)=>typeof hex === \"string\" && /^0x[0-9A-Fa-f]*$/.test(hex);\nconst utf8ToHex = (str)=>{\n    return Buffer.from(str, \"utf8\").toString(\"hex\");\n};\nvar _EthereumProvider_instances, _EthereumProvider_getBloctoProperties, _EthereumProvider_addToSwitchable, _EthereumProvider_checkNetworkMatched;\nfunction parseChainId(chainId) {\n    if (!chainId) {\n        return 1;\n    }\n    if (typeof chainId === \"number\") {\n        return chainId;\n    } else if (chainId.startsWith(\"0x\")) {\n        return parseInt(chainId, 16);\n    }\n    return parseInt(chainId, 10);\n}\nclass EthereumProvider extends BloctoProvider {\n    constructor({ chainId, rpc, walletServer, appId }){\n        super();\n        _EthereumProvider_instances.add(this);\n        this.networkVersion = \"1\"; // same as chainId but in decimal\n        // setup chainId\n        invariant(chainId, \"'chainId' is required\");\n        this.networkVersion = `${parseChainId(chainId)}`;\n        this.chainId = `0x${parseChainId(chainId).toString(16)}`;\n        // setup rpc\n        this.rpc = rpc || ETH_RPC_LIST[this.networkVersion];\n        invariant(this.rpc, \"'rpc' is required\");\n        // setup injectedWalletServer\n        this.injectedWalletServer = walletServer;\n        // NOTE: _blocto is not fully initialized yet at this point\n        // Any function should call #getBloctoProperties() to get the full _blocto properties\n        this._blocto = {\n            sessionKey: KEY_SESSION.prod,\n            walletServer: this.injectedWalletServer || \"\",\n            blockchainName: \"\",\n            networkType: \"\",\n            supportNetworkList: {},\n            switchableNetwork: {}\n        };\n        this.appId = appId || DEFAULT_APP_ID;\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#ethereum-send-deprecated\n    send(methodOrPayload, paramsOrCallback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(true){\n                // signature type 1: arg1 - JSON-RPC payload, arg2 - callback;\n                // ethereum.send(payload: JsonRpcRequest, callback: JsonRpcCallback): void;\n                // This signature is exactly like ethereum.sendAsync()\n                case paramsOrCallback instanceof Function:\n                    return this.sendAsync(methodOrPayload, paramsOrCallback);\n                // signature type 2: arg1 - JSON-RPC method name, arg2 - params array;\n                // ethereum.send(method: string, params?: Array<unknown>): Promise<JsonRpcResponse>;\n                // This signature is like an async ethereum.sendAsync() with method and params as arguments,\n                // instead of a JSON-RPC payload and callback\n                case typeof methodOrPayload === \"string\" && Array.isArray(paramsOrCallback):\n                    return this.sendAsync({\n                        jsonrpc: \"2.0\",\n                        method: methodOrPayload,\n                        params: paramsOrCallback\n                    });\n                // signature type 3: arg1 - JSON-RPC payload(should be synchronous methods)\n                // ethereum.send(payload: JsonRpcRequest): unknown;\n                // This signature enables you to call some type of RPC methods synchronously\n                default:\n                    return this.sendAsync(methodOrPayload);\n            }\n        });\n    }\n    // DEPRECATED API: see https://docs.metamask.io/guide/ethereum-provider.html#legacy-methods implementation\n    // web3 v1.x BatchRequest still depends on it so we need to implement anyway \\_()_/\n    sendAsync(payload, callback) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const handleRequest = new Promise((resolve)=>{\n                // web3 v1.x concat batched JSON-RPC requests to an array, handle it here\n                if (Array.isArray(payload)) {\n                    // collect transactions and send batch with custom method\n                    const transactions = payload.filter((request)=>request.method === \"eth_sendTransaction\").map((request)=>{\n                        var _a;\n                        return (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n                    });\n                    const idBase = Math.floor(Math.random() * 10000);\n                    const batchedRequestPayload = {\n                        method: \"blocto_sendBatchTransaction\",\n                        params: transactions\n                    };\n                    const batchResponsePromise = this.request(batchedRequestPayload);\n                    const requests = payload.map(({ method, params }, index)=>method === \"eth_sendTransaction\" ? batchResponsePromise : this.request({\n                            id: idBase + index + 1,\n                            jsonrpc: \"2.0\",\n                            method,\n                            params\n                        }));\n                    // resolve response when all request are executed\n                    Promise.allSettled(requests).then((responses)=>resolve(responses.map((response, index)=>{\n                            return {\n                                id: String(idBase + index + 1),\n                                jsonrpc: \"2.0\",\n                                method: payload[index].method,\n                                result: response.status === \"fulfilled\" ? response.value : undefined,\n                                error: response.status !== \"fulfilled\" ? response.reason : undefined\n                            };\n                        }))).catch((error)=>{\n                        throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n                    });\n                } else {\n                    this.request(Object.assign(Object.assign({}, payload), {\n                        id: Number(payload.id)\n                    })).then(resolve);\n                }\n            });\n            // execute callback or return promise, depdends on callback arg given or not\n            if (callback) {\n                handleRequest.then((data)=>callback(null, data)).catch((error)=>callback(error));\n            } else {\n                return handleRequest;\n            }\n        });\n    }\n    /**\n     * Sending userOperation using Blocto SDK.\n     * @param {IUserOperation} userOp - userOperation object\n     * @remarks No need to include nonce, initCode, and signature as parameters when using BloctoSDK to send userOperation.\n     * These parameters will be ignored.\n     * @returns {Promise<string>} - userOperation hash\n     */ sendUserOperation(userOp) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.request({\n                method: \"eth_sendUserOperation\",\n                params: [\n                    userOp\n                ]\n            });\n        });\n    }\n    request(payload) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!(payload === null || payload === void 0 ? void 0 : payload.method)) throw dist.ethErrors.rpc.invalidRequest();\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (payload.method === \"wallet_switchEthereumChain\") {\n                    if (!((_b = (_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams();\n                    }\n                    return existedSDK.request(payload).then(()=>{\n                        var _a, _b, _c;\n                        this.networkVersion = `${parseChainId((_a = payload === null || payload === void 0 ? void 0 : payload.params) === null || _a === void 0 ? void 0 : _a[0].chainId)}`;\n                        this.chainId = `0x${parseChainId((_b = payload === null || payload === void 0 ? void 0 : payload.params) === null || _b === void 0 ? void 0 : _b[0].chainId).toString(16)}`;\n                        this.rpc = (_c = switchableNetwork === null || switchableNetwork === void 0 ? void 0 : switchableNetwork[this.networkVersion]) === null || _c === void 0 ? void 0 : _c.rpc_url;\n                        return null;\n                    });\n                }\n                return existedSDK.request(payload);\n            }\n            const { blockchainName, switchableNetwork, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            // method that doesn't require user to be connected\n            switch(payload.method){\n                case \"eth_chainId\":\n                    {\n                        return this.chainId;\n                    }\n                case \"net_version\":\n                    {\n                        return this.networkVersion;\n                    }\n                case \"wallet_addEthereumChain\":\n                    {\n                        return this.loadSwitchableNetwork((payload === null || payload === void 0 ? void 0 : payload.params) || []);\n                    }\n                case \"eth_call\":\n                    {\n                        const response = yield this.handleReadRequests(payload);\n                        if (!response || response && !response.result && response.error) {\n                            const errorMessage = ((_c = response === null || response === void 0 ? void 0 : response.error) === null || _c === void 0 ? void 0 : _c.message) ? response.error.message : \"Request failed\";\n                            throw dist.ethErrors.rpc.internal(errorMessage);\n                        }\n                        return response.result;\n                    }\n                case \"wallet_switchEthereumChain\":\n                    {\n                        if (!((_e = (_d = payload === null || payload === void 0 ? void 0 : payload.params) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.chainId)) throw dist.ethErrors.rpc.invalidParams();\n                        const newChainId = payload.params[0].chainId;\n                        if (!getChainAddress(sessionKey, blockchainName)) {\n                            // directly switch network if user is not connected\n                            // TODO: add a confirm switch network dialog\n                            const phasedChainId = parseChainId(newChainId);\n                            if (!switchableNetwork[phasedChainId]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: `Unrecognized chain ID \"${newChainId}\". Try adding the chain using wallet_addEthereumChain first.`\n                                });\n                            }\n                            this.networkVersion = `${phasedChainId}`;\n                            this.chainId = `0x${phasedChainId.toString(16)}`;\n                            this.rpc = switchableNetwork[phasedChainId].rpc_url;\n                            this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                            return null;\n                        }\n                        break;\n                    }\n            }\n            // Method that requires user to be connected\n            if (!getChainAddress(sessionKey, blockchainName)) {\n                const email = (_f = payload === null || payload === void 0 ? void 0 : payload.params) === null || _f === void 0 ? void 0 : _f[0];\n                if (payload.method === \"eth_requestAccounts\" && isEmail(email)) {\n                    yield this.enable(email);\n                } else {\n                    yield this.enable();\n                }\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"eth_requestAccounts\":\n                        yield this.fetchAccounts();\n                    // eslint-disable-next-line\n                    case \"eth_accounts\":\n                        result = getChainAddress(sessionKey, blockchainName);\n                        break;\n                    case \"eth_coinbase\":\n                        {\n                            result = (_g = getChainAddress(sessionKey, blockchainName)) === null || _g === void 0 ? void 0 : _g[0];\n                            break;\n                        }\n                    case \"eth_signTypedData_v3\":\n                    case \"eth_signTypedData\":\n                    case \"eth_signTypedData_v4\":\n                    case \"personal_sign\":\n                    case \"eth_sign\":\n                        {\n                            result = yield this.handleSign(payload);\n                            break;\n                        }\n                    case \"wallet_disconnect\":\n                        {\n                            this.handleDisconnect();\n                            result = null;\n                            break;\n                        }\n                    case \"eth_sendTransaction\":\n                        result = yield this.handleSendTransaction(payload);\n                        break;\n                    case \"blocto_sendBatchTransaction\":\n                        result = yield this.handleSendBatchTransaction(payload);\n                        break;\n                    case \"eth_signTransaction\":\n                    case \"eth_sendRawTransaction\":\n                        {\n                            throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + payload.method);\n                        }\n                    case \"eth_sendUserOperation\":\n                        result = yield this.handleSendUserOperation(payload);\n                        break;\n                    case \"wallet_switchEthereumChain\":\n                        {\n                            if (!((_j = (_h = payload === null || payload === void 0 ? void 0 : payload.params) === null || _h === void 0 ? void 0 : _h[0]) === null || _j === void 0 ? void 0 : _j.chainId)) {\n                                throw dist.ethErrors.rpc.invalidParams();\n                            }\n                            const oldAccount = (_k = getChainAddress(sessionKey, blockchainName)) === null || _k === void 0 ? void 0 : _k[0];\n                            const oldChainId = this.chainId;\n                            const newChainId = payload.params[0].chainId;\n                            if (!switchableNetwork[parseChainId(newChainId)]) {\n                                throw dist.ethErrors.provider.custom({\n                                    code: 4902,\n                                    message: `Unrecognized chain ID \"${parseChainId(payload.params[0].chainId)}\". Try adding the chain using wallet_addEthereumChain first.`\n                                });\n                            }\n                            this.networkVersion = `${parseChainId(newChainId)}`;\n                            this.chainId = `0x${parseChainId(newChainId).toString(16)}`;\n                            this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                            yield this.enable().then(([newAccount])=>{\n                                var _a;\n                                if (newAccount !== oldAccount) {\n                                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.accountsChanged.forEach((listener)=>listener([\n                                            newAccount\n                                        ]));\n                                }\n                                this.eventListeners.chainChanged.forEach((listener)=>listener(this.chainId));\n                                result = null;\n                            }).catch((error)=>{\n                                this.networkVersion = `${parseChainId(oldChainId)}`;\n                                this.chainId = `0x${parseChainId(oldChainId).toString(16)}`;\n                                this.rpc = switchableNetwork[this.networkVersion].rpc_url;\n                                throw error;\n                            });\n                            break;\n                        }\n                    case \"eth_estimateUserOperationGas\":\n                    case \"eth_getUserOperationByHash\":\n                    case \"eth_getUserOperationReceipt\":\n                    case \"eth_supportedEntryPoints\":\n                        result = yield this.handleBundler(payload);\n                        break;\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw dist.ethErrors.rpc.internal(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                throw dist.ethErrors.rpc.internal(error === null || error === void 0 ? void 0 : error.message);\n            }\n        });\n    }\n    bloctoApi(url, options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const sessionId = ((_a = getAccountStorage(sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            if (!sessionId) {\n                throw dist.ethErrors.provider.unauthorized();\n            }\n            return fetch(`${walletServer}/api/${blockchainName}${url}`, Object.assign({\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }, options)).then((response)=>responseSessionGuard(response, sessionKey, ()=>{\n                    var _a;\n                    (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n                })).catch((e)=>{\n                if ((e === null || e === void 0 ? void 0 : e.error_code) === \"unsupported_method\") {\n                    throw dist.ethErrors.rpc.methodNotSupported(\"Method Not Supported: \" + e.message);\n                } else {\n                    throw dist.ethErrors.rpc.server({\n                        code: -32005,\n                        message: `Blocto server error: ${e.message}`\n                    });\n                }\n            });\n        });\n    }\n    responseListener(frame, objectKey) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === walletServer && e.data.type === \"ETH:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            resolve(e.data[objectKey]);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(frame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.handleDisconnect();\n                            }\n                            reject(dist.ethErrors.provider.userRejectedRequest(e.data.errorMessage));\n                        }\n                    }\n                    if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                        removeEventListener();\n                        detatchFrame(frame);\n                        reject(dist.ethErrors.provider.userRejectedRequest(\"User declined the request\"));\n                    }\n                }));\n        });\n    }\n    setIframe(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (true) {\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: \"Blocto SDK only works in browser environment\"\n                });\n            }\n            const { walletServer, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const frame = createFrame(`${walletServer}/${this.appId}/${blockchainName}${url}`);\n            attachFrame(frame);\n            return frame;\n        });\n    }\n    // eip-1102 alias\n    // DEPRECATED API: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1102.md\n    enable(email) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { walletServer, blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                if (existedSDK.chainId !== this.chainId) {\n                    yield existedSDK.request({\n                        method: \"wallet_addEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    yield existedSDK.request({\n                        method: \"wallet_switchEthereumChain\",\n                        params: [\n                            {\n                                chainId: this.chainId\n                            }\n                        ]\n                    });\n                    setChainAddress(sessionKey, blockchainName, [\n                        existedSDK.address\n                    ]);\n                }\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.enable().then(resolve).catch(reject), 10));\n            }\n            const address = getChainAddress(sessionKey, blockchainName);\n            if (address) {\n                return new Promise((resolve)=>{\n                    resolve(address);\n                });\n            }\n            const params = new URLSearchParams();\n            params.set(\"l6n\", window.location.origin);\n            params.set(\"v\", SDK_VERSION);\n            const emailParam = email && isEmail(email) ? `/${email}` : \"\";\n            const loginFrame = yield this.setIframe(`/authn${emailParam}?${params.toString()}`);\n            return new Promise((resolve, reject)=>{\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    var _a;\n                    const e = event;\n                    if (e.origin === walletServer) {\n                        if (e.data.type === \"ETH:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.connect.forEach((listener)=>listener({\n                                    chainId: this.chainId\n                                }));\n                            setAccountStorage(sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [blockchainName]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve([\n                                e.data.addr\n                            ]);\n                        }\n                        if (e.data.type === \"ETH:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(dist.ethErrors.provider.userRejectedRequest());\n                        }\n                    }\n                });\n            });\n        });\n    }\n    fetchAccounts() {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { blockchainName, sessionKey } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            const { accounts } = yield this.bloctoApi(`/accounts`);\n            setChainAddress(sessionKey, blockchainName, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json()).catch((e)=>{\n                throw dist.ethErrors.rpc.internal(e);\n            });\n        });\n    }\n    handleSign({ method, params }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let message = \"\";\n            if (Array.isArray(params)) {\n                if (method === \"eth_sign\") {\n                    message = isHexString(params[1]) ? params[1].slice(2) : utf8ToHex(params[1]);\n                } else if (method === \"personal_sign\") {\n                    message = isHexString(params[0]) ? params[0].slice(2) : utf8ToHex(params[0]);\n                } else if ([\n                    \"eth_signTypedData\",\n                    \"eth_signTypedData_v3\",\n                    \"eth_signTypedData_v4\"\n                ].includes(method)) {\n                    message = params[1];\n                    const { domain } = JSON.parse(message);\n                    if (isHexString(domain.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must be a number`);\n                    }\n                    if (parseChainId(domain.chainId) !== parseChainId(this.chainId)) {\n                        throw dist.ethErrors.rpc.invalidParams(`Provided chainId \"${domain.chainId}\" must match the active chainId \"${parseChainId(this.chainId)}\"`);\n                    }\n                }\n            }\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { signatureId } = yield this.bloctoApi(`/user-signature`, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    method,\n                    message\n                })\n            });\n            const signFrame = yield this.setIframe(`/user-signature/${signatureId}`);\n            return this.responseListener(signFrame, \"signature\");\n        });\n    }\n    handleSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            if (!isValidTransaction((_a = payload.params) === null || _a === void 0 ? void 0 : _a[0])) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            const { authorizationId } = yield this.bloctoApi(`/authz`, {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const authzFrame = yield this.setIframe(`/authz/${authorizationId}`);\n            return this.responseListener(authzFrame, \"txHash\");\n        });\n    }\n    handleSendBatchTransaction(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const extractParams = (params)=>params.map((param)=>\"params\" in param ? param.params[0] // handle passing web3.eth.sendTransaction.request(...) as a parameter with params\n                     : param);\n            const formatParams = extractParams(payload.params);\n            const copyPayload = Object.assign(Object.assign({}, payload), {\n                params: formatParams\n            });\n            if (!isValidTransactions(copyPayload.params)) {\n                throw dist.ethErrors.rpc.invalidParams();\n            }\n            return this.handleSendTransaction(copyPayload);\n        });\n    }\n    handleSendUserOperation(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            const { authorizationId } = yield this.bloctoApi(`/user-operation`, {\n                method: \"POST\",\n                body: JSON.stringify(payload.params)\n            });\n            const userOPFrame = yield this.setIframe(`/user-operation/${authorizationId}`);\n            return this.responseListener(userOPFrame, \"userOpHash\");\n        });\n    }\n    handleBundler(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_checkNetworkMatched).call(this);\n            return this.bloctoApi(`/rpc/bundler`, {\n                method: \"POST\",\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            });\n        });\n    }\n    handleDisconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.ethereum;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.disconnect();\n            }\n            const { sessionKey, blockchainName } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n            removeChainAddress(sessionKey, blockchainName);\n            (_a = this.eventListeners) === null || _a === void 0 ? void 0 : _a.disconnect.forEach((listener)=>listener(dist.ethErrors.provider.disconnected()));\n        });\n    }\n    loadSwitchableNetwork(networkList) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // setup switchable list if user set networkList\n            if (networkList === null || networkList === void 0 ? void 0 : networkList.length) {\n                const listToAdd = networkList.map(({ chainId, rpcUrls })=>{\n                    if (!chainId) throw dist.ethErrors.rpc.invalidParams(\"Empty chainId\");\n                    if (!(rpcUrls === null || rpcUrls === void 0 ? void 0 : rpcUrls.length)) throw dist.ethErrors.rpc.invalidParams(\"Empty rpcUrls\");\n                    return __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_addToSwitchable).call(this, {\n                        chainId: `${parseChainId(chainId)}`,\n                        rpcUrls\n                    });\n                });\n                return Promise.all(listToAdd).then(()=>null);\n            } else {\n                throw dist.ethErrors.rpc.invalidParams(\"Empty networkList\");\n            }\n        });\n    }\n}\n_EthereumProvider_instances = new WeakSet(), _EthereumProvider_getBloctoProperties = function _EthereumProvider_getBloctoProperties() {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (!Object.keys(this._blocto.supportNetworkList).length) {\n            yield getEvmSupport().then((result)=>this._blocto.supportNetworkList = result).catch((e)=>{\n                throw dist.ethErrors.provider.custom({\n                    code: 1001,\n                    message: `Get blocto server failed: ${e.message}`\n                });\n            });\n        }\n        const { chain_id, name, network_type, blocto_service_environment, display_name } = this._blocto.supportNetworkList[this.networkVersion];\n        if (!chain_id) throw dist.ethErrors.provider.unsupportedMethod(`Get support chain failed: ${this.networkVersion} might not be supported yet.`);\n        this._blocto = Object.assign(Object.assign({}, this._blocto), {\n            sessionKey: ETH_SESSION_KEY_MAPPING[blocto_service_environment],\n            walletServer: this.injectedWalletServer || ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment],\n            blockchainName: name,\n            networkType: network_type,\n            switchableNetwork: Object.assign(Object.assign({}, this._blocto.switchableNetwork), {\n                [chain_id]: {\n                    name,\n                    display_name,\n                    network_type,\n                    wallet_web_url: this._blocto.walletServer,\n                    rpc_url: this.rpc\n                }\n            })\n        });\n        return this._blocto;\n    });\n}, _EthereumProvider_addToSwitchable = function _EthereumProvider_addToSwitchable({ chainId, rpcUrls }) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { supportNetworkList } = yield __classPrivateFieldGet(this, _EthereumProvider_instances, \"m\", _EthereumProvider_getBloctoProperties).call(this);\n        const { chain_id, name, display_name, network_type, blocto_service_environment } = supportNetworkList[chainId];\n        const wallet_web_url = ETH_ENV_WALLET_SERVER_MAPPING[blocto_service_environment];\n        this._blocto.switchableNetwork[chain_id] = {\n            name,\n            display_name,\n            network_type,\n            wallet_web_url,\n            rpc_url: rpcUrls[0]\n        };\n    });\n}, _EthereumProvider_checkNetworkMatched = function _EthereumProvider_checkNetworkMatched() {\n    const existedSDK = window.ethereum;\n    if (existedSDK && existedSDK.isBlocto && parseChainId(existedSDK.chainId) !== parseChainId(this.chainId)) {\n        throw dist.ethErrors.provider.chainDisconnected();\n    }\n};\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    function encode(source) {\n        if (source instanceof Uint8Array) ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nconst basex = src;\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar bs58 = basex(ALPHABET);\nvar bs58$1 = /*@__PURE__*/ getDefaultExportFromCjs(bs58);\nlet Solana;\ntry {\n    Solana = require(\"@solana/web3.js\");\n} catch (_a) {\n// prevent crash if there is no @solana/web3.js.\n}\nclass SolanaProvider extends BloctoProvider {\n    constructor({ net = \"mainnet-beta\", server, appId, rpc }){\n        super();\n        invariant(net, \"'net' is required\");\n        invariant(Object.values(SOL_NET).includes(net), \"unsupported net\");\n        this.net = net;\n        this.rpc = rpc || (net === \"mainnet-beta\" ? \"https://free.rpcpool.com\" : `https://api.${net}.solana.com`);\n        this.server = server || SOL_NET_SERVER_MAPPING[this.net] || \"\";\n        this.appId = appId || DEFAULT_APP_ID;\n        this.sessionKey = SOL_SESSION_KEY_MAPPING[this.net];\n        if (!Solana) {\n            throw new Error(\"No @solana/web3.js installed. Please install it to interact with Solana.\");\n        }\n    }\n    request(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.request(payload);\n            }\n            if (!getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                yield this.connect();\n            }\n            try {\n                let response = null;\n                let result = null;\n                switch(payload.method){\n                    case \"connect\":\n                        result = yield this.fetchAccounts();\n                        break;\n                    case \"disconnect\":\n                        this.disconnect();\n                        break;\n                    case \"getAccounts\":\n                        result = ((_a = getChainAddress(this.sessionKey, CHAIN.SOLANA)) === null || _a === void 0 ? void 0 : _a.length) ? getChainAddress(this.sessionKey, CHAIN.SOLANA) : yield this.fetchAccounts();\n                        break;\n                    case \"getAccountInfo\":\n                        {\n                            // Format the data as the same format returning from Connection.getAccountInfo from @solana/web3.js\n                            // ref: https://solana-labs.github.io/solana-web3.js/classes/Connection.html#getAccountInfo\n                            const accountInfo = yield this.handleReadRequests(payload);\n                            const [bufferData, encoding] = accountInfo.result.value.data;\n                            result = Object.assign(Object.assign({}, accountInfo.result.value), {\n                                data: Buffer.from(bufferData, encoding),\n                                owner: new Solana.PublicKey(accountInfo.result.value.owner)\n                            });\n                            break;\n                        }\n                    // custom JSON-RPC method\n                    case \"convertToProgramWalletTransaction\":\n                        result = yield this.handleConvertTransaction(payload);\n                        break;\n                    // custom JSON-RPC method\n                    case \"signAndSendTransaction\":\n                        result = yield this.handleSignAndSendTransaction(payload);\n                        break;\n                    // block user from using traditional methods\n                    case \"signTransaction\":\n                    case \"signAllTransactions\":\n                        throw new Error(`Blocto is program wallet, which doesn't support ${payload.method}. Use signAndSendTransaction instead.`);\n                    default:\n                        response = yield this.handleReadRequests(payload);\n                }\n                if (response && !response.result && response.error) {\n                    const errorMessage = response.error.message ? response.error.message : \"Request failed\";\n                    throw new Error(errorMessage);\n                }\n                if (response) return response.result;\n                return result;\n            } catch (error) {\n                console.error(error);\n                throw error;\n            }\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return new Promise((resolve)=>{\n                    existedSDK.on(\"connect\", ()=>{\n                        setChainAddress(this.sessionKey, CHAIN.SOLANA, [\n                            existedSDK.publicKey.toBase58()\n                        ]);\n                        resolve();\n                    });\n                    existedSDK.connect();\n                });\n            }\n            return new Promise((resolve, reject)=>{\n                if (true) {\n                    return reject(\"Currently only supported in browser\");\n                }\n                if (getChainAddress(this.sessionKey, CHAIN.SOLANA)) {\n                    return resolve();\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/solana/authn?l6n=${location}&v=${SDK_VERSION}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>{\n                    const e = event;\n                    if (e.origin === this.server) {\n                        if (e.data.type === \"SOL:FRAME:RESPONSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            this.eventListeners.connect.forEach((listener)=>listener(this.net));\n                            setAccountStorage(this.sessionKey, {\n                                code: e.data.code,\n                                connected: true,\n                                accounts: {\n                                    [CHAIN.SOLANA]: [\n                                        e.data.addr\n                                    ]\n                                }\n                            }, e.data.exp);\n                            resolve();\n                        }\n                        if (e.data.type === \"SOL:FRAME:CLOSE\") {\n                            removeListener();\n                            detatchFrame(loginFrame);\n                            reject(new Error(\"User declined the login request\"));\n                        }\n                    }\n                });\n            });\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            this.eventListeners.disconnect.forEach((listener)=>listener(null));\n            removeChainAddress(this.sessionKey, CHAIN.SOLANA);\n        });\n    }\n    fetchAccounts() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(`${this.server}/api/solana/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.SOLANA, accounts);\n            return accounts;\n        });\n    }\n    handleReadRequests(payload) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return fetch(this.rpc, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(Object.assign({\n                    id: 1,\n                    jsonrpc: \"2.0\"\n                }, payload))\n            }).then((response)=>response.json());\n        });\n    }\n    // solana web3 utility\n    convertToProgramWalletTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.convertToProgramWalletTransaction(transaction);\n            }\n            const message = yield this.request({\n                method: \"convertToProgramWalletTransaction\",\n                params: {\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }\n            });\n            return this.toTransaction(message, []);\n        });\n    }\n    // solana web3 utility\n    signAndSendTransaction(transaction, connection) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.solana;\n            if (existedSDK && existedSDK.isBlocto) {\n                return existedSDK.signAndSendTransaction(transaction);\n            }\n            const extra = {};\n            if (connection) {\n                if (connection.commitment) extra.commitment = connection.commitment;\n                // if the connection object passed-in has different rpc endpoint, reconnect to it\n                // eslint-disable-next-line no-underscore-dangle\n                const rpc = connection ? connection._rpcEndpoint : null;\n                if (rpc && rpc !== this.rpc) {\n                    this.rpc = rpc;\n                    this.disconnect();\n                    yield this.connect();\n                }\n            }\n            return this.request({\n                method: \"signAndSendTransaction\",\n                params: Object.assign({\n                    signatures: yield this.collectSignatures(transaction),\n                    message: transaction.serializeMessage().toString(\"hex\")\n                }, extra)\n            });\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    toTransaction(raw, signatures) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const message = Solana.Message.from(Buffer.from(raw, \"hex\"));\n            const transaction = new Solana.Transaction();\n            transaction.recentBlockhash = message.recentBlockhash;\n            if (message.header.numRequiredSignatures > 0) {\n                transaction.feePayer = message.accountKeys[0];\n            }\n            signatures.forEach((signature, index)=>{\n                const sigPubkeyPair = {\n                    signature: signature === Solana.PublicKey.default.toBase58() ? null : bs58$1.decode(signature),\n                    publicKey: message.accountKeys[index]\n                };\n                transaction.signatures.push(sigPubkeyPair);\n            });\n            message.instructions.forEach((instruction)=>{\n                const keys = instruction.accounts.map((account)=>{\n                    const pubkey = message.accountKeys[account];\n                    return {\n                        pubkey,\n                        isSigner: account < message.header.numRequiredSignatures,\n                        isWritable: message.isAccountWritable(account)\n                    };\n                });\n                transaction.instructions.push(new Solana.TransactionInstruction({\n                    keys,\n                    programId: message.accountKeys[instruction.programIdIndex],\n                    data: bs58$1.decode(instruction.data)\n                }));\n            });\n            return transaction;\n        });\n    }\n    // solana web3 utility\n    // eslint-disable-next-line class-methods-use-this\n    collectSignatures(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return transaction.signatures.reduce((acc, cur)=>{\n                if (cur.signature) {\n                    acc[cur.publicKey.toBase58()] = cur.signature.toString(\"hex\");\n                }\n                return acc;\n            }, {});\n        });\n    }\n    handleConvertTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            return fetch(`${this.server}/api/solana/convertToWalletTx`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n        });\n    }\n    handleSignAndSendTransaction(payload) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { authorizationId } = yield fetch(`${this.server}/api/solana/authz`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(payload.params)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/solana/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"SOL:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve(e.data.txHash);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n}\nconst checkMessagePayloadFormat = (payload)=>{\n    var _a, _b;\n    const formattedPayload = Object.assign({}, payload);\n    const { message, nonce, address, application, chainId } = payload;\n    if (typeof message !== \"string\") {\n        formattedPayload.message = (_a = String(message)) !== null && _a !== void 0 ? _a : \"\";\n    }\n    if (typeof nonce !== \"string\") {\n        formattedPayload.nonce = (_b = String(nonce)) !== null && _b !== void 0 ? _b : \"\";\n    }\n    if (address && typeof address !== \"boolean\") {\n        formattedPayload.address = !!address;\n    }\n    if (application && typeof application !== \"boolean\") {\n        formattedPayload.application = !!application;\n    }\n    if (chainId && typeof chainId !== \"boolean\") {\n        formattedPayload.chainId = !!chainId;\n    }\n    return formattedPayload;\n};\nclass AptosProvider extends BloctoProvider {\n    constructor({ chainId, server, appId }){\n        super();\n        this.publicKey = [];\n        this.authKey = \"\";\n        invariant(chainId, \"'chainId' is required\");\n        invariant(appId, \"It is necessary to interact with Blocto wallet via your app id. Please visit https://developers.blocto.app for more details.\");\n        this.chainId = chainId;\n        this.networkName = APT_CHAIN_ID_NAME_MAPPING[chainId];\n        this.api = APT_CHAIN_ID_RPC_MAPPING[chainId];\n        this.sessionKey = APT_SESSION_KEY_MAPPING[chainId];\n        const defaultServer = APT_CHAIN_ID_SERVER_MAPPING[chainId];\n        this.appId = appId || DEFAULT_APP_ID;\n        this.server = server || defaultServer || \"\";\n    }\n    get publicAccount() {\n        var _a;\n        return {\n            address: ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a[0]) || null,\n            publicKey: this.publicKey.length ? this.publicKey : null,\n            // @todo: provide authkey\n            authKey: null,\n            minKeysRequired: 2\n        };\n    }\n    network() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return {\n                name: this.networkName,\n                api: this.api,\n                chainId: this.chainId.toString()\n            };\n        });\n    }\n    isConnected() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return !!((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code);\n        });\n    }\n    signTransaction(transaction) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signTransaction(transaction);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            throw new Error(\"signTransaction method not supported.\");\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                yield existedSDK.disconnect();\n                return;\n            }\n            removeChainAddress(this.sessionKey, CHAIN.APTOS);\n        });\n    }\n    signAndSubmitTransaction(transaction, txOptions = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return existedSDK.signAndSubmitTransaction(transaction, txOptions);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { authorizationId } = yield fetch(`${this.server}/api/aptos/authz`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(Object.assign(Object.assign({}, transaction), txOptions))\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const authzFrame = createFrame(`${this.server}/${this.appId}/aptos/authz/${authorizationId}`);\n            attachFrame(authzFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            resolve({\n                                hash: e.data.txHash\n                            });\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(authzFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    signMessage(payload) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            const formattedPayload = checkMessagePayloadFormat(payload);\n            if (existedSDK) {\n                return existedSDK.signMessage(formattedPayload);\n            }\n            const hasConnected = yield this.isConnected();\n            if (!hasConnected) {\n                yield this.connect();\n            }\n            if (!((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length)) {\n                throw new Error(\"Fail to get account\");\n            }\n            if (true) {\n                throw new Error(\"Currently only supported in browser\");\n            }\n            const sessionId = ((_b = getAccountStorage(this.sessionKey)) === null || _b === void 0 ? void 0 : _b.code) || \"\";\n            const { signatureId } = yield fetch(`${this.server}/api/aptos/user-signature`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                },\n                body: JSON.stringify(formattedPayload)\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            const url = `${this.server}/${this.appId}/aptos/user-signature/${signatureId}`;\n            const signFrame = createFrame(url);\n            attachFrame(signFrame);\n            return new Promise((resolve, reject)=>addSelfRemovableHandler(\"message\", (event, removeEventListener)=>{\n                    const e = event;\n                    if (e.origin === this.server && e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                        if (e.data.status === \"APPROVED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            resolve(e.data);\n                        }\n                        if (e.data.status === \"DECLINED\") {\n                            removeEventListener();\n                            detatchFrame(signFrame);\n                            if (e.data.errorCode === \"incorrect_session_id\") {\n                                this.disconnect();\n                            }\n                            reject(new Error(e.data.errorMessage));\n                        }\n                    }\n                }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const existedSDK = window.bloctoAptos;\n            if (existedSDK) {\n                return new Promise((resolve, reject)=>// add a small delay to make sure the network has been switched\n                    setTimeout(()=>existedSDK.connect().then(resolve).catch(reject), 10));\n            }\n            return new Promise((resolve, reject)=>{\n                var _a, _b;\n                if (true) {\n                    return reject(\"Currently only supported in browser\");\n                }\n                if ((_a = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _a === void 0 ? void 0 : _a.length) {\n                    return resolve({\n                        address: ((_b = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _b === void 0 ? void 0 : _b[0]) || null,\n                        publicKey: this.publicKey,\n                        authKey: null,\n                        minKeysRequired: 2\n                    });\n                }\n                const location = encodeURIComponent(window.location.origin);\n                const loginFrame = createFrame(`${this.server}/${this.appId}/aptos/authn?l6n=${location}&v=${SDK_VERSION}}`);\n                attachFrame(loginFrame);\n                addSelfRemovableHandler(\"message\", (event, removeListener)=>__awaiter(this, void 0, void 0, function*() {\n                        var _c, _d, _e;\n                        const e = event;\n                        if (e.origin === this.server) {\n                            if (e.data.type === \"APTOS:FRAME:RESPONSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                setAccountStorage(this.sessionKey, {\n                                    code: e.data.code,\n                                    connected: true,\n                                    accounts: {\n                                        [CHAIN.APTOS]: [\n                                            e.data.addr\n                                        ]\n                                    }\n                                }, e.data.exp);\n                                if ((_c = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _c === void 0 ? void 0 : _c.length) {\n                                    try {\n                                        const { public_keys: publicKeys } = yield fetch(`${this.server}/blocto/aptos/accounts/${(_d = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _d === void 0 ? void 0 : _d[0]}`).then((response)=>response.json());\n                                        this.publicKey = publicKeys || [];\n                                        resolve({\n                                            address: ((_e = getChainAddress(this.sessionKey, CHAIN.APTOS)) === null || _e === void 0 ? void 0 : _e[0]) || \"\",\n                                            publicKey: this.publicKey,\n                                            authKey: null,\n                                            minKeysRequired: 2\n                                        });\n                                    } catch (err) {\n                                        return reject(e);\n                                    }\n                                } else {\n                                    // @todo: better error\n                                    return reject();\n                                }\n                            }\n                            if (e.data.type === \"APTOS:FRAME:CLOSE\") {\n                                removeListener();\n                                detatchFrame(loginFrame);\n                                reject(new Error(\"User declined the login request\"));\n                            }\n                        }\n                    }));\n            });\n        });\n    }\n    fetchAddress() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sessionId = ((_a = getAccountStorage(this.sessionKey)) === null || _a === void 0 ? void 0 : _a.code) || \"\";\n            const { accounts } = yield fetch(`${this.server}/api/aptos/accounts`, {\n                headers: {\n                    // We already check the existence in the constructor\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    \"Blocto-Application-Identifier\": this.appId,\n                    \"Blocto-Session-Identifier\": sessionId\n                }\n            }).then((response)=>responseSessionGuard(response, this.sessionKey));\n            setChainAddress(this.sessionKey, CHAIN.APTOS, accounts);\n            return (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || \"\";\n        });\n    }\n}\nclass BloctoSDK {\n    constructor({ appId, ethereum, solana, aptos }){\n        if (ethereum) {\n            this.ethereum = new EthereumProvider(Object.assign(Object.assign({}, ethereum), {\n                appId\n            }));\n        }\n        if (solana) {\n            this.solana = new SolanaProvider(Object.assign(Object.assign({}, solana), {\n                appId\n            }));\n        }\n        if (aptos) {\n            this.aptos = new AptosProvider(Object.assign(Object.assign({}, aptos), {\n                appId\n            }));\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2N0by9zZGsvZGlzdC9ibG9jdG8tc2RrLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsNkNBQTZDLEdBQzdDOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSxvREFBb0Q7Ozs7K0JBZ2tKOUJBOzs7ZUFBYkM7OztBQTdqSlQsU0FBU0MsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsU0FBU08sdUJBQXVCQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQ3BELElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFH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U0FBUztvQkFDTCxvREFBb0Q7b0JBQ3BELG9FQUFvRTtvQkFDcEUsaUNBQWlDLElBQUksQ0FBQ3RqQixLQUFLO29CQUMzQyw2QkFBNkJxakI7Z0JBQ2pDO1lBQ0osR0FBR2xwQixJQUFJLENBQUMsQ0FBQytILFdBQWFELHFCQUFxQkMsVUFBVSxJQUFJLENBQUMyZCxVQUFVO1lBQ3BFL2hCLGdCQUFnQixJQUFJLENBQUMraEIsVUFBVSxFQUFFcmtCLE1BQU15dkIsS0FBSyxFQUFFenRCO1lBQzlDLE9BQU8sQ0FBQ0EsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEtBQUs7UUFDaEY7SUFDSjtBQUNKO0FBRUEsTUFBTXZFO0lBQ0Z5QyxZQUFZLEVBQUVzRSxLQUFLLEVBQUUraEIsUUFBUSxFQUFFNEYsTUFBTSxFQUFFb0UsS0FBSyxFQUFFLENBQUU7UUFDNUMsSUFBSWhLLFVBQVU7WUFDVixJQUFJLENBQUNBLFFBQVEsR0FBRyxJQUFJeEMsaUJBQWlCOWhCLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR3FrQixXQUFXO2dCQUFFL2hCO1lBQU07UUFDNUY7UUFDQSxJQUFJMm5CLFFBQVE7WUFDUixJQUFJLENBQUNBLE1BQU0sR0FBRyxJQUFJSCxlQUFlL3BCLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2lxQixTQUFTO2dCQUFFM25CO1lBQU07UUFDdEY7UUFDQSxJQUFJK3JCLE9BQU87WUFDUCxJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJcEIsY0FBY2x0QixPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdxdUIsUUFBUTtnQkFBRS9yQjtZQUFNO1FBQ25GO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AYmxvY3RvL3Nkay9kaXN0L2Jsb2N0by1zZGsubW9kdWxlLmpzP2M1NzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVmVyc2lvbjogMC41LjUgLSBBdWd1c3QgMTQsIDIwMjMgMTA6MjM6NTIgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLy8gaW5zdGVhZCBpbnZhcmlhbnQgZnJvbSBwYWNrYWdlLCBzaW5jZSBhbGwgZXJyb3Igd2lsbCB0aHJvdyBvbiBwcm9kdWN0aW9uXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KTtcbiAgICB9XG59XG5cbi8vIGxvY2FsIHN0b3JhZ2UgdmVyc2lvbiBuYW1pbmcgcnVsZTogW21pbGVzdG9uZV0uW3BhdGNoXVxudmFyIEtFWV9TRVNTSU9OO1xuKGZ1bmN0aW9uIChLRVlfU0VTU0lPTikge1xuICAgIEtFWV9TRVNTSU9OW1wicHJvZFwiXSA9IFwiQkxPQ1RPX1NES1wiO1xuICAgIEtFWV9TRVNTSU9OW1wiZGV2XCJdID0gXCJCTE9DVE9fU0RLX0RFVlwiO1xuICAgIEtFWV9TRVNTSU9OW1wic3RhZ2luZ1wiXSA9IFwiQkxPQ1RPX1NES19TVEFHSU5HXCI7XG59KShLRVlfU0VTU0lPTiB8fCAoS0VZX1NFU1NJT04gPSB7fSkpO1xudmFyIENIQUlOO1xuKGZ1bmN0aW9uIChDSEFJTikge1xuICAgIENIQUlOW1wiRVRIRVJFVU1cIl0gPSBcImV0aGVyZXVtXCI7XG4gICAgQ0hBSU5bXCJTT0xBTkFcIl0gPSBcInNvbGFuYVwiO1xuICAgIENIQUlOW1wiQVBUT1NcIl0gPSBcImFwdG9zXCI7XG59KShDSEFJTiB8fCAoQ0hBSU4gPSB7fSkpO1xuXG5jbGFzcyBNZW1vcnlTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0ge307XG4gICAgfVxuICAgIGdldEl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzW2tleV0gfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5XTtcbiAgICB9XG59XG5jb25zdCBtZW1vcnlTdG9yYWdlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubWVtb3J5U3RvcmFnZSA6IG5ldyBNZW1vcnlTdG9yYWdlKCk7XG5cbmNvbnN0IGlzU3VwcG9ydGVkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdsb2NhbF9zdG9yYWdlX3N1cHBvcnRlZCcsICcxJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdsb2NhbF9zdG9yYWdlX3N1cHBvcnRlZCcpO1xuICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgnbG9jYWxfc3RvcmFnZV9zdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gJzEnO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5jb25zdCBzdG9yYWdlID0gaXNTdXBwb3J0ZWQoKSA/IHdpbmRvdy5zZXNzaW9uU3RvcmFnZSA6IG1lbW9yeVN0b3JhZ2U7XG5jb25zdCBnZXRJdGVtID0gKGtleSwgZGVmYXVsdFZhbHVlID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiBKU09OLnBhcnNlKHZhbHVlKSkgfHwgZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBjYXRjaCAoU3ludGF4RXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59O1xuY29uc3Qgc2V0SXRlbSA9IChrZXksIHZhbHVlKSA9PiBzdG9yYWdlLnNldEl0ZW0oa2V5LCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuY29uc3QgcmVtb3ZlSXRlbSA9IChrZXkpID0+IHtcbiAgICBzZXRJdGVtKGtleSwgJycpOyAvLyBEdWUgdG8gc29tZSB2ZXJzaW9ucyBvZiBicm93c2VyIGJ1ZyBjYW4ndCByZW1vdmVJdGVtIGNvcnJlY3RseS5cbiAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbn07XG4vKipcbiAqIEBwYXJhbSB7a2V5cy5LRVlfU0VTU0lPTn0ga2V5IC0ga2V5IHRvIHJldHJpZXZlIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7UHJvdmlkZXJTZXNzaW9uIHwgbnVsbH0gUHJvdmlkZXJTZXNzaW9uIHwgbnVsbFxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgUHJvdmlkZXJTZXNzaW9uIGZyb20gc3RvcmFnZS5cbiAqIElmIHRoZSBkYXRhIGlzIGV4cGlyZWQsIHdpbGwgcmVtb3ZlIHRoZSBkYXRhIGFuZCByZXR1cm4gbnVsbFxuICovXG5jb25zdCBnZXRBY2NvdW50U3RvcmFnZSA9IChrZXkpID0+IHtcbiAgICBjb25zdCByYXdBY2NvdW50U3RvcmFnZSA9IGdldEl0ZW0oa2V5LCBudWxsKTtcbiAgICBpZiAoIXJhd0FjY291bnRTdG9yYWdlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBjb21wYXJlIHRoZSBleHBpcnkgdGltZSBvZiB0aGUgaXRlbSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiByYXdBY2NvdW50U3RvcmFnZS5leHBpcnkgfHxcbiAgICAgICAgcmF3QWNjb3VudFN0b3JhZ2UudiAhPT0gU0RLX1ZFUlNJT04pIHtcbiAgICAgICAgcmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0FjY291bnRTdG9yYWdlID09PSBudWxsIHx8IHJhd0FjY291bnRTdG9yYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdBY2NvdW50U3RvcmFnZS5kYXRhO1xufTtcbi8qKlxuICBAcGFyYW0ge2tleXMuS0VZX1NFU1NJT059IGtleSAtIGtleSB0byBzdG9yZSB0aGUgZGF0YVxuICBAcGFyYW0ge1Byb3ZpZGVyU2Vzc2lvbn0gZGF0YSAtIE9ubHkgdGhlIHBhcnQgb2YgUHJvdmlkZXJTZXNzaW9uIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICB7XG4gICAgY29ubmVjdGVkPzogYm9vbGVhbjtcbiAgICBjb2RlPzogc3RyaW5nIHwgbnVsbDtcbiAgICBhY2NvdW50czogUmVjb3JkPHN0cmluZywgc3RyaW5nW10gfCB1bmRlZmluZWQ+O1xuICB9XG4gIEBwYXJhbSB7bnVtYmVyfSBleHBpcnkgLSBleHBpcnkgdGltZSBvZiB0aGUgZGF0YVxuKi9cbmNvbnN0IHNldEFjY291bnRTdG9yYWdlID0gKGtleSwgZGF0YSwgZXhwaXJ5KSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgcmF3QWNjb3VudFN0b3JhZ2UgPSBnZXRJdGVtKGtleSk7XG4gICAgY29uc3QgbmV3QWNjb3VudFN0b3JhZ2UgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGNvZGU6IChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY29kZSkgfHwgKChfYSA9IHJhd0FjY291bnRTdG9yYWdlID09PSBudWxsIHx8IHJhd0FjY291bnRTdG9yYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdBY2NvdW50U3RvcmFnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSksXG4gICAgICAgICAgICBjb25uZWN0ZWQ6ICEhKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY29kZSkgfHwgKChfYiA9IHJhd0FjY291bnRTdG9yYWdlID09PSBudWxsIHx8IHJhd0FjY291bnRTdG9yYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByYXdBY2NvdW50U3RvcmFnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkpLFxuICAgICAgICAgICAgYWNjb3VudHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9jID0gcmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2NvdW50cyksIGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5hY2NvdW50cyksXG4gICAgICAgIH0sXG4gICAgICAgIGV4cGlyeTogZXhwaXJ5IHx8XG4gICAgICAgICAgICAocmF3QWNjb3VudFN0b3JhZ2UgPT09IG51bGwgfHwgcmF3QWNjb3VudFN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0FjY291bnRTdG9yYWdlLmV4cGlyeSkgfHxcbiAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgTE9HSU5fUEVSU0lTVElOR19USU1FLFxuICAgICAgICB2OiBTREtfVkVSU0lPTixcbiAgICB9O1xuICAgIHNldEl0ZW0oa2V5LCBuZXdBY2NvdW50U3RvcmFnZSk7XG4gICAgcmV0dXJuO1xufTtcbmNvbnN0IGdldENoYWluQWRkcmVzcyA9IChrZXksIGNoYWluKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoISgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZShrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkpIHtcbiAgICAgICAgcmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICgoX2IgPSBnZXRBY2NvdW50U3RvcmFnZShrZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjb3VudHNbY2hhaW5dKSB8fCBudWxsO1xufTtcbmNvbnN0IHNldENoYWluQWRkcmVzcyA9IChrZXksIGNoYWluLCBhY2NvdW50KSA9PiB7XG4gICAgc2V0QWNjb3VudFN0b3JhZ2Uoa2V5LCB7IGFjY291bnRzOiB7IFtjaGFpbl06IGFjY291bnQgfSB9KTtcbiAgICByZXR1cm47XG59O1xuY29uc3QgcmVtb3ZlQ2hhaW5BZGRyZXNzID0gKGtleSwgY2hhaW4pID0+IHtcbiAgICBzZXRBY2NvdW50U3RvcmFnZShrZXksIHsgYWNjb3VudHM6IHsgW2NoYWluXTogdW5kZWZpbmVkIH0gfSk7XG4gICAgcmV0dXJuO1xufTtcblxuLyogZXRoIHNlcmllcyBjb25zdGFudHMgYmVnaW4gKi9cbmNvbnN0IEVUSF9SUENfTElTVCA9IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBsaXN0IG9mIHB1YmxpYyBSUEMgZW5kcG9pbnRzIHRoYXQgd2Uga25vd24gdG8gYmUgd29ya2luZ1xuICAgIC8vIFVzZWQgdG8gaGVscCBkZXZlbG9wZXJzIGRpZCBub3Qgc2V0IHVwIHRoZWlyIG93biBSUEMgZW5kcG9pbnRzXG4gICAgLy8gQlNDIG1haW5uZXRcbiAgICA1NjogJ2h0dHBzOi8vYnNjLWRhdGFzZWVkMS5iaW5hbmNlLm9yZycsXG4gICAgLy8gQlNDIHRlc3RuZXRcbiAgICA5NzogJ2h0dHBzOi8vZGF0YS1zZWVkLXByZWJzYy0xLXMxLmJpbmFuY2Uub3JnOjg1NDUnLFxuICAgIC8vIFBvbHlnb24gTWFpbm5ldFxuICAgIDEzNzogJ2h0dHBzOi8vcnBjLW1haW5uZXQubWF0aWN2aWdpbC5jb20vJyxcbiAgICAvLyBQb2x5Z29uIFRlc3RuZXRcbiAgICA4MDAwMTogJ2h0dHBzOi8vcnBjLW11bWJhaS5tYXRpYy50b2RheS8nLFxuICAgIC8vIEF2YWxhbmNoZSBNYWlubmV0XG4gICAgNDMxMTQ6ICdodHRwczovL2FwaS5hdmF4Lm5ldHdvcmsvZXh0L2JjL0MvcnBjJyxcbiAgICAvLyBBdmFsYW5jaGUgRnVqaSBUZXN0bmV0XG4gICAgNDMxMTM6ICdodHRwczovL2FwaS5hdmF4LXRlc3QubmV0d29yay9leHQvYmMvQy9ycGMnLFxuICAgIC8vIEFyYml0cnVtIE1haW5uZXRcbiAgICA0MjE2MTogJ2h0dHBzOi8vYXJiMS5hcmJpdHJ1bS5pby9ycGMnLFxuICAgIC8vIEFyYml0cnVtIFRlc3RuZXRcbiAgICA0MjE2MTM6ICdodHRwczovL2VuZHBvaW50cy5vbW5pYXRlY2guaW8vdjEvYXJiaXRydW0vZ29lcmxpL3B1YmxpYycsXG4gICAgLy8gT3B0aW1pc20gTWFpbm5ldFxuICAgIDEwOiAnaHR0cHM6Ly9tYWlubmV0Lm9wdGltaXNtLmlvJyxcbiAgICAvLyBPcHRpbWlzbSBHb2VybGkgVGVzdG5ldFxuICAgIDQyMDogJ2h0dHBzOi8vZ29lcmxpLm9wdGltaXNtLmlvJyxcbn07XG5jb25zdCBFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElORyA9IHtcbiAgICBwcm9kOiAnaHR0cHM6Ly93YWxsZXQtdjIuYmxvY3RvLmFwcCcsXG4gICAgc3RhZ2luZzogJ2h0dHBzOi8vd2FsbGV0LXYyLXN0YWdpbmcuYmxvY3RvLmFwcCcsXG4gICAgZGV2OiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxufTtcbmNvbnN0IEVUSF9TRVNTSU9OX0tFWV9NQVBQSU5HID0ge1xuICAgIHByb2Q6IEtFWV9TRVNTSU9OLnByb2QsXG4gICAgc3RhZ2luZzogS0VZX1NFU1NJT04uc3RhZ2luZyxcbiAgICBkZXY6IEtFWV9TRVNTSU9OLmRldixcbn07XG4vKiBldGggc2VyaWVzIGNvbnN0YW50cyBlbmQgKi9cbi8qIHNvbCBjb25zdGFudHMgYmVnaW4gKi9cbmNvbnN0IFNPTF9ORVQgPSB7XG4gICAgTWFpbm5ldEJldGE6ICdtYWlubmV0LWJldGEnLFxuICAgIFRlc3RuZXQ6ICd0ZXN0bmV0JyxcbiAgICBEZXZuZXQ6ICdkZXZuZXQnLFxufTtcbmNvbnN0IFNPTF9ORVRfU0VSVkVSX01BUFBJTkcgPSB7XG4gICAgW1NPTF9ORVQuTWFpbm5ldEJldGFdOiAnaHR0cHM6Ly93YWxsZXQtdjIuYmxvY3RvLmFwcCcsXG4gICAgW1NPTF9ORVQuRGV2bmV0XTogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbiAgICBbU09MX05FVC5UZXN0bmV0XTogJ2h0dHBzOi8vd2FsbGV0LXYyLWRldi5ibG9jdG8uYXBwJyxcbn07XG5jb25zdCBTT0xfU0VTU0lPTl9LRVlfTUFQUElORyA9IHtcbiAgICBbU09MX05FVC5NYWlubmV0QmV0YV06IEtFWV9TRVNTSU9OLnByb2QsXG4gICAgW1NPTF9ORVQuRGV2bmV0XTogS0VZX1NFU1NJT04uZGV2LFxuICAgIFtTT0xfTkVULlRlc3RuZXRdOiBLRVlfU0VTU0lPTi5kZXYsXG59O1xuLyogc29sIGNvbnN0YW50cyBlbmQgKi9cbi8qIGFwdG9zIGNvbnN0YW50cyBiZWdpbiAqL1xuY29uc3QgQVBUX1NFU1NJT05fS0VZX01BUFBJTkcgPSB7XG4gICAgMTogS0VZX1NFU1NJT04ucHJvZCxcbiAgICAyOiBLRVlfU0VTU0lPTi5kZXYsXG4gICAgMzogS0VZX1NFU1NJT04uZGV2LFxuICAgIDQ6IEtFWV9TRVNTSU9OLmRldixcbiAgICA1OiBLRVlfU0VTU0lPTi5zdGFnaW5nLFxufTtcbmNvbnN0IEFQVF9DSEFJTl9JRF9TRVJWRVJfTUFQUElORyA9IHtcbiAgICAvLyBNQUlOTkVUXG4gICAgMTogJ2h0dHBzOi8vd2FsbGV0LXYyLmJsb2N0by5hcHAnLFxuICAgIC8vIFRFU1RORVRcbiAgICAyOiAnaHR0cHM6Ly93YWxsZXQtdjItZGV2LmJsb2N0by5hcHAnLFxuICAgIC8vIERFVk5FVFxuICAgIDM6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gVEVTVElOR1xuICAgIDQ6ICdodHRwczovL3dhbGxldC12Mi1kZXYuYmxvY3RvLmFwcCcsXG4gICAgLy8gUFJFTUFJTk5FVFxuICAgIDU6ICdodHRwczovL3dhbGxldC12Mi1zdGFnaW5nLmJsb2N0by5hcHAnLFxufTtcbnZhciBXYWxsZXRBZGFwdGVyTmV0d29yaztcbihmdW5jdGlvbiAoV2FsbGV0QWRhcHRlck5ldHdvcmspIHtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIk1haW5uZXRcIl0gPSBcIm1haW5uZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RuZXRcIl0gPSBcInRlc3RuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIkRldm5ldFwiXSA9IFwiZGV2bmV0XCI7XG4gICAgV2FsbGV0QWRhcHRlck5ldHdvcmtbXCJUZXN0aW5nXCJdID0gXCJ0ZXN0aW5nXCI7XG4gICAgV2FsbGV0QWRhcHRlck5ldHdvcmtbXCJQcmVtYWlubmV0XCJdID0gXCJwcmVtYWlubmV0XCI7XG59KShXYWxsZXRBZGFwdGVyTmV0d29yayB8fCAoV2FsbGV0QWRhcHRlck5ldHdvcmsgPSB7fSkpO1xuY29uc3QgQVBUX0NIQUlOX0lEX05BTUVfTUFQUElORyA9IHtcbiAgICAxOiBXYWxsZXRBZGFwdGVyTmV0d29yay5NYWlubmV0LFxuICAgIDI6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLlRlc3RuZXQsXG4gICAgMzogV2FsbGV0QWRhcHRlck5ldHdvcmsuRGV2bmV0LFxuICAgIDQ6IFdhbGxldEFkYXB0ZXJOZXR3b3JrLlRlc3RpbmcsXG4gICAgNTogV2FsbGV0QWRhcHRlck5ldHdvcmsuUHJlbWFpbm5ldCxcbn07XG5jb25zdCBBUFRfQ0hBSU5fSURfUlBDX01BUFBJTkcgPSB7XG4gICAgMTogJ2h0dHBzOi8vZnVsbG5vZGUubWFpbm5ldC5hcHRvc2xhYnMuY29tL3YxJyxcbiAgICAyOiAnaHR0cHM6Ly9mdWxsbm9kZS50ZXN0bmV0LmFwdG9zbGFicy5jb20vdjEnLFxuICAgIDM6ICdodHRwczovL2Z1bGxub2RlLmRldm5ldC5hcHRvc2xhYnMuY29tL3YxJyxcbiAgICA0OiAnJyxcbiAgICA1OiAnaHR0cHM6Ly9wcmVtYWlubmV0LmFwdG9zZGV2LmNvbS92MScsXG59O1xuLyogYXB0b3MgY29uc3RhbnRzIGVuZCAqL1xuY29uc3QgRUlQMTE5M19FVkVOVFMgPSBbXG4gICAgJ2Nvbm5lY3QnLFxuICAgICdkaXNjb25uZWN0JyxcbiAgICAnbWVzc2FnZScsXG4gICAgJ2NoYWluQ2hhbmdlZCcsXG4gICAgJ2FjY291bnRzQ2hhbmdlZCcsXG5dO1xuLy8gUHJlc2VydmUgbG9naW4gZm9yIDEgZGF5XG5jb25zdCBMT0dJTl9QRVJTSVNUSU5HX1RJTUUgPSA4NjQwMCAqIDEwMDA7XG5jb25zdCBERUZBVUxUX0FQUF9JRCA9ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnO1xuLy8gV2lsbCBpbmplY3QgdGhlIHZlcnNpb24gb2YgdGhlIFNESyBieSByb2xsdXAgdmVyc2lvbkluamVjdG9yIGR1cmluZyBidWlsZCB0aW1lXG5jb25zdCBTREtfVkVSU0lPTiA9ICcwLjUuNSc7XG5cbi8vIFRoZSByb290IGNsYXNzIGZvciBhbGwgcHJvdmlkZXJzXG5jbGFzcyBCbG9jdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXNCbG9jdG8gPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgLy8gYWxpYXMgcmVtb3ZlTGlzdGVuZXJcbiAgICAgICAgdGhpcy5vZmYgPSB0aGlzLnJlbW92ZUxpc3RlbmVyO1xuICAgICAgICAvLyBpbml0IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBFSVAxMTkzX0VWRU5UUy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXBwSWQgPSBERUZBVUxUX0FQUF9JRDtcbiAgICB9XG4gICAgLy8gaW1wbGVtZW50IGJ5IGNoaWxkcmVuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IH0pO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCFFSVAxMTkzX0VWRU5UUy5pbmNsdWRlcyhldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyBAdG9kbzogaW1wbGVtZW50IGl0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgb25jZSgpIHsgfVxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IElGUkFNRV9TVFlMRSA9ICd3aWR0aDoxMDB2dztoZWlnaHQ6MTAwJTtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7ei1pbmRleDoyMTQ3NDgzNjQ2O2JvcmRlcjpub25lO2JveC1zaXppbmc6Ym9yZGVyLWJveDtjb2xvci1zY2hlbWU6bGlnaHQ7aW5zZXQ6MHB4O2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6YXV0bzsnO1xuZnVuY3Rpb24gY3JlYXRlRnJhbWUodXJsKSB7XG4gICAgY29uc3QgZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHVybCk7XG4gICAgZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsIElGUkFNRV9TVFlMRSk7XG4gICAgcmV0dXJuIGZyYW1lO1xufVxuZnVuY3Rpb24gYXR0YWNoRnJhbWUoZnJhbWUpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZyYW1lKTtcbn1cbmZ1bmN0aW9uIGRldGF0Y2hGcmFtZShmcmFtZSkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBmcmFtZSAmJiBmcmFtZS5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZyYW1lKTtcbiAgICB9XG59XG5cbnZhciBhZGRTZWxmUmVtb3ZhYmxlSGFuZGxlciA9IChldmVudFR5cGUsIGhhbmRsZXIsIHRhcmdldCA9IHdpbmRvdykgPT4ge1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBoYW5kbGVyKGUsIHJlbW92ZUV2ZW50TGlzdGVuZXIpO1xuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKTtcbn07XG5cbmZ1bmN0aW9uIHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCBrZXksIGRpc2Nvbm5lY3RIYW5kbGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBkaXNjb25uZWN0SGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCBlID0gbmV3IEVycm9yKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZSkgfHwgJ3Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICAgIGUuZXJyb3JfY29kZSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5lcnJvcl9jb2RlO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0pO1xufVxuXG5jb25zdCBpc0VtYWlsID0gKHZhbHVlKSA9PiAvXFxTK0BcXFMrXFwuXFxTKy8udGVzdCh2YWx1ZSk7XG5jb25zdCBpc1ZhbGlkVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24pID0+ICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09ICdvYmplY3QnICYmIHRyYW5zYWN0aW9uICE9PSBudWxsICYmICdmcm9tJyBpbiB0cmFuc2FjdGlvbik7XG5jb25zdCBpc1ZhbGlkVHJhbnNhY3Rpb25zID0gKHRyYW5zYWN0aW9ucykgPT4gKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSAmJiB0cmFuc2FjdGlvbnMuZXZlcnkodHggPT4gaXNWYWxpZFRyYW5zYWN0aW9uKHR4KSkpO1xuXG5mdW5jdGlvbiBnZXRFdm1TdXBwb3J0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgbmV0d29ya3MgfSA9IHlpZWxkIGZldGNoKCdodHRwczovL2FwaS5ibG9jdG8uYXBwL25ldHdvcmtzL2V2bScpLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICBjb25zdCBldm1TdXBwb3J0TWFwID0gbmV0d29ya3MucmVkdWNlKChhLCB2KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhKSwgeyBbdi5jaGFpbl9pZF06IHYgfSkpLCB7fSk7XG4gICAgICAgIHJldHVybiBldm1TdXBwb3J0TWFwO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgZGlzdCA9IHt9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBfc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG52YXIgY2xhc3NlcyA9IHt9O1xuXG52YXIgZmFzdFNhZmVTdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5zdHJpbmdpZnlbXCJkZWZhdWx0XCJdID0gc3RyaW5naWZ5O1xuc3RyaW5naWZ5LnN0YWJsZSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnk7XG5zdHJpbmdpZnkuc3RhYmxlU3RyaW5naWZ5ID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeTtcbnZhciBMSU1JVF9SRVBMQUNFX05PREUgPSAnWy4uLl0nO1xudmFyIENJUkNVTEFSX1JFUExBQ0VfTk9ERSA9ICdbQ2lyY3VsYXJdJztcbnZhciBhcnIgPSBbXTtcbnZhciByZXBsYWNlclN0YWNrID0gW107XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9O1xufVxuXG4vLyBSZWd1bGFyIHN0cmluZ2lmeVxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gIH1cbiAgZGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpO1xuICB2YXIgcmVzO1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBzZXRSZXBsYWNlKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgayk7XG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudCwgaywge1xuICAgICAgICB2YWx1ZTogcmVwbGFjZVxuICAgICAgfSk7XG4gICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRba10gPSByZXBsYWNlO1xuICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICB9XG59XG5mdW5jdGlvbiBkZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDE7XG4gIHZhciBpO1xuICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdCkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhY2sucHVzaCh2YWwpO1xuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cbn1cblxuLy8gU3RhYmxlLXN0cmluZ2lmeVxuZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICB9XG4gIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgJycsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpIHx8IG9iajtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzdG9yZSB0aGUgb2JqZWN0IGFzIGl0IHdhcy5cbiAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICBkZXB0aCArPSAxO1xuICB2YXIgaTtcbiAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdCkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhY2sucHVzaCh2YWwpO1xuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICB2YXIgdG1wID0ge307XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgICAgICBwYXJlbnRba10gPSB0bXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxufVxuXG4vLyB3cmFwcyByZXBsYWNlciBmdW5jdGlvbiB0byBoYW5kbGUgdmFsdWVzIHdlIGNvdWxkbid0IHJlcGxhY2Vcbi8vIGFuZCBtYXJrIHRoZW0gYXMgcmVwbGFjZWQgdmFsdWVcbmZ1bmN0aW9uIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpIHtcbiAgcmVwbGFjZXIgPSB0eXBlb2YgcmVwbGFjZXIgIT09ICd1bmRlZmluZWQnID8gcmVwbGFjZXIgOiBmdW5jdGlvbiAoaywgdikge1xuICAgIHJldHVybiB2O1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXTtcbiAgICAgICAgaWYgKHBhcnRbMV0gPT09IGtleSAmJiBwYXJ0WzBdID09PSB2YWwpIHtcbiAgICAgICAgICB2YWwgPSBwYXJ0WzJdO1xuICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzZXMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmNsYXNzZXMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gY2xhc3Nlcy5FdGhlcmV1bVJwY0Vycm9yID0gdm9pZCAwO1xudmFyIGZhc3Rfc2FmZV9zdHJpbmdpZnlfMSA9IGZhc3RTYWZlU3RyaW5naWZ5O1xuLyoqXG4gKiBFcnJvciBzdWJjbGFzcyBpbXBsZW1lbnRpbmcgSlNPTiBSUEMgMi4wIGVycm9ycyBhbmQgRXRoZXJldW0gUlBDIGVycm9yc1xuICogcGVyIEVJUC0xNDc0LlxuICogUGVybWl0cyBhbnkgaW50ZWdlciBlcnJvciBjb2RlLlxuICovXG52YXIgRXRoZXJldW1ScGNFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhFdGhlcmV1bVJwY0Vycm9yLCBfRXJyb3IpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEV0aGVyZXVtUnBjRXJyb3IpO1xuICBmdW5jdGlvbiBFdGhlcmV1bVJwY0Vycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV0aGVyZXVtUnBjRXJyb3IpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbmVtcHR5IHN0cmluZy4nKTtcbiAgICB9XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHdpdGggYWxsIHB1YmxpYyBjbGFzcyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEV0aGVyZXVtUnBjRXJyb3IsIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IHtcbiAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5kYXRhID0gdGhpcy5kYXRhO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgc2VyaWFsaXplZC5zdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZXJpYWxpemVkIGVycm9yLCBvbWl0dGluZ1xuICAgICAqIGFueSBjaXJjdWxhciByZWZlcmVuY2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGZhc3Rfc2FmZV9zdHJpbmdpZnlfMVtcImRlZmF1bHRcIl0odGhpcy5zZXJpYWxpemUoKSwgc3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRXRoZXJldW1ScGNFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5jbGFzc2VzLkV0aGVyZXVtUnBjRXJyb3IgPSBFdGhlcmV1bVJwY0Vycm9yO1xuLyoqXG4gKiBFcnJvciBzdWJjbGFzcyBpbXBsZW1lbnRpbmcgRXRoZXJldW0gUHJvdmlkZXIgZXJyb3JzIHBlciBFSVAtMTE5My5cbiAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAxMDAwIDw9IDQ5OTkgXSByYW5nZS5cbiAqL1xudmFyIEV0aGVyZXVtUHJvdmlkZXJFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V0aGVyZXVtUnBjRXJyb3IpIHtcbiAgX2luaGVyaXRzKEV0aGVyZXVtUHJvdmlkZXJFcnJvciwgX0V0aGVyZXVtUnBjRXJyb3IpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihFdGhlcmV1bVByb3ZpZGVyRXJyb3IpO1xuICAvKipcbiAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIFByb3ZpZGVyIEpTT04tUlBDIGVycm9yLlxuICAgKiBgY29kZWAgbXVzdCBiZSBhbiBpbnRlZ2VyIGluIHRoZSAxMDAwIDw9IDQ5OTkgcmFuZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBFdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdGhlcmV1bVByb3ZpZGVyRXJyb3IpO1xuICAgIGlmICghaXNWYWxpZEV0aFByb3ZpZGVyQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAxMDAwIDw9IGNvZGUgPD0gNDk5OScpO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cGVyMi5jYWxsKHRoaXMsIGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXRoZXJldW1Qcm92aWRlckVycm9yKTtcbn0oRXRoZXJldW1ScGNFcnJvcik7XG5jbGFzc2VzLkV0aGVyZXVtUHJvdmlkZXJFcnJvciA9IEV0aGVyZXVtUHJvdmlkZXJFcnJvcjtcbi8vIEludGVybmFsXG5mdW5jdGlvbiBpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoY29kZSkgJiYgY29kZSA+PSAxMDAwICYmIGNvZGUgPD0gNDk5OTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gJ1tDaXJjdWxhcl0nKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciB1dGlscyA9IHt9O1xuXG52YXIgZXJyb3JDb25zdGFudHMgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yQ29uc3RhbnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5lcnJvckNvbnN0YW50cy5lcnJvclZhbHVlcyA9IGVycm9yQ29uc3RhbnRzLmVycm9yQ29kZXMgPSB2b2lkIDA7XG5lcnJvckNvbnN0YW50cy5lcnJvckNvZGVzID0ge1xuICBycGM6IHtcbiAgICBpbnZhbGlkSW5wdXQ6IC0zMjAwMCxcbiAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXG4gICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogLTMyMDAyLFxuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IC0zMjAwMyxcbiAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcbiAgICBsaW1pdEV4Y2VlZGVkOiAtMzIwMDUsXG4gICAgcGFyc2U6IC0zMjcwMCxcbiAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxuICAgIG1ldGhvZE5vdEZvdW5kOiAtMzI2MDEsXG4gICAgaW52YWxpZFBhcmFtczogLTMyNjAyLFxuICAgIGludGVybmFsOiAtMzI2MDNcbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxuICAgIHVuYXV0aG9yaXplZDogNDEwMCxcbiAgICB1bnN1cHBvcnRlZE1ldGhvZDogNDIwMCxcbiAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IDQ5MDFcbiAgfVxufTtcbmVycm9yQ29uc3RhbnRzLmVycm9yVmFsdWVzID0ge1xuICAnLTMyNzAwJzoge1xuICAgIHN0YW5kYXJkOiAnSlNPTiBSUEMgMi4wJyxcbiAgICBtZXNzYWdlOiAnSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC4nXG4gIH0sXG4gICctMzI2MDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIFJlcXVlc3Qgb2JqZWN0LidcbiAgfSxcbiAgJy0zMjYwMSc6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ1RoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QgLyBpcyBub3QgYXZhaWxhYmxlLidcbiAgfSxcbiAgJy0zMjYwMic6IHtcbiAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKS4nXG4gIH0sXG4gICctMzI2MDMnOiB7XG4gICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBKU09OLVJQQyBlcnJvci4nXG4gIH0sXG4gICctMzIwMDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ0ludmFsaWQgaW5wdXQuJ1xuICB9LFxuICAnLTMyMDAxJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdSZXNvdXJjZSBub3QgZm91bmQuJ1xuICB9LFxuICAnLTMyMDAyJzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdSZXNvdXJjZSB1bmF2YWlsYWJsZS4nXG4gIH0sXG4gICctMzIwMDMnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgbWVzc2FnZTogJ1RyYW5zYWN0aW9uIHJlamVjdGVkLidcbiAgfSxcbiAgJy0zMjAwNCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICBtZXNzYWdlOiAnTWV0aG9kIG5vdCBzdXBwb3J0ZWQuJ1xuICB9LFxuICAnLTMyMDA1Jzoge1xuICAgIHN0YW5kYXJkOiAnRUlQLTE0NzQnLFxuICAgIG1lc3NhZ2U6ICdSZXF1ZXN0IGxpbWl0IGV4Y2VlZGVkLidcbiAgfSxcbiAgJzQwMDEnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgbWVzc2FnZTogJ1VzZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3QuJ1xuICB9LFxuICAnNDEwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHJlcXVlc3RlZCBhY2NvdW50IGFuZC9vciBtZXRob2QgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuJ1xuICB9LFxuICAnNDIwMCc6IHtcbiAgICBzdGFuZGFyZDogJ0VJUC0xMTkzJyxcbiAgICBtZXNzYWdlOiAnVGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIEV0aGVyZXVtIHByb3ZpZGVyLidcbiAgfSxcbiAgJzQ5MDAnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgbWVzc2FnZTogJ1RoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLidcbiAgfSxcbiAgJzQ5MDEnOiB7XG4gICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgbWVzc2FnZTogJ1RoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGNoYWluLidcbiAgfVxufTtcblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHMuc2VyaWFsaXplRXJyb3IgPSBleHBvcnRzLmlzVmFsaWRDb2RlID0gZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBleHBvcnRzLkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFID0gdm9pZCAwO1xuICB2YXIgZXJyb3JfY29uc3RhbnRzXzEgPSBlcnJvckNvbnN0YW50cztcbiAgdmFyIGNsYXNzZXNfMSA9IGNsYXNzZXM7XG4gIHZhciBGQUxMQkFDS19FUlJPUl9DT0RFID0gZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWw7XG4gIHZhciBGQUxMQkFDS19NRVNTQUdFID0gJ1Vuc3BlY2lmaWVkIGVycm9yIG1lc3NhZ2UuIFRoaXMgaXMgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQuJztcbiAgdmFyIEZBTExCQUNLX0VSUk9SID0ge1xuICAgIGNvZGU6IEZBTExCQUNLX0VSUk9SX0NPREUsXG4gICAgbWVzc2FnZTogZ2V0TWVzc2FnZUZyb21Db2RlKEZBTExCQUNLX0VSUk9SX0NPREUpXG4gIH07XG4gIGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSAnVW5zcGVjaWZpZWQgc2VydmVyIGVycm9yLic7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtZXNzYWdlIGZvciBhIGdpdmVuIGNvZGUsIG9yIGEgZmFsbGJhY2sgbWVzc2FnZSBpZiB0aGUgY29kZSBoYXNcbiAgICogbm8gY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpIHtcbiAgICB2YXIgZmFsbGJhY2tNZXNzYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBGQUxMQkFDS19NRVNTQUdFO1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB2YXIgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICAgIGlmIChoYXNLZXkoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXMsIGNvZGVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlc1tjb2RlU3RyaW5nXS5tZXNzYWdlO1xuICAgICAgfVxuICAgICAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2tNZXNzYWdlO1xuICB9XG4gIGV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZ2V0TWVzc2FnZUZyb21Db2RlO1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBjb2RlIGlzIHZhbGlkLlxuICAgKiBBIGNvZGUgaXMgb25seSB2YWxpZCBpZiBpdCBoYXMgYSBtZXNzYWdlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNWYWxpZENvZGUoY29kZSkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICBpZiAoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGlzVmFsaWRDb2RlO1xuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gZXJyb3IgdG8gYW4gRXRoZXJldW0gSlNPTiBSUEMtY29tcGF0aWJsZSBlcnJvciBvYmplY3QuXG4gICAqIE1lcmVseSBjb3BpZXMgdGhlIGdpdmVuIGVycm9yJ3MgdmFsdWVzIGlmIGl0IGlzIGFscmVhZHkgY29tcGF0aWJsZS5cbiAgICogSWYgdGhlIGdpdmVuIGVycm9yIGlzIG5vdCBmdWxseSBjb21wYXRpYmxlLCBpdCB3aWxsIGJlIHByZXNlcnZlZCBvbiB0aGVcbiAgICogcmV0dXJuZWQgb2JqZWN0J3MgZGF0YS5vcmlnaW5hbEVycm9yIHByb3BlcnR5LlxuICAgKi9cbiAgZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJGZhbGxiYWNrRXJyb3IgPSBfcmVmLmZhbGxiYWNrRXJyb3IsXG4gICAgICBmYWxsYmFja0Vycm9yID0gX3JlZiRmYWxsYmFja0Vycm9yID09PSB2b2lkIDAgPyBGQUxMQkFDS19FUlJPUiA6IF9yZWYkZmFsbGJhY2tFcnJvcixcbiAgICAgIF9yZWYkc2hvdWxkSW5jbHVkZVN0YSA9IF9yZWYuc2hvdWxkSW5jbHVkZVN0YWNrLFxuICAgICAgc2hvdWxkSW5jbHVkZVN0YWNrID0gX3JlZiRzaG91bGRJbmNsdWRlU3RhID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkc2hvdWxkSW5jbHVkZVN0YTtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghZmFsbGJhY2tFcnJvciB8fCAhTnVtYmVyLmlzSW50ZWdlcihmYWxsYmFja0Vycm9yLmNvZGUpIHx8IHR5cGVvZiBmYWxsYmFja0Vycm9yLm1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBmYWxsYmFjayBlcnJvciB3aXRoIGludGVnZXIgbnVtYmVyIGNvZGUgYW5kIHN0cmluZyBtZXNzYWdlLicpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICB2YXIgc2VyaWFsaXplZCA9IHt9O1xuICAgIGlmIChlcnJvciAmJiBfdHlwZW9mKGVycm9yKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoZXJyb3IpICYmIGhhc0tleShlcnJvciwgJ2NvZGUnKSAmJiBpc1ZhbGlkQ29kZShlcnJvci5jb2RlKSkge1xuICAgICAgdmFyIF9lcnJvciA9IGVycm9yO1xuICAgICAgc2VyaWFsaXplZC5jb2RlID0gX2Vycm9yLmNvZGU7XG4gICAgICBpZiAoX2Vycm9yLm1lc3NhZ2UgJiYgdHlwZW9mIF9lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBfZXJyb3IubWVzc2FnZTtcbiAgICAgICAgaWYgKGhhc0tleShfZXJyb3IsICdkYXRhJykpIHtcbiAgICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSBfZXJyb3IuZGF0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gZ2V0TWVzc2FnZUZyb21Db2RlKHNlcmlhbGl6ZWQuY29kZSk7XG4gICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHtcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBhc3NpZ25PcmlnaW5hbEVycm9yKGVycm9yKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkLmNvZGUgPSBmYWxsYmFja0Vycm9yLmNvZGU7XG4gICAgICB2YXIgbWVzc2FnZSA9IChfYSA9IGVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZTtcbiAgICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gbWVzc2FnZSA6IGZhbGxiYWNrRXJyb3IubWVzc2FnZTtcbiAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHtcbiAgICAgICAgb3JpZ2luYWxFcnJvcjogYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcilcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBzdGFjayA9IChfYiA9IGVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2s7XG4gICAgaWYgKHNob3VsZEluY2x1ZGVTdGFjayAmJiBlcnJvciAmJiBzdGFjayAmJiB0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZXJpYWxpemVkLnN0YWNrID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gIGV4cG9ydHMuc2VyaWFsaXplRXJyb3IgPSBzZXJpYWxpemVFcnJvcjtcbiAgLy8gSW50ZXJuYWxcbiAgZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IC0zMjA5OSAmJiBjb2RlIDw9IC0zMjAwMDtcbiAgfVxuICBmdW5jdGlvbiBhc3NpZ25PcmlnaW5hbEVycm9yKGVycm9yKSB7XG4gICAgaWYgKGVycm9yICYmIF90eXBlb2YoZXJyb3IpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShlcnJvcikpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBmdW5jdGlvbiBoYXNLZXkob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfVxufSkodXRpbHMpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gbnVsbCA9PSBhcnIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IF9pKSB7XG4gICAgdmFyIF9zLFxuICAgICAgX2UsXG4gICAgICBfeCxcbiAgICAgIF9yLFxuICAgICAgX2FyciA9IFtdLFxuICAgICAgX24gPSAhMCxcbiAgICAgIF9kID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfeCA9IChfaSA9IF9pLmNhbGwoYXJyKSkubmV4dCwgMCA9PT0gaSkge1xuICAgICAgICBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjtcbiAgICAgICAgX24gPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShfbiA9IChfcyA9IF94LmNhbGwoX2kpKS5kb25lKSAmJiAoX2Fyci5wdXNoKF9zLnZhbHVlKSwgX2Fyci5sZW5ndGggIT09IGkpOyBfbiA9ICEwKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gITAsIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIG51bGwgIT0gX2lbXCJyZXR1cm5cIl0gJiYgKF9yID0gX2lbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KF9yKSAhPT0gX3IpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2FycjtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxudmFyIGVycm9ycyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5lcnJvcnMuZXRoRXJyb3JzID0gdm9pZCAwO1xudmFyIGNsYXNzZXNfMSA9IGNsYXNzZXM7XG52YXIgdXRpbHNfMSA9IHV0aWxzO1xudmFyIGVycm9yX2NvbnN0YW50c18xID0gZXJyb3JDb25zdGFudHM7XG5lcnJvcnMuZXRoRXJyb3JzID0ge1xuICBycGM6IHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgUGFyc2UgKC0zMjcwMCkgZXJyb3IuXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5wYXJzZSwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFJlcXVlc3QgKC0zMjYwMCkgZXJyb3IuXG4gICAgICovXG4gICAgaW52YWxpZFJlcXVlc3Q6IGZ1bmN0aW9uIGludmFsaWRSZXF1ZXN0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFBhcmFtcyAoLTMyNjAyKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnZhbGlkUGFyYW1zOiBmdW5jdGlvbiBpbnZhbGlkUGFyYW1zKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkUGFyYW1zLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIE1ldGhvZCBOb3QgRm91bmQgKC0zMjYwMSkgZXJyb3IuXG4gICAgICovXG4gICAgbWV0aG9kTm90Rm91bmQ6IGZ1bmN0aW9uIG1ldGhvZE5vdEZvdW5kKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5tZXRob2ROb3RGb3VuZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cbiAgICAgKi9cbiAgICBpbnRlcm5hbDogZnVuY3Rpb24gaW50ZXJuYWwoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLmludGVybmFsLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFNlcnZlciBlcnJvci5cbiAgICAgKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgLTMyMDk5IDw9IC0zMjAwNSBdIHJhbmdlLlxuICAgICAqIENvZGVzIC0zMjAwMCB0aHJvdWdoIC0zMjAwNCBhcmUgcmVzZXJ2ZWQgYnkgRUlQLTE0NzQuXG4gICAgICovXG4gICAgc2VydmVyOiBmdW5jdGlvbiBzZXJ2ZXIob3B0cykge1xuICAgICAgaWYgKCFvcHRzIHx8IF90eXBlb2Yob3B0cykgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGhlcmV1bSBSUEMgU2VydmVyIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gb3B0cy5jb2RlO1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IC0zMjA5OSA8PSBjb2RlIDw9IC0zMjAwNScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihjb2RlLCBvcHRzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBJbnZhbGlkIElucHV0ICgtMzIwMDApIGVycm9yLlxuICAgICAqL1xuICAgIGludmFsaWRJbnB1dDogZnVuY3Rpb24gaW52YWxpZElucHV0KGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnZhbGlkSW5wdXQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgTm90IEZvdW5kICgtMzIwMDEpIGVycm9yLlxuICAgICAqL1xuICAgIHJlc291cmNlTm90Rm91bmQ6IGZ1bmN0aW9uIHJlc291cmNlTm90Rm91bmQoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnJlc291cmNlTm90Rm91bmQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgUmVzb3VyY2UgVW5hdmFpbGFibGUgKC0zMjAwMikgZXJyb3IuXG4gICAgICovXG4gICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogZnVuY3Rpb24gcmVzb3VyY2VVbmF2YWlsYWJsZShhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZSwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cbiAgICAgKi9cbiAgICB0cmFuc2FjdGlvblJlamVjdGVkOiBmdW5jdGlvbiB0cmFuc2FjdGlvblJlamVjdGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy50cmFuc2FjdGlvblJlamVjdGVkLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIE1ldGhvZCBOb3QgU3VwcG9ydGVkICgtMzIwMDQpIGVycm9yLlxuICAgICAqL1xuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogZnVuY3Rpb24gbWV0aG9kTm90U3VwcG9ydGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTGltaXQgRXhjZWVkZWQgKC0zMjAwNSkgZXJyb3IuXG4gICAgICovXG4gICAgbGltaXRFeGNlZWRlZDogZnVuY3Rpb24gbGltaXRFeGNlZWRlZChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMubGltaXRFeGNlZWRlZCwgYXJnKTtcbiAgICB9XG4gIH0sXG4gIHByb3ZpZGVyOiB7XG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVzZXIgUmVqZWN0ZWQgUmVxdWVzdCAoNDAwMSkgZXJyb3IuXG4gICAgICovXG4gICAgdXNlclJlamVjdGVkUmVxdWVzdDogZnVuY3Rpb24gdXNlclJlamVjdGVkUmVxdWVzdChhcmcpIHtcbiAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVbmF1dGhvcml6ZWQgKDQxMDApIGVycm9yLlxuICAgICAqL1xuICAgIHVuYXV0aG9yaXplZDogZnVuY3Rpb24gdW5hdXRob3JpemVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5zdXBwb3J0ZWQgTWV0aG9kICg0MjAwKSBlcnJvci5cbiAgICAgKi9cbiAgICB1bnN1cHBvcnRlZE1ldGhvZDogZnVuY3Rpb24gdW5zdXBwb3J0ZWRNZXRob2QoYXJnKSB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnByb3ZpZGVyLnVuc3VwcG9ydGVkTWV0aG9kLCBhcmcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIE5vdCBDb25uZWN0ZWQgKDQ5MDApIGVycm9yLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZDogZnVuY3Rpb24gZGlzY29ubmVjdGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5kaXNjb25uZWN0ZWQsIGFyZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAgICovXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IGZ1bmN0aW9uIGNoYWluRGlzY29ubmVjdGVkKGFyZykge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cbiAgICAgKi9cbiAgICBjdXN0b206IGZ1bmN0aW9uIGN1c3RvbShvcHRzKSB7XG4gICAgICBpZiAoIW9wdHMgfHwgX3R5cGVvZihvcHRzKSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFByb3ZpZGVyIGN1c3RvbSBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgY29kZSA9IG9wdHMuY29kZSxcbiAgICAgICAgbWVzc2FnZSA9IG9wdHMubWVzc2FnZSxcbiAgICAgICAgZGF0YSA9IG9wdHMuZGF0YTtcbiAgICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSwgZGF0YSk7XG4gICAgfVxuICB9XG59O1xuLy8gSW50ZXJuYWxcbmZ1bmN0aW9uIGdldEV0aEpzb25ScGNFcnJvcihjb2RlLCBhcmcpIHtcbiAgdmFyIF9wYXJzZU9wdHMgPSBwYXJzZU9wdHMoYXJnKSxcbiAgICBfcGFyc2VPcHRzMiA9IF9zbGljZWRUb0FycmF5KF9wYXJzZU9wdHMsIDIpLFxuICAgIG1lc3NhZ2UgPSBfcGFyc2VPcHRzMlswXSxcbiAgICBkYXRhID0gX3BhcnNlT3B0czJbMV07XG4gIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3IoY29kZSwgbWVzc2FnZSB8fCB1dGlsc18xLmdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5mdW5jdGlvbiBnZXRFdGhQcm92aWRlckVycm9yKGNvZGUsIGFyZykge1xuICB2YXIgX3BhcnNlT3B0czMgPSBwYXJzZU9wdHMoYXJnKSxcbiAgICBfcGFyc2VPcHRzNCA9IF9zbGljZWRUb0FycmF5KF9wYXJzZU9wdHMzLCAyKSxcbiAgICBtZXNzYWdlID0gX3BhcnNlT3B0czRbMF0sXG4gICAgZGF0YSA9IF9wYXJzZU9wdHM0WzFdO1xuICByZXR1cm4gbmV3IGNsYXNzZXNfMS5FdGhlcmV1bVByb3ZpZGVyRXJyb3IoY29kZSwgbWVzc2FnZSB8fCB1dGlsc18xLmdldE1lc3NhZ2VGcm9tQ29kZShjb2RlKSwgZGF0YSk7XG59XG5mdW5jdGlvbiBwYXJzZU9wdHMoYXJnKSB7XG4gIGlmIChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBbYXJnXTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBhcmcubWVzc2FnZSxcbiAgICAgICAgZGF0YSA9IGFyZy5kYXRhO1xuICAgICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHN0cmluZyBtZXNzYWdlLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFttZXNzYWdlIHx8IHVuZGVmaW5lZCwgZGF0YV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IGV4cG9ydHMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVJwY0Vycm9yID0gZXhwb3J0cy5ldGhFcnJvcnMgPSBleHBvcnRzLmVycm9yQ29kZXMgPSB2b2lkIDA7XG4gIHZhciBjbGFzc2VzXzEgPSBjbGFzc2VzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcmV1bVJwY0Vycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGNsYXNzZXNfMS5FdGhlcmV1bVJwY0Vycm9yO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUHJvdmlkZXJFcnJvclwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yO1xuICAgIH1cbiAgfSk7XG4gIHZhciB1dGlsc18xID0gdXRpbHM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcmlhbGl6ZUVycm9yXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHV0aWxzXzEuc2VyaWFsaXplRXJyb3I7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TWVzc2FnZUZyb21Db2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlO1xuICAgIH1cbiAgfSk7XG4gIHZhciBlcnJvcnNfMSA9IGVycm9ycztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXRoRXJyb3JzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGVycm9yc18xLmV0aEVycm9ycztcbiAgICB9XG4gIH0pO1xuICB2YXIgZXJyb3JfY29uc3RhbnRzXzEgPSBlcnJvckNvbnN0YW50cztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXJyb3JDb2Rlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzO1xuICAgIH1cbiAgfSk7XG59KShkaXN0KTtcblxudmFyIGdsb2JhbCQxID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pO1xuXG52YXIgbG9va3VwID0gW107XG52YXIgcmV2TG9va3VwID0gW107XG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoO1xuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwO1xuXG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTtcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbjtcblxuICB2YXIgTCA9IDA7XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KTtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXA7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciB0bXA7XG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGg7XG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMzsgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpO1xuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPT0nO1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz0nO1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpO1xuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiByZWFkIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gLTc7XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDA7XG4gIHZhciBkID0gaXNMRSA/IC0xIDogMTtcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZnVuY3Rpb24gd3JpdGUgKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKTtcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKTtcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0cnVlO1xuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5rTWF4TGVuZ3RoKCk7XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICByZXR1cm4gYXJyXG59O1xuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn07XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheTtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59O1xuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpO1xuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKTtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aDsgLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXk7XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDA7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7XG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cbkJ1ZmZlci5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuZnVuY3Rpb24gaW50ZXJuYWxJc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpO1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXJcbn07XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDA7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dO1xuICBiW25dID0gYlttXTtcbiAgYlttXSA9IGk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMik7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7XG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICc7XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDtcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwO1xuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwO1xuICBlbmQgPj4+PSAwO1xuICB0aGlzU3RhcnQgPj4+PSAwO1xuICB0aGlzRW5kID4+Pj0gMDtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcbiAgdmFyIHkgPSBlbmQgLSBzdGFydDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpO1xuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTtcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldO1xuICAgICAgeSA9IHRhcmdldENvcHlbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMDtcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDtcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7XG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkY7IC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDE7XG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDI7XG4gICAgICBhcnJMZW5ndGggLz0gMjtcbiAgICAgIHZhbExlbmd0aCAvPSAyO1xuICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufTtcblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDA7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufTtcblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICB2YXIgcmVzID0gW107XG5cbiAgdmFyIGkgPSBzdGFydDtcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldO1xuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsO1xuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMTtcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJyc7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgc3RhcnQgPSB+fnN0YXJ0O1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW47XG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICB2YXIgbmV3QnVmO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufTtcblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF07XG4gIHZhciBtdWwgPSAxO1xuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGg7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldO1xuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAxXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4O1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgc3ViID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgc3ViID0gMDtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAxXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCk7XG4gIH1cbiAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDA7XG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgaTtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGxlblxufTtcblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NTtcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDtcblxuICBpZiAoIXZhbCkgdmFsID0gMDtcblxuICB2YXIgaTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gaW50ZXJuYWxJc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpO1xuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59O1xuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZztcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTtcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5O1xuICB2YXIgY29kZVBvaW50O1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsbztcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhpID0gYyA+PiA4O1xuICAgIGxvID0gYyAlIDI1NjtcbiAgICBieXRlQXJyYXkucHVzaChsbyk7XG4gICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gdG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuLy8gdGhlIGZvbGxvd2luZyBpcyBmcm9tIGlzLWJ1ZmZlciwgYWxzbyBieSBGZXJvc3MgQWJvdWtoYWRpamVoIGFuZCB3aXRoIHNhbWUgbGlzZW5jZVxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoISFvYmouX2lzQnVmZmVyIHx8IGlzRmFzdEJ1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopKVxufVxuXG5mdW5jdGlvbiBpc0Zhc3RCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Zhc3RCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5jb25zdCBpc0hleFN0cmluZyA9IChoZXgpID0+IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnICYmIC9eMHhbMC05QS1GYS1mXSokLy50ZXN0KGhleCk7XG5jb25zdCB1dGY4VG9IZXggPSAoc3RyKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XG59O1xuXG52YXIgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzLCBfRXRoZXJldW1Qcm92aWRlcl9hZGRUb1N3aXRjaGFibGUsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQ7XG5mdW5jdGlvbiBwYXJzZUNoYWluSWQoY2hhaW5JZCkge1xuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gY2hhaW5JZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhaW5JZC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChjaGFpbklkLCAxMCk7XG59XG5jbGFzcyBFdGhlcmV1bVByb3ZpZGVyIGV4dGVuZHMgQmxvY3RvUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgY2hhaW5JZCwgcnBjLCB3YWxsZXRTZXJ2ZXIsIGFwcElkIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9ICcxJzsgLy8gc2FtZSBhcyBjaGFpbklkIGJ1dCBpbiBkZWNpbWFsXG4gICAgICAgIC8vIHNldHVwIGNoYWluSWRcbiAgICAgICAgaW52YXJpYW50KGNoYWluSWQsIFwiJ2NoYWluSWQnIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKGNoYWluSWQpfWA7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGAweCR7cGFyc2VDaGFpbklkKGNoYWluSWQpLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICAvLyBzZXR1cCBycGNcbiAgICAgICAgdGhpcy5ycGMgPSBycGMgfHwgRVRIX1JQQ19MSVNUW3RoaXMubmV0d29ya1ZlcnNpb25dO1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5ycGMsIFwiJ3JwYycgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIC8vIHNldHVwIGluamVjdGVkV2FsbGV0U2VydmVyXG4gICAgICAgIHRoaXMuaW5qZWN0ZWRXYWxsZXRTZXJ2ZXIgPSB3YWxsZXRTZXJ2ZXI7XG4gICAgICAgIC8vIE5PVEU6IF9ibG9jdG8gaXMgbm90IGZ1bGx5IGluaXRpYWxpemVkIHlldCBhdCB0aGlzIHBvaW50XG4gICAgICAgIC8vIEFueSBmdW5jdGlvbiBzaG91bGQgY2FsbCAjZ2V0QmxvY3RvUHJvcGVydGllcygpIHRvIGdldCB0aGUgZnVsbCBfYmxvY3RvIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5fYmxvY3RvID0ge1xuICAgICAgICAgICAgc2Vzc2lvbktleTogS0VZX1NFU1NJT04ucHJvZCxcbiAgICAgICAgICAgIHdhbGxldFNlcnZlcjogdGhpcy5pbmplY3RlZFdhbGxldFNlcnZlciB8fCAnJyxcbiAgICAgICAgICAgIGJsb2NrY2hhaW5OYW1lOiAnJyxcbiAgICAgICAgICAgIG5ldHdvcmtUeXBlOiAnJyxcbiAgICAgICAgICAgIHN1cHBvcnROZXR3b3JrTGlzdDoge30sXG4gICAgICAgICAgICBzd2l0Y2hhYmxlTmV0d29yazoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZCB8fCBERUZBVUxUX0FQUF9JRDtcbiAgICB9XG4gICAgLy8gREVQUkVDQVRFRCBBUEk6IHNlZSBodHRwczovL2RvY3MubWV0YW1hc2suaW8vZ3VpZGUvZXRoZXJldW0tcHJvdmlkZXIuaHRtbCNldGhlcmV1bS1zZW5kLWRlcHJlY2F0ZWRcbiAgICBzZW5kKG1ldGhvZE9yUGF5bG9hZCwgcGFyYW1zT3JDYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlIHR5cGUgMTogYXJnMSAtIEpTT04tUlBDIHBheWxvYWQsIGFyZzIgLSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAvLyBldGhlcmV1bS5zZW5kKHBheWxvYWQ6IEpzb25ScGNSZXF1ZXN0LCBjYWxsYmFjazogSnNvblJwY0NhbGxiYWNrKTogdm9pZDtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNpZ25hdHVyZSBpcyBleGFjdGx5IGxpa2UgZXRoZXJldW0uc2VuZEFzeW5jKClcbiAgICAgICAgICAgICAgICBjYXNlIHBhcmFtc09yQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKG1ldGhvZE9yUGF5bG9hZCwgcGFyYW1zT3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlIHR5cGUgMjogYXJnMSAtIEpTT04tUlBDIG1ldGhvZCBuYW1lLCBhcmcyIC0gcGFyYW1zIGFycmF5O1xuICAgICAgICAgICAgICAgIC8vIGV0aGVyZXVtLnNlbmQobWV0aG9kOiBzdHJpbmcsIHBhcmFtcz86IEFycmF5PHVua25vd24+KTogUHJvbWlzZTxKc29uUnBjUmVzcG9uc2U+O1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2lnbmF0dXJlIGlzIGxpa2UgYW4gYXN5bmMgZXRoZXJldW0uc2VuZEFzeW5jKCkgd2l0aCBtZXRob2QgYW5kIHBhcmFtcyBhcyBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBhIEpTT04tUlBDIHBheWxvYWQgYW5kIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlb2YgbWV0aG9kT3JQYXlsb2FkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHBhcmFtc09yQ2FsbGJhY2spOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZE9yUGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zT3JDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlIHR5cGUgMzogYXJnMSAtIEpTT04tUlBDIHBheWxvYWQoc2hvdWxkIGJlIHN5bmNocm9ub3VzIG1ldGhvZHMpXG4gICAgICAgICAgICAgICAgLy8gZXRoZXJldW0uc2VuZChwYXlsb2FkOiBKc29uUnBjUmVxdWVzdCk6IHVua25vd247XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaWduYXR1cmUgZW5hYmxlcyB5b3UgdG8gY2FsbCBzb21lIHR5cGUgb2YgUlBDIG1ldGhvZHMgc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRBc3luYyhtZXRob2RPclBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gREVQUkVDQVRFRCBBUEk6IHNlZSBodHRwczovL2RvY3MubWV0YW1hc2suaW8vZ3VpZGUvZXRoZXJldW0tcHJvdmlkZXIuaHRtbCNsZWdhY3ktbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxuICAgIC8vIHdlYjMgdjEueCBCYXRjaFJlcXVlc3Qgc3RpbGwgZGVwZW5kcyBvbiBpdCBzbyB3ZSBuZWVkIHRvIGltcGxlbWVudCBhbnl3YXkgwq9cXF8o44OEKV8vwq9cbiAgICBzZW5kQXN5bmMocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVJlcXVlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHdlYjMgdjEueCBjb25jYXQgYmF0Y2hlZCBKU09OLVJQQyByZXF1ZXN0cyB0byBhbiBhcnJheSwgaGFuZGxlIGl0IGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRyYW5zYWN0aW9ucyBhbmQgc2VuZCBiYXRjaCB3aXRoIGN1c3RvbSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigocmVxdWVzdCkgPT4gcmVxdWVzdC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHJlcXVlc3QpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcmVxdWVzdC5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkQmFzZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hlZFJlcXVlc3RQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnYmxvY3RvX3NlbmRCYXRjaFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogdHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaFJlc3BvbnNlUHJvbWlzZSA9IHRoaXMucmVxdWVzdChiYXRjaGVkUmVxdWVzdFBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHBheWxvYWQubWFwKCh7IG1ldGhvZCwgcGFyYW1zIH0sIGluZGV4KSA9PiBtZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBiYXRjaFJlc3BvbnNlUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZEJhc2UgKyBpbmRleCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZSByZXNwb25zZSB3aGVuIGFsbCByZXF1ZXN0IGFyZSBleGVjdXRlZFxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbFNldHRsZWQocmVxdWVzdHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2VzKSA9PiByZXNvbHZlKHJlc3BvbnNlcy5tYXAoKHJlc3BvbnNlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkQmFzZSArIGluZGV4ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwYXlsb2FkW2luZGV4XS5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXNwb25zZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlLnN0YXR1cyAhPT0gJ2Z1bGZpbGxlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5yZWFzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBheWxvYWQpLCB7IGlkOiBOdW1iZXIocGF5bG9hZC5pZCkgfSkpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBleGVjdXRlIGNhbGxiYWNrIG9yIHJldHVybiBwcm9taXNlLCBkZXBkZW5kcyBvbiBjYWxsYmFjayBhcmcgZ2l2ZW4gb3Igbm90XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiBjYWxsYmFjayhudWxsLCBkYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gY2FsbGJhY2soZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZGluZyB1c2VyT3BlcmF0aW9uIHVzaW5nIEJsb2N0byBTREsuXG4gICAgICogQHBhcmFtIHtJVXNlck9wZXJhdGlvbn0gdXNlck9wIC0gdXNlck9wZXJhdGlvbiBvYmplY3RcbiAgICAgKiBAcmVtYXJrcyBObyBuZWVkIHRvIGluY2x1ZGUgbm9uY2UsIGluaXRDb2RlLCBhbmQgc2lnbmF0dXJlIGFzIHBhcmFtZXRlcnMgd2hlbiB1c2luZyBCbG9jdG9TREsgdG8gc2VuZCB1c2VyT3BlcmF0aW9uLlxuICAgICAqIFRoZXNlIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gdXNlck9wZXJhdGlvbiBoYXNoXG4gICAgICovXG4gICAgc2VuZFVzZXJPcGVyYXRpb24odXNlck9wKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc2VuZFVzZXJPcGVyYXRpb24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3VzZXJPcF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIShwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQubWV0aG9kKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuZXRoZXJldW07XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKChfYiA9IChfYSA9IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF5bG9hZC5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnJlcXVlc3QocGF5bG9hZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwYXJzZUNoYWluSWQoKF9hID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdLmNoYWluSWQpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BhcnNlQ2hhaW5JZCgoX2IgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0uY2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IChfYyA9IHN3aXRjaGFibGVOZXR3b3JrID09PSBudWxsIHx8IHN3aXRjaGFibGVOZXR3b3JrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzd2l0Y2hhYmxlTmV0d29ya1t0aGlzLm5ldHdvcmtWZXJzaW9uXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnJlcXVlc3QocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGJsb2NrY2hhaW5OYW1lLCBzd2l0Y2hhYmxlTmV0d29yaywgc2Vzc2lvbktleSB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gbWV0aG9kIHRoYXQgZG9lc24ndCByZXF1aXJlIHVzZXIgdG8gYmUgY29ubmVjdGVkXG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXRoX2NoYWluSWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ25ldF92ZXJzaW9uJzoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrVmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRTd2l0Y2hhYmxlTmV0d29yaygocGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnBhcmFtcykgfHwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdldGhfY2FsbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCAocmVzcG9uc2UgJiYgIXJlc3BvbnNlLnJlc3VsdCAmJiByZXNwb25zZS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICgoX2MgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuZXJyb3IpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ1JlcXVlc3QgZmFpbGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3dhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluJzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2UgPSAoX2QgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMF0pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jaGFpbklkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoYWluSWQgPSBwYXlsb2FkLnBhcmFtc1swXS5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpcmVjdGx5IHN3aXRjaCBuZXR3b3JrIGlmIHVzZXIgaXMgbm90IGNvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogYWRkIGEgY29uZmlybSBzd2l0Y2ggbmV0d29yayBkaWFsb2dcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBoYXNlZENoYWluSWQgPSBwYXJzZUNoYWluSWQobmV3Q2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN3aXRjaGFibGVOZXR3b3JrW3BoYXNlZENoYWluSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogNDkwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFVucmVjb2duaXplZCBjaGFpbiBJRCBcIiR7bmV3Q2hhaW5JZH1cIi4gVHJ5IGFkZGluZyB0aGUgY2hhaW4gdXNpbmcgd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4gZmlyc3QuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV0d29ya1ZlcnNpb24gPSBgJHtwaGFzZWRDaGFpbklkfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke3BoYXNlZENoYWluSWQudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IHN3aXRjaGFibGVOZXR3b3JrW3BoYXNlZENoYWluSWRdLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNoYWluQ2hhbmdlZC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5jaGFpbklkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNZXRob2QgdGhhdCByZXF1aXJlcyB1c2VyIHRvIGJlIGNvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKCFnZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWwgPSAoX2YgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZbMF07XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycgJiYgaXNFbWFpbChlbWFpbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5lbmFibGUoZW1haWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfcmVxdWVzdEFjY291bnRzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZmV0Y2hBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX2FjY291bnRzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdldENoYWluQWRkcmVzcyhzZXNzaW9uS2V5LCBibG9ja2NoYWluTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX2NvaW5iYXNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gKF9nID0gZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjMnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGVyc29uYWxfc2lnbic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTaWduKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X2Rpc2Nvbm5lY3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2VuZFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2N0b19zZW5kQmF0Y2hUcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNlbmRCYXRjaFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgnTWV0aG9kIE5vdCBTdXBwb3J0ZWQ6ICcgKyBwYXlsb2FkLm1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX3NlbmRVc2VyT3BlcmF0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlU2VuZFVzZXJPcGVyYXRpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2ogPSAoX2ggPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQucGFyYW1zKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRBY2NvdW50ID0gKF9rID0gZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKSkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQ2hhaW5JZCA9IHRoaXMuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoYWluSWQgPSBwYXlsb2FkLnBhcmFtc1swXS5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzd2l0Y2hhYmxlTmV0d29ya1twYXJzZUNoYWluSWQobmV3Q2hhaW5JZCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY3VzdG9tKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogNDkwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFVucmVjb2duaXplZCBjaGFpbiBJRCBcIiR7cGFyc2VDaGFpbklkKHBheWxvYWQucGFyYW1zWzBdLmNoYWluSWQpfVwiLiBUcnkgYWRkaW5nIHRoZSBjaGFpbiB1c2luZyB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbiBmaXJzdC5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGAke3BhcnNlQ2hhaW5JZChuZXdDaGFpbklkKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQobmV3Q2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IHN3aXRjaGFibGVOZXR3b3JrW3RoaXMubmV0d29ya1ZlcnNpb25dLnJwY191cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmVuYWJsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKFtuZXdBY2NvdW50XSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3QWNjb3VudCAhPT0gb2xkQWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjb3VudHNDaGFuZ2VkLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihbbmV3QWNjb3VudF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5jaGFpbkNoYW5nZWQuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHRoaXMuY2hhaW5JZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gYCR7cGFyc2VDaGFpbklkKG9sZENoYWluSWQpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFpbklkID0gYDB4JHtwYXJzZUNoYWluSWQob2xkQ2hhaW5JZCkudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ycGMgPSBzd2l0Y2hhYmxlTmV0d29ya1t0aGlzLm5ldHdvcmtWZXJzaW9uXS5ycGNfdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfZXN0aW1hdGVVc2VyT3BlcmF0aW9uR2FzJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXRoX2dldFVzZXJPcGVyYXRpb25CeUhhc2gnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfZ2V0VXNlck9wZXJhdGlvblJlY2VpcHQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdldGhfc3VwcG9ydGVkRW50cnlQb2ludHMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVCdW5kbGVyKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMuaGFuZGxlUmVhZFJlcXVlc3RzKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgIXJlc3BvbnNlLnJlc3VsdCAmJiByZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ1JlcXVlc3QgZmFpbGVkJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludGVybmFsKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJsb2N0b0FwaSh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIsIGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSAoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2Uoc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSB8fCAnJztcbiAgICAgICAgICAgIGlmICghc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYCR7d2FsbGV0U2VydmVyfS9hcGkvJHtibG9ja2NoYWluTmFtZX0ke3VybH1gLCBPYmplY3QuYXNzaWduKHsgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLUFwcGxpY2F0aW9uLUlkZW50aWZpZXInOiB0aGlzLmFwcElkLFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLVNlc3Npb24tSWRlbnRpZmllcic6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB9IH0sIG9wdGlvbnMpKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHNlc3Npb25LZXksICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCgpKSk7XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5lcnJvcl9jb2RlKSA9PT0gJ3Vuc3VwcG9ydGVkX21ldGhvZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgnTWV0aG9kIE5vdCBTdXBwb3J0ZWQ6ICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLnNlcnZlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAtMzIwMDUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQmxvY3RvIHNlcnZlciBlcnJvcjogJHtlLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNwb25zZUxpc3RlbmVyKGZyYW1lLCBvYmplY3RLZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2FsbGV0U2VydmVyIH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB3YWxsZXRTZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnR5cGUgPT09ICdFVEg6RlJBTUU6UkVTUE9OU0UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuc3RhdHVzID09PSAnQVBQUk9WRUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGFbb2JqZWN0S2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmVycm9yQ29kZSA9PT0gJ2luY29ycmVjdF9zZXNzaW9uX2lkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoZS5kYXRhLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpDTE9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCgnVXNlciBkZWNsaW5lZCB0aGUgcmVxdWVzdCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRJZnJhbWUodXJsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkaXN0LmV0aEVycm9ycy5wcm92aWRlci5jdXN0b20oe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAxMDAxLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQmxvY3RvIFNESyBvbmx5IHdvcmtzIGluIGJyb3dzZXIgZW52aXJvbm1lbnQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIsIGJsb2NrY2hhaW5OYW1lIH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IGNyZWF0ZUZyYW1lKGAke3dhbGxldFNlcnZlcn0vJHt0aGlzLmFwcElkfS8ke2Jsb2NrY2hhaW5OYW1lfSR7dXJsfWApO1xuICAgICAgICAgICAgYXR0YWNoRnJhbWUoZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZWlwLTExMDIgYWxpYXNcbiAgICAvLyBERVBSRUNBVEVEIEFQSTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvYmxvYi9tYXN0ZXIvRUlQUy9laXAtMTEwMi5tZFxuICAgIGVuYWJsZShlbWFpbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRTZXJ2ZXIsIGJsb2NrY2hhaW5OYW1lLCBzZXNzaW9uS2V5IH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LmV0aGVyZXVtO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGVkU0RLLmNoYWluSWQgIT09IHRoaXMuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBleGlzdGVkU0RLLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiB0aGlzLmNoYWluSWQgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBleGlzdGVkU0RLLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBjaGFpbklkOiB0aGlzLmNoYWluSWQgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUsIFtleGlzdGVkU0RLLmFkZHJlc3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IFxuICAgICAgICAgICAgICAgIC8vIGFkZCBhIHNtYWxsIGRlbGF5IHRvIG1ha2Ugc3VyZSB0aGUgbmV0d29yayBoYXMgYmVlbiBzd2l0Y2hlZFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXhpc3RlZFNESy5lbmFibGUoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCksIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdsNm4nLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ3YnLCBTREtfVkVSU0lPTik7XG4gICAgICAgICAgICBjb25zdCBlbWFpbFBhcmFtID0gZW1haWwgJiYgaXNFbWFpbChlbWFpbCkgPyBgLyR7ZW1haWx9YCA6ICcnO1xuICAgICAgICAgICAgY29uc3QgbG9naW5GcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvYXV0aG4ke2VtYWlsUGFyYW19PyR7cGFyYW1zLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVMaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB3YWxsZXRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoeyBjaGFpbklkOiB0aGlzLmNoYWluSWQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjY291bnRTdG9yYWdlKHNlc3Npb25LZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZS5kYXRhLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtibG9ja2NoYWluTmFtZV06IFtlLmRhdGEuYWRkcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZS5kYXRhLmV4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbZS5kYXRhLmFkZHJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0VUSDpGUkFNRTpDTE9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEFjY291bnRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBibG9ja2NoYWluTmFtZSwgc2Vzc2lvbktleSB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC9hY2NvdW50c2ApO1xuICAgICAgICAgICAgc2V0Q2hhaW5BZGRyZXNzKHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lLCBhY2NvdW50cyk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMucnBjLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7IGlkOiAxLCBqc29ucnBjOiAnMi4wJyB9LCBwYXlsb2FkKSksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2lnbih7IG1ldGhvZCwgcGFyYW1zIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2V0aF9zaWduJykge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gaXNIZXhTdHJpbmcocGFyYW1zWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXNbMV0uc2xpY2UoMilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdXRmOFRvSGV4KHBhcmFtc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ3BlcnNvbmFsX3NpZ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBpc0hleFN0cmluZyhwYXJhbXNbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtc1swXS5zbGljZSgyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1dGY4VG9IZXgocGFyYW1zWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoW1xuICAgICAgICAgICAgICAgICAgICAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICAgICAgICAgICAgICAgICAgICAnZXRoX3NpZ25UeXBlZERhdGFfdjMnLFxuICAgICAgICAgICAgICAgICAgICAnZXRoX3NpZ25UeXBlZERhdGFfdjQnLFxuICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gcGFyYW1zWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbWFpbiB9ID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGRvbWFpbi5jaGFpbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYFByb3ZpZGVkIGNoYWluSWQgXCIke2RvbWFpbi5jaGFpbklkfVwiIG11c3QgYmUgYSBudW1iZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VDaGFpbklkKGRvbWFpbi5jaGFpbklkKSAhPT0gcGFyc2VDaGFpbklkKHRoaXMuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBQcm92aWRlZCBjaGFpbklkIFwiJHtkb21haW4uY2hhaW5JZH1cIiBtdXN0IG1hdGNoIHRoZSBhY3RpdmUgY2hhaW5JZCBcIiR7cGFyc2VDaGFpbklkKHRoaXMuY2hhaW5JZCl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfY2hlY2tOZXR3b3JrTWF0Y2hlZCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlSWQgfSA9IHlpZWxkIHRoaXMuYmxvY3RvQXBpKGAvdXNlci1zaWduYXR1cmVgLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5OiBKU09OLnN0cmluZ2lmeSh7IG1ldGhvZCwgbWVzc2FnZSB9KSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25GcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvdXNlci1zaWduYXR1cmUvJHtzaWduYXR1cmVJZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlTGlzdGVuZXIoc2lnbkZyYW1lLCAnc2lnbmF0dXJlJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRUcmFuc2FjdGlvbigoX2EgPSBwYXlsb2FkLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb25JZCB9ID0geWllbGQgdGhpcy5ibG9jdG9BcGkoYC9hdXRoemAsIHsgbWV0aG9kOiAnUE9TVCcsIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQucGFyYW1zKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGh6RnJhbWUgPSB5aWVsZCB0aGlzLnNldElmcmFtZShgL2F1dGh6LyR7YXV0aG9yaXphdGlvbklkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VMaXN0ZW5lcihhdXRoekZyYW1lLCAndHhIYXNoJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTZW5kQmF0Y2hUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBleHRyYWN0UGFyYW1zID0gKHBhcmFtcykgPT4gcGFyYW1zLm1hcCgocGFyYW0pID0+ICdwYXJhbXMnIGluIHBhcmFtXG4gICAgICAgICAgICAgICAgPyBwYXJhbS5wYXJhbXNbMF0gLy8gaGFuZGxlIHBhc3Npbmcgd2ViMy5ldGguc2VuZFRyYW5zYWN0aW9uLnJlcXVlc3QoLi4uKSBhcyBhIHBhcmFtZXRlciB3aXRoIHBhcmFtc1xuICAgICAgICAgICAgICAgIDogcGFyYW0pO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0UGFyYW1zID0gZXh0cmFjdFBhcmFtcyhwYXlsb2FkLnBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBjb3B5UGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCksIHsgcGFyYW1zOiBmb3JtYXRQYXJhbXMgfSk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRUcmFuc2FjdGlvbnMoY29weVBheWxvYWQucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZW5kVHJhbnNhY3Rpb24oY29weVBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU2VuZFVzZXJPcGVyYXRpb24ocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uSWQgfSA9IHlpZWxkIHRoaXMuYmxvY3RvQXBpKGAvdXNlci1vcGVyYXRpb25gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyT1BGcmFtZSA9IHlpZWxkIHRoaXMuc2V0SWZyYW1lKGAvdXNlci1vcGVyYXRpb24vJHthdXRob3JpemF0aW9uSWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25zZUxpc3RlbmVyKHVzZXJPUEZyYW1lLCAndXNlck9wSGFzaCcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQnVuZGxlcihwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9jdG9BcGkoYC9ycGMvYnVuZGxlcmAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKHsgaWQ6IDEsIGpzb25ycGM6ICcyLjAnIH0sIHBheWxvYWQpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5ldGhlcmV1bTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RlZFNESy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNlc3Npb25LZXksIGJsb2NrY2hhaW5OYW1lIH0gPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdGhlcmV1bVByb3ZpZGVyX2luc3RhbmNlcywgXCJtXCIsIF9FdGhlcmV1bVByb3ZpZGVyX2dldEJsb2N0b1Byb3BlcnRpZXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICByZW1vdmVDaGFpbkFkZHJlc3Moc2Vzc2lvbktleSwgYmxvY2tjaGFpbk5hbWUpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5ldmVudExpc3RlbmVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmRpc2Nvbm5lY3RlZCgpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkU3dpdGNoYWJsZU5ldHdvcmsobmV0d29ya0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIHN3aXRjaGFibGUgbGlzdCBpZiB1c2VyIHNldCBuZXR3b3JrTGlzdFxuICAgICAgICAgICAgaWYgKG5ldHdvcmtMaXN0ID09PSBudWxsIHx8IG5ldHdvcmtMaXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXR3b3JrTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9BZGQgPSBuZXR3b3JrTGlzdC5tYXAoKHsgY2hhaW5JZCwgcnBjVXJscyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hhaW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCdFbXB0eSBjaGFpbklkJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJwY1VybHMgPT09IG51bGwgfHwgcnBjVXJscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcnBjVXJscy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoJ0VtcHR5IHJwY1VybHMnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0V0aGVyZXVtUHJvdmlkZXJfYWRkVG9Td2l0Y2hhYmxlKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGAke3BhcnNlQ2hhaW5JZChjaGFpbklkKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGxpc3RUb0FkZCkudGhlbigoKSA9PiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKCdFbXB0eSBuZXR3b3JrTGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5fRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuX2Jsb2N0by5zdXBwb3J0TmV0d29ya0xpc3QpLmxlbmd0aCkge1xuICAgICAgICAgICAgeWllbGQgZ2V0RXZtU3VwcG9ydCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4gKHRoaXMuX2Jsb2N0by5zdXBwb3J0TmV0d29ya0xpc3QgPSByZXN1bHQpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGRpc3QuZXRoRXJyb3JzLnByb3ZpZGVyLmN1c3RvbSh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDEwMDEsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBHZXQgYmxvY3RvIHNlcnZlciBmYWlsZWQ6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNoYWluX2lkLCBuYW1lLCBuZXR3b3JrX3R5cGUsIGJsb2N0b19zZXJ2aWNlX2Vudmlyb25tZW50LCBkaXNwbGF5X25hbWUsIH0gPSB0aGlzLl9ibG9jdG8uc3VwcG9ydE5ldHdvcmtMaXN0W3RoaXMubmV0d29ya1ZlcnNpb25dO1xuICAgICAgICBpZiAoIWNoYWluX2lkKVxuICAgICAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QoYEdldCBzdXBwb3J0IGNoYWluIGZhaWxlZDogJHt0aGlzLm5ldHdvcmtWZXJzaW9ufSBtaWdodCBub3QgYmUgc3VwcG9ydGVkIHlldC5gKTtcbiAgICAgICAgdGhpcy5fYmxvY3RvID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9ibG9jdG8pLCB7IHNlc3Npb25LZXk6IEVUSF9TRVNTSU9OX0tFWV9NQVBQSU5HW2Jsb2N0b19zZXJ2aWNlX2Vudmlyb25tZW50XSwgd2FsbGV0U2VydmVyOiB0aGlzLmluamVjdGVkV2FsbGV0U2VydmVyIHx8XG4gICAgICAgICAgICAgICAgRVRIX0VOVl9XQUxMRVRfU0VSVkVSX01BUFBJTkdbYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnRdLCBibG9ja2NoYWluTmFtZTogbmFtZSwgbmV0d29ya1R5cGU6IG5ldHdvcmtfdHlwZSwgc3dpdGNoYWJsZU5ldHdvcms6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYmxvY3RvLnN3aXRjaGFibGVOZXR3b3JrKSwgeyBbY2hhaW5faWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya190eXBlLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXRfd2ViX3VybDogdGhpcy5fYmxvY3RvLndhbGxldFNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgcnBjX3VybDogdGhpcy5ycGMsXG4gICAgICAgICAgICAgICAgfSB9KSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2N0bztcbiAgICB9KTtcbn0sIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSA9IGZ1bmN0aW9uIF9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSh7IGNoYWluSWQsIHJwY1VybHMsIH0pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB7IHN1cHBvcnROZXR3b3JrTGlzdCB9ID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXRoZXJldW1Qcm92aWRlcl9pbnN0YW5jZXMsIFwibVwiLCBfRXRoZXJldW1Qcm92aWRlcl9nZXRCbG9jdG9Qcm9wZXJ0aWVzKS5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGNoYWluX2lkLCBuYW1lLCBkaXNwbGF5X25hbWUsIG5ldHdvcmtfdHlwZSwgYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnQsIH0gPSBzdXBwb3J0TmV0d29ya0xpc3RbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IHdhbGxldF93ZWJfdXJsID0gRVRIX0VOVl9XQUxMRVRfU0VSVkVSX01BUFBJTkdbYmxvY3RvX3NlcnZpY2VfZW52aXJvbm1lbnRdO1xuICAgICAgICB0aGlzLl9ibG9jdG8uc3dpdGNoYWJsZU5ldHdvcmtbY2hhaW5faWRdID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgIG5ldHdvcmtfdHlwZSxcbiAgICAgICAgICAgIHdhbGxldF93ZWJfdXJsLFxuICAgICAgICAgICAgcnBjX3VybDogcnBjVXJsc1swXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn0sIF9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQgPSBmdW5jdGlvbiBfRXRoZXJldW1Qcm92aWRlcl9jaGVja05ldHdvcmtNYXRjaGVkKCkge1xuICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuZXRoZXJldW07XG4gICAgaWYgKGV4aXN0ZWRTREsgJiZcbiAgICAgICAgZXhpc3RlZFNESy5pc0Jsb2N0byAmJlxuICAgICAgICBwYXJzZUNoYWluSWQoZXhpc3RlZFNESy5jaGFpbklkKSAhPT0gcGFyc2VDaGFpbklkKHRoaXMuY2hhaW5JZCkpIHtcbiAgICAgICAgdGhyb3cgZGlzdC5ldGhFcnJvcnMucHJvdmlkZXIuY2hhaW5EaXNjb25uZWN0ZWQoKTtcbiAgICB9XG59O1xuXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpO1xuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaTtcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aDtcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKTtcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KTsgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSk7IC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIDsgZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5JykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICB2YXIgcGJlZ2luID0gMDtcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKys7XG4gICAgICB6ZXJvZXMrKztcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDA7XG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXTtcbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDA7XG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGk7XG4gICAgICBwYmVnaW4rKztcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aDtcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrKztcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKTtcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSk7IH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMDtcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrKztcbiAgICAgIHBzeisrO1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwOyAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildO1xuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDA7XG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDA7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaTtcbiAgICAgIHBzeisrO1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoO1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrKztcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSk7XG4gICAgdmFyIGogPSB6ZXJvZXM7XG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpO1xuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxudmFyIHNyYyA9IGJhc2U7XG5cbmNvbnN0IGJhc2V4ID0gc3JjO1xuY29uc3QgQUxQSEFCRVQgPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbnZhciBiczU4ID0gYmFzZXgoQUxQSEFCRVQpO1xuXG52YXIgYnM1OCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGJzNTgpO1xuXG5sZXQgU29sYW5hO1xudHJ5IHtcbiAgICBTb2xhbmEgPSByZXF1aXJlKCdAc29sYW5hL3dlYjMuanMnKTtcbn1cbmNhdGNoIChfYSkge1xuICAgIC8vIHByZXZlbnQgY3Jhc2ggaWYgdGhlcmUgaXMgbm8gQHNvbGFuYS93ZWIzLmpzLlxufVxuY2xhc3MgU29sYW5hUHJvdmlkZXIgZXh0ZW5kcyBCbG9jdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoeyBuZXQgPSAnbWFpbm5ldC1iZXRhJywgc2VydmVyLCBhcHBJZCwgcnBjLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGludmFyaWFudChuZXQsIFwiJ25ldCcgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIGludmFyaWFudChPYmplY3QudmFsdWVzKFNPTF9ORVQpLmluY2x1ZGVzKG5ldCksICd1bnN1cHBvcnRlZCBuZXQnKTtcbiAgICAgICAgdGhpcy5uZXQgPSBuZXQ7XG4gICAgICAgIHRoaXMucnBjID1cbiAgICAgICAgICAgIHJwYyB8fFxuICAgICAgICAgICAgICAgIChuZXQgPT09ICdtYWlubmV0LWJldGEnXG4gICAgICAgICAgICAgICAgICAgID8gJ2h0dHBzOi8vZnJlZS5ycGNwb29sLmNvbSdcbiAgICAgICAgICAgICAgICAgICAgOiBgaHR0cHM6Ly9hcGkuJHtuZXR9LnNvbGFuYS5jb21gKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXIgfHwgU09MX05FVF9TRVJWRVJfTUFQUElOR1t0aGlzLm5ldF0gfHwgJyc7XG4gICAgICAgIHRoaXMuYXBwSWQgPSBhcHBJZCB8fCBERUZBVUxUX0FQUF9JRDtcbiAgICAgICAgdGhpcy5zZXNzaW9uS2V5ID0gU09MX1NFU1NJT05fS0VZX01BUFBJTkdbdGhpcy5uZXRdO1xuICAgICAgICBpZiAoIVNvbGFuYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBAc29sYW5hL3dlYjMuanMgaW5zdGFsbGVkLiBQbGVhc2UgaW5zdGFsbCBpdCB0byBpbnRlcmFjdCB3aXRoIFNvbGFuYS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0KHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RlZFNESyA9IHdpbmRvdy5zb2xhbmE7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESyAmJiBleGlzdGVkU0RLLmlzQmxvY3RvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0ZWRTREsucmVxdWVzdChwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmZldGNoQWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldEFjY291bnRzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5TT0xBTkEpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeWllbGQgdGhpcy5mZXRjaEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0QWNjb3VudEluZm8nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIGRhdGEgYXMgdGhlIHNhbWUgZm9ybWF0IHJldHVybmluZyBmcm9tIENvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8gZnJvbSBAc29sYW5hL3dlYjMuanNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZjogaHR0cHM6Ly9zb2xhbmEtbGFicy5naXRodWIuaW8vc29sYW5hLXdlYjMuanMvY2xhc3Nlcy9Db25uZWN0aW9uLmh0bWwjZ2V0QWNjb3VudEluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRJbmZvID0geWllbGQgdGhpcy5oYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbYnVmZmVyRGF0YSwgZW5jb2RpbmddID0gYWNjb3VudEluZm8ucmVzdWx0LnZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnRJbmZvLnJlc3VsdC52YWx1ZSksIHsgZGF0YTogQnVmZmVyLmZyb20oYnVmZmVyRGF0YSwgZW5jb2RpbmcpLCBvd25lcjogbmV3IFNvbGFuYS5QdWJsaWNLZXkoYWNjb3VudEluZm8ucmVzdWx0LnZhbHVlLm93bmVyKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBKU09OLVJQQyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udmVydFRvUHJvZ3JhbVdhbGxldFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIHRoaXMuaGFuZGxlQ29udmVydFRyYW5zYWN0aW9uKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBKU09OLVJQQyBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbkFuZFNlbmRUcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB5aWVsZCB0aGlzLmhhbmRsZVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2sgdXNlciBmcm9tIHVzaW5nIHRyYWRpdGlvbmFsIG1ldGhvZHNcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnblRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbkFsbFRyYW5zYWN0aW9ucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsb2N0byBpcyBwcm9ncmFtIHdhbGxldCwgd2hpY2ggZG9lc24ndCBzdXBwb3J0ICR7cGF5bG9hZC5tZXRob2R9LiBVc2Ugc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmhhbmRsZVJlYWRSZXF1ZXN0cyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmICFyZXNwb25zZS5yZXN1bHQgJiYgcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2UuZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5lcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdSZXF1ZXN0IGZhaWxlZCc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuc29sYW5hO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGVkU0RLLm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RlZFNESy5wdWJsaWNLZXkudG9CYXNlNTgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RlZFNESy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCdDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dpbkZyYW1lID0gY3JlYXRlRnJhbWUoYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vc29sYW5hL2F1dGhuP2w2bj0ke2xvY2F0aW9ufSZ2PSR7U0RLX1ZFUlNJT059YCk7XG4gICAgICAgICAgICAgICAgYXR0YWNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS50eXBlID09PSAnU09MOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuY29ubmVjdC5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIodGhpcy5uZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZS5kYXRhLmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtDSEFJTi5TT0xBTkFdOiBbZS5kYXRhLmFkZHJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGUuZGF0YS5leHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ1NPTDpGUkFNRTpDTE9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVc2VyIGRlY2xpbmVkIHRoZSBsb2dpbiByZXF1ZXN0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LnNvbGFuYTtcbiAgICAgICAgICAgIGlmIChleGlzdGVkU0RLICYmIGV4aXN0ZWRTREsuaXNCbG9jdG8pIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBleGlzdGVkU0RLLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmRpc2Nvbm5lY3QuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKG51bGwpKTtcbiAgICAgICAgICAgIHJlbW92ZUNoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLlNPTEFOQSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEFjY291bnRzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSAoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50cyB9ID0geWllbGQgZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9zb2xhbmEvYWNjb3VudHNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2VTZXNzaW9uR3VhcmQocmVzcG9uc2UsIHRoaXMuc2Vzc2lvbktleSkpO1xuICAgICAgICAgICAgc2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uU09MQU5BLCBhY2NvdW50cyk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZWFkUmVxdWVzdHMocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHRoaXMucnBjLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7IGlkOiAxLCBqc29ucnBjOiAnMi4wJyB9LCBwYXlsb2FkKSksXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHNvbGFuYSB3ZWIzIHV0aWxpdHlcbiAgICBjb252ZXJ0VG9Qcm9ncmFtV2FsbGV0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuc29sYW5hO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLmNvbnZlcnRUb1Byb2dyYW1XYWxsZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0geWllbGQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdjb252ZXJ0VG9Qcm9ncmFtV2FsbGV0VHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0cmFuc2FjdGlvbi5zZXJpYWxpemVNZXNzYWdlKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVHJhbnNhY3Rpb24obWVzc2FnZSwgW10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuc29sYW5hO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREsgJiYgZXhpc3RlZFNESy5pc0Jsb2N0bykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7fTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uY29tbWl0bWVudClcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEuY29tbWl0bWVudCA9IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY29ubmVjdGlvbiBvYmplY3QgcGFzc2VkLWluIGhhcyBkaWZmZXJlbnQgcnBjIGVuZHBvaW50LCByZWNvbm5lY3QgdG8gaXRcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICAgICAgICAgICAgICBjb25zdCBycGMgPSBjb25uZWN0aW9uID8gY29ubmVjdGlvbi5fcnBjRW5kcG9pbnQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChycGMgJiYgcnBjICE9PSB0aGlzLnJwYykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJwYyA9IHJwYztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7IHNpZ25hdHVyZXM6IHlpZWxkIHRoaXMuY29sbGVjdFNpZ25hdHVyZXModHJhbnNhY3Rpb24pLCBtZXNzYWdlOiB0cmFuc2FjdGlvbi5zZXJpYWxpemVNZXNzYWdlKCkudG9TdHJpbmcoJ2hleCcpIH0sIGV4dHJhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc29sYW5hIHdlYjMgdXRpbGl0eVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgdG9UcmFuc2FjdGlvbihyYXcsIHNpZ25hdHVyZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBTb2xhbmEuTWVzc2FnZS5mcm9tKEJ1ZmZlci5mcm9tKHJhdywgJ2hleCcpKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFNvbGFuYS5UcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbWVzc2FnZS5yZWNlbnRCbG9ja2hhc2g7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzID4gMCkge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbWVzc2FnZS5hY2NvdW50S2V5c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpZ25hdHVyZXMuZm9yRWFjaCgoc2lnbmF0dXJlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ1B1YmtleVBhaXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID09PSBTb2xhbmEuUHVibGljS2V5LmRlZmF1bHQudG9CYXNlNTgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGJzNTgkMS5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBtZXNzYWdlLmFjY291bnRLZXlzW2luZGV4XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVzc2FnZS5pbnN0cnVjdGlvbnMuZm9yRWFjaCgoaW5zdHJ1Y3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gaW5zdHJ1Y3Rpb24uYWNjb3VudHMubWFwKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IG1lc3NhZ2UuYWNjb3VudEtleXNbYWNjb3VudF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NpZ25lcjogYWNjb3VudCA8IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFNvbGFuYS5UcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbUlkOiBtZXNzYWdlLmFjY291bnRLZXlzW2luc3RydWN0aW9uLnByb2dyYW1JZEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYnM1OCQxLmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHNvbGFuYSB3ZWIzIHV0aWxpdHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGNvbGxlY3RTaWduYXR1cmVzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2N1ci5wdWJsaWNLZXkudG9CYXNlNTgoKV0gPSBjdXIuc2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUNvbnZlcnRUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5zZXJ2ZXJ9L2FwaS9zb2xhbmEvY29udmVydFRvV2FsbGV0VHhgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZC5wYXJhbXMpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSAoKF9hID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uSWQgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvc29sYW5hL2F1dGh6YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBjaGVjayB0aGUgZXhpc3RlbmNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLUFwcGxpY2F0aW9uLUlkZW50aWZpZXInOiB0aGlzLmFwcElkLFxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLVNlc3Npb24tSWRlbnRpZmllcic6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQucGFyYW1zKSxcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZVNlc3Npb25HdWFyZChyZXNwb25zZSwgdGhpcy5zZXNzaW9uS2V5KSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRoekZyYW1lID0gY3JlYXRlRnJhbWUoYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vc29sYW5hL2F1dGh6LyR7YXV0aG9yaXphdGlvbklkfWApO1xuICAgICAgICAgICAgYXR0YWNoRnJhbWUoYXV0aHpGcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luID09PSB0aGlzLnNlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBlLmRhdGEudHlwZSA9PT0gJ1NPTDpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS5kYXRhLnR4SGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdERUNMSU5FRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBjaGVja01lc3NhZ2VQYXlsb2FkRm9ybWF0ID0gKHBheWxvYWQpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGZvcm1hdHRlZFBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXlsb2FkKTtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIG5vbmNlLCBhZGRyZXNzLCBhcHBsaWNhdGlvbiwgY2hhaW5JZCB9ID0gcGF5bG9hZDtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQubWVzc2FnZSA9IChfYSA9IFN0cmluZyhtZXNzYWdlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygbm9uY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZvcm1hdHRlZFBheWxvYWQubm9uY2UgPSAoX2IgPSBTdHJpbmcobm9uY2UpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICB9XG4gICAgaWYgKGFkZHJlc3MgJiYgdHlwZW9mIGFkZHJlc3MgIT09ICdib29sZWFuJykge1xuICAgICAgICBmb3JtYXR0ZWRQYXlsb2FkLmFkZHJlc3MgPSAhIWFkZHJlc3M7XG4gICAgfVxuICAgIGlmIChhcHBsaWNhdGlvbiAmJiB0eXBlb2YgYXBwbGljYXRpb24gIT09ICdib29sZWFuJykge1xuICAgICAgICBmb3JtYXR0ZWRQYXlsb2FkLmFwcGxpY2F0aW9uID0gISFhcHBsaWNhdGlvbjtcbiAgICB9XG4gICAgaWYgKGNoYWluSWQgJiYgdHlwZW9mIGNoYWluSWQgIT09ICdib29sZWFuJykge1xuICAgICAgICBmb3JtYXR0ZWRQYXlsb2FkLmNoYWluSWQgPSAhIWNoYWluSWQ7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXR0ZWRQYXlsb2FkO1xufTtcbmNsYXNzIEFwdG9zUHJvdmlkZXIgZXh0ZW5kcyBCbG9jdG9Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkLCBzZXJ2ZXIsIGFwcElkIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBbXTtcbiAgICAgICAgdGhpcy5hdXRoS2V5ID0gJyc7XG4gICAgICAgIGludmFyaWFudChjaGFpbklkLCBcIidjaGFpbklkJyBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgaW52YXJpYW50KGFwcElkLCAnSXQgaXMgbmVjZXNzYXJ5IHRvIGludGVyYWN0IHdpdGggQmxvY3RvIHdhbGxldCB2aWEgeW91ciBhcHAgaWQuIFBsZWFzZSB2aXNpdCBodHRwczovL2RldmVsb3BlcnMuYmxvY3RvLmFwcCBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB0aGlzLm5ldHdvcmtOYW1lID0gQVBUX0NIQUlOX0lEX05BTUVfTUFQUElOR1tjaGFpbklkXTtcbiAgICAgICAgdGhpcy5hcGkgPSBBUFRfQ0hBSU5fSURfUlBDX01BUFBJTkdbY2hhaW5JZF07XG4gICAgICAgIHRoaXMuc2Vzc2lvbktleSA9IEFQVF9TRVNTSU9OX0tFWV9NQVBQSU5HW2NoYWluSWRdO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2VydmVyID0gQVBUX0NIQUlOX0lEX1NFUlZFUl9NQVBQSU5HW2NoYWluSWRdO1xuICAgICAgICB0aGlzLmFwcElkID0gYXBwSWQgfHwgREVGQVVMVF9BUFBfSUQ7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyIHx8IGRlZmF1bHRTZXJ2ZXIgfHwgJyc7XG4gICAgfVxuICAgIGdldCBwdWJsaWNBY2NvdW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiAoKF9hID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pIHx8IG51bGwsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5Lmxlbmd0aCA/IHRoaXMucHVibGljS2V5IDogbnVsbCxcbiAgICAgICAgICAgIC8vIEB0b2RvOiBwcm92aWRlIGF1dGhrZXlcbiAgICAgICAgICAgIGF1dGhLZXk6IG51bGwsXG4gICAgICAgICAgICBtaW5LZXlzUmVxdWlyZWQ6IDIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmV0d29ya05hbWUsXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmFwaSxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiB0aGlzLmNoYWluSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKChfYSA9IGdldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LmJsb2N0b0FwdG9zO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RlZFNESy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnblRyYW5zYWN0aW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHlpZWxkIGV4aXN0ZWRTREsuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUNoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdHhPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0ZWRTREsgPSB3aW5kb3cuYmxvY3RvQXB0b3M7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdHhPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc0Nvbm5lY3RlZCA9IHlpZWxkIHRoaXMuaXNDb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIGlmICghaGFzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsIHRvIGdldCBhY2NvdW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSAoKF9iID0gZ2V0QWNjb3VudFN0b3JhZ2UodGhpcy5zZXNzaW9uS2V5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvZGUpIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uSWQgfSA9IHlpZWxkIGZldGNoKGAke3RoaXMuc2VydmVyfS9hcGkvYXB0b3MvYXV0aHpgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGNoZWNrIHRoZSBleGlzdGVuY2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tQXBwbGljYXRpb24tSWRlbnRpZmllcic6IHRoaXMuYXBwSWQsXG4gICAgICAgICAgICAgICAgICAgICdCbG9jdG8tU2Vzc2lvbi1JZGVudGlmaWVyJzogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbiksIHR4T3B0aW9ucykpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGh6RnJhbWUgPSBjcmVhdGVGcmFtZShgJHt0aGlzLnNlcnZlcn0vJHt0aGlzLmFwcElkfS9hcHRvcy9hdXRoei8ke2F1dGhvcml6YXRpb25JZH1gKTtcbiAgICAgICAgICAgIGF0dGFjaEZyYW1lKGF1dGh6RnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVFdmVudExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5zZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnR5cGUgPT09ICdBUFRPUzpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShhdXRoekZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBoYXNoOiBlLmRhdGEudHhIYXNoIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuc3RhdHVzID09PSAnREVDTElORUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoYXV0aHpGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLmVycm9yQ29kZSA9PT0gJ2luY29ycmVjdF9zZXNzaW9uX2lkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlLmRhdGEuZXJyb3JNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LmJsb2N0b0FwdG9zO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkUGF5bG9hZCA9IGNoZWNrTWVzc2FnZVBheWxvYWRGb3JtYXQocGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RlZFNESykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGVkU0RLLnNpZ25NZXNzYWdlKGZvcm1hdHRlZFBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFzQ29ubmVjdGVkID0geWllbGQgdGhpcy5pc0Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgaWYgKCFoYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKChfYSA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWwgdG8gZ2V0IGFjY291bnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2IgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZUlkIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL2FwdG9zL3VzZXItc2lnbmF0dXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBjaGVjayB0aGUgZXhpc3RlbmNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLUFwcGxpY2F0aW9uLUlkZW50aWZpZXInOiB0aGlzLmFwcElkLFxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLVNlc3Npb24tSWRlbnRpZmllcic6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZvcm1hdHRlZFBheWxvYWQpLFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuc2VydmVyfS8ke3RoaXMuYXBwSWR9L2FwdG9zL3VzZXItc2lnbmF0dXJlLyR7c2lnbmF0dXJlSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25GcmFtZSA9IGNyZWF0ZUZyYW1lKHVybCk7XG4gICAgICAgICAgICBhdHRhY2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFkZFNlbGZSZW1vdmFibGVIYW5kbGVyKCdtZXNzYWdlJywgKGV2ZW50LCByZW1vdmVFdmVudExpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5zZXJ2ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnR5cGUgPT09ICdBUFRPUzpGUkFNRTpSRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5zdGF0dXMgPT09ICdBUFBST1ZFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShzaWduRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuc3RhdHVzID09PSAnREVDTElORUQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhdGNoRnJhbWUoc2lnbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuZXJyb3JDb2RlID09PSAnaW5jb3JyZWN0X3Nlc3Npb25faWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUuZGF0YS5lcnJvck1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGVkU0RLID0gd2luZG93LmJsb2N0b0FwdG9zO1xuICAgICAgICAgICAgaWYgKGV4aXN0ZWRTREspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gXG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc21hbGwgZGVsYXkgdG8gbWFrZSBzdXJlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIHN3aXRjaGVkXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBleGlzdGVkU0RLLmNvbm5lY3QoKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCksIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoJ0N1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBnZXRDaGFpbkFkZHJlc3ModGhpcy5zZXNzaW9uS2V5LCBDSEFJTi5BUFRPUykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogKChfYiA9IGdldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhLZXk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5LZXlzUmVxdWlyZWQ6IDIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dpbkZyYW1lID0gY3JlYXRlRnJhbWUoYCR7dGhpcy5zZXJ2ZXJ9LyR7dGhpcy5hcHBJZH0vYXB0b3MvYXV0aG4/bDZuPSR7bG9jYXRpb259JnY9JHtTREtfVkVSU0lPTn19YCk7XG4gICAgICAgICAgICAgICAgYXR0YWNoRnJhbWUobG9naW5GcmFtZSk7XG4gICAgICAgICAgICAgICAgYWRkU2VsZlJlbW92YWJsZUhhbmRsZXIoJ21lc3NhZ2UnLCAoZXZlbnQsIHJlbW92ZUxpc3RlbmVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYywgX2QsIF9lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiA9PT0gdGhpcy5zZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ0FQVE9TOkZSQU1FOlJFU1BPTlNFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YXRjaEZyYW1lKGxvZ2luRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjY291bnRTdG9yYWdlKHRoaXMuc2Vzc2lvbktleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlLmRhdGEuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0NIQUlOLkFQVE9TXTogW2UuZGF0YS5hZGRyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBlLmRhdGEuZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9jID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHB1YmxpY19rZXlzOiBwdWJsaWNLZXlzIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYmxvY3RvL2FwdG9zL2FjY291bnRzLyR7KF9kID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMF19YCkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IHB1YmxpY0tleXMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAoKF9lID0gZ2V0Q2hhaW5BZGRyZXNzKHRoaXMuc2Vzc2lvbktleSwgQ0hBSU4uQVBUT1MpKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleTogdGhpcy5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aEtleTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5LZXlzUmVxdWlyZWQ6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbzogYmV0dGVyIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdBUFRPUzpGUkFNRTpDTE9TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGF0Y2hGcmFtZShsb2dpbkZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdVc2VyIGRlY2xpbmVkIHRoZSBsb2dpbiByZXF1ZXN0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEFkZHJlc3MoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICgoX2EgPSBnZXRBY2NvdW50U3RvcmFnZSh0aGlzLnNlc3Npb25LZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB5aWVsZCBmZXRjaChgJHt0aGlzLnNlcnZlcn0vYXBpL2FwdG9zL2FjY291bnRzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBjaGVjayB0aGUgZXhpc3RlbmNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLUFwcGxpY2F0aW9uLUlkZW50aWZpZXInOiB0aGlzLmFwcElkLFxuICAgICAgICAgICAgICAgICAgICAnQmxvY3RvLVNlc3Npb24tSWRlbnRpZmllcic6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlU2Vzc2lvbkd1YXJkKHJlc3BvbnNlLCB0aGlzLnNlc3Npb25LZXkpKTtcbiAgICAgICAgICAgIHNldENoYWluQWRkcmVzcyh0aGlzLnNlc3Npb25LZXksIENIQUlOLkFQVE9TLCBhY2NvdW50cyk7XG4gICAgICAgICAgICByZXR1cm4gKGFjY291bnRzID09PSBudWxsIHx8IGFjY291bnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY2NvdW50c1swXSkgfHwgJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQmxvY3RvU0RLIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGFwcElkLCBldGhlcmV1bSwgc29sYW5hLCBhcHRvcyB9KSB7XG4gICAgICAgIGlmIChldGhlcmV1bSkge1xuICAgICAgICAgICAgdGhpcy5ldGhlcmV1bSA9IG5ldyBFdGhlcmV1bVByb3ZpZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXRoZXJldW0pLCB7IGFwcElkIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29sYW5hKSB7XG4gICAgICAgICAgICB0aGlzLnNvbGFuYSA9IG5ldyBTb2xhbmFQcm92aWRlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNvbGFuYSksIHsgYXBwSWQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHRvcykge1xuICAgICAgICAgICAgdGhpcy5hcHRvcyA9IG5ldyBBcHRvc1Byb3ZpZGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXB0b3MpLCB7IGFwcElkIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgQmxvY3RvU0RLIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0IiwiQmxvY3RvU0RLIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJnZXQiLCJTdXBwcmVzc2VkRXJyb3IiLCJlcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwiRXJyb3IiLCJuYW1lIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiS0VZX1NFU1NJT04iLCJDSEFJTiIsIk1lbW9yeVN0b3JhZ2UiLCJjb25zdHJ1Y3RvciIsInN0b3JhZ2UiLCJnZXRJdGVtIiwia2V5Iiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJtZW1vcnlTdG9yYWdlIiwid2luZG93IiwiaXNTdXBwb3J0ZWQiLCJzZXNzaW9uU3RvcmFnZSIsImRlZmF1bHRWYWx1ZSIsIkpTT04iLCJwYXJzZSIsIlN5bnRheEVycm9yIiwic3RyaW5naWZ5IiwiZ2V0QWNjb3VudFN0b3JhZ2UiLCJyYXdBY2NvdW50U3RvcmFnZSIsIkRhdGUiLCJnZXRUaW1lIiwiZXhwaXJ5IiwidiIsIlNES19WRVJTSU9OIiwiZGF0YSIsInNldEFjY291bnRTdG9yYWdlIiwiX2EiLCJfYiIsIl9jIiwibmV3QWNjb3VudFN0b3JhZ2UiLCJjb2RlIiwiY29ubmVjdGVkIiwiYWNjb3VudHMiLCJPYmplY3QiLCJhc3NpZ24iLCJMT0dJTl9QRVJTSVNUSU5HX1RJTUUiLCJnZXRDaGFpbkFkZHJlc3MiLCJjaGFpbiIsInNldENoYWluQWRkcmVzcyIsImFjY291bnQiLCJyZW1vdmVDaGFpbkFkZHJlc3MiLCJ1bmRlZmluZWQiLCJFVEhfUlBDX0xJU1QiLCJFVEhfRU5WX1dBTExFVF9TRVJWRVJfTUFQUElORyIsInByb2QiLCJzdGFnaW5nIiwiZGV2IiwiRVRIX1NFU1NJT05fS0VZX01BUFBJTkciLCJTT0xfTkVUIiwiTWFpbm5ldEJldGEiLCJUZXN0bmV0IiwiRGV2bmV0IiwiU09MX05FVF9TRVJWRVJfTUFQUElORyIsIlNPTF9TRVNTSU9OX0tFWV9NQVBQSU5HIiwiQVBUX1NFU1NJT05fS0VZX01BUFBJTkciLCJBUFRfQ0hBSU5fSURfU0VSVkVSX01BUFBJTkciLCJXYWxsZXRBZGFwdGVyTmV0d29yayIsIkFQVF9DSEFJTl9JRF9OQU1FX01BUFBJTkciLCJNYWlubmV0IiwiVGVzdGluZyIsIlByZW1haW5uZXQiLCJBUFRfQ0hBSU5fSURfUlBDX01BUFBJTkciLCJFSVAxMTkzX0VWRU5UUyIsIkRFRkFVTFRfQVBQX0lEIiwiQmxvY3RvUHJvdmlkZXIiLCJpc0Jsb2N0byIsImlzQ29ubmVjdGluZyIsImV2ZW50TGlzdGVuZXJzIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJmb3JFYWNoIiwiZXZlbnQiLCJhcHBJZCIsInJlcXVlc3QiLCJwYXlsb2FkIiwib24iLCJsaXN0ZW5lciIsImluY2x1ZGVzIiwicHVzaCIsIm9uY2UiLCJsaXN0ZW5lcnMiLCJpbmRleCIsImZpbmRJbmRleCIsIml0ZW0iLCJzcGxpY2UiLCJJRlJBTUVfU1RZTEUiLCJjcmVhdGVGcmFtZSIsInVybCIsImZyYW1lIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYXR0YWNoRnJhbWUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJkZXRhdGNoRnJhbWUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJGdW5jdGlvbiIsImFkZFNlbGZSZW1vdmFibGVIYW5kbGVyIiwiZXZlbnRUeXBlIiwiaGFuZGxlciIsInRhcmdldCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVzcG9uc2VTZXNzaW9uR3VhcmQiLCJyZXNwb25zZSIsImRpc2Nvbm5lY3RIYW5kbGVyIiwic3RhdHVzIiwib2siLCJqc29uIiwiZXJyb3JfY29kZSIsImlzRW1haWwiLCJ0ZXN0IiwiaXNWYWxpZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJpc1ZhbGlkVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJ0eCIsImdldEV2bVN1cHBvcnQiLCJuZXR3b3JrcyIsImZldGNoIiwiZXZtU3VwcG9ydE1hcCIsInJlZHVjZSIsImEiLCJjaGFpbl9pZCIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwieCIsIl9fZXNNb2R1bGUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImRpc3QiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3RvUHJpbWl0aXZlIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwicmVzIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3RvUHJvcGVydHlLZXkiLCJhcmciLCJfZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9zZXRQcm90b3R5cGVPZiIsIm8iLCJwIiwic2V0UHJvdG90eXBlT2YiLCJiaW5kIiwiX19wcm90b19fIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2dldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfaXNOYXRpdmVGdW5jdGlvbiIsImZuIiwidG9TdHJpbmciLCJpbmRleE9mIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxIiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiX2NvbnN0cnVjdCIsIlBhcmVudCIsImFyZ3MiLCJDbGFzcyIsImFyZ3VtZW50cyIsIl93cmFwTmF0aXZlU3VwZXIiLCJfY2FjaGUiLCJNYXAiLCJzZXQiLCJXcmFwcGVyIiwiY2xhc3NlcyIsImZhc3RTYWZlU3RyaW5naWZ5Iiwic3RhYmxlIiwiZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSIsInN0YWJsZVN0cmluZ2lmeSIsIkxJTUlUX1JFUExBQ0VfTk9ERSIsIkNJUkNVTEFSX1JFUExBQ0VfTk9ERSIsImFyciIsInJlcGxhY2VyU3RhY2siLCJkZWZhdWx0T3B0aW9ucyIsImRlcHRoTGltaXQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZWRnZXNMaW1pdCIsInJlcGxhY2VyIiwic3BhY2VyIiwib3B0aW9ucyIsImRlY2lyYyIsInJlcGxhY2VHZXR0ZXJWYWx1ZXMiLCJfIiwicGFydCIsInBvcCIsInNldFJlcGxhY2UiLCJyZXBsYWNlIiwidmFsIiwiayIsInBhcmVudCIsInByb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVkZ2VJbmRleCIsInN0YWNrIiwiZGVwdGgiLCJrZXlzIiwiY29tcGFyZUZ1bmN0aW9uIiwiYiIsInRtcCIsImRldGVybWluaXN0aWNEZWNpcmMiLCJ0b0pTT04iLCJzb3J0IiwiX2NyZWF0ZVN1cGVyIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIk5ld1RhcmdldCIsIkV0aGVyZXVtUHJvdmlkZXJFcnJvciIsIkV0aGVyZXVtUnBjRXJyb3IiLCJmYXN0X3NhZmVfc3RyaW5naWZ5XzEiLCJfRXJyb3IiLCJfc3VwZXIiLCJfdGhpcyIsImlzSW50ZWdlciIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJzdHJpbmdpZnlSZXBsYWNlciIsIl9FdGhlcmV1bVJwY0Vycm9yIiwiX3N1cGVyMiIsImlzVmFsaWRFdGhQcm92aWRlckNvZGUiLCJ1dGlscyIsImVycm9yQ29uc3RhbnRzIiwiZXJyb3JWYWx1ZXMiLCJlcnJvckNvZGVzIiwicnBjIiwiaW52YWxpZElucHV0IiwicmVzb3VyY2VOb3RGb3VuZCIsInJlc291cmNlVW5hdmFpbGFibGUiLCJ0cmFuc2FjdGlvblJlamVjdGVkIiwibWV0aG9kTm90U3VwcG9ydGVkIiwibGltaXRFeGNlZWRlZCIsImludmFsaWRSZXF1ZXN0IiwibWV0aG9kTm90Rm91bmQiLCJpbnZhbGlkUGFyYW1zIiwiaW50ZXJuYWwiLCJwcm92aWRlciIsInVzZXJSZWplY3RlZFJlcXVlc3QiLCJ1bmF1dGhvcml6ZWQiLCJ1bnN1cHBvcnRlZE1ldGhvZCIsImRpc2Nvbm5lY3RlZCIsImNoYWluRGlzY29ubmVjdGVkIiwic3RhbmRhcmQiLCJleHBvcnRzIiwic2VyaWFsaXplRXJyb3IiLCJpc1ZhbGlkQ29kZSIsImdldE1lc3NhZ2VGcm9tQ29kZSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFIiwiZXJyb3JfY29uc3RhbnRzXzEiLCJjbGFzc2VzXzEiLCJGQUxMQkFDS19FUlJPUl9DT0RFIiwiRkFMTEJBQ0tfTUVTU0FHRSIsIkZBTExCQUNLX0VSUk9SIiwiZmFsbGJhY2tNZXNzYWdlIiwiY29kZVN0cmluZyIsImhhc0tleSIsImlzSnNvblJwY1NlcnZlckVycm9yIiwiX3JlZiIsIl9yZWYkZmFsbGJhY2tFcnJvciIsImZhbGxiYWNrRXJyb3IiLCJfcmVmJHNob3VsZEluY2x1ZGVTdGEiLCJzaG91bGRJbmNsdWRlU3RhY2siLCJfZXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiYXNzaWduT3JpZ2luYWxFcnJvciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9pIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsImVyciIsIl9hcnJheUxpa2VUb0FycmF5IiwibGVuIiwiYXJyMiIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsIm4iLCJzbGljZSIsImZyb20iLCJfbm9uSXRlcmFibGVSZXN0IiwiX3NsaWNlZFRvQXJyYXkiLCJlcnJvcnMiLCJldGhFcnJvcnMiLCJ1dGlsc18xIiwiZ2V0RXRoSnNvblJwY0Vycm9yIiwic2VydmVyIiwib3B0cyIsImdldEV0aFByb3ZpZGVyRXJyb3IiLCJjdXN0b20iLCJfcGFyc2VPcHRzIiwicGFyc2VPcHRzIiwiX3BhcnNlT3B0czIiLCJfcGFyc2VPcHRzMyIsIl9wYXJzZU9wdHM0IiwiZXJyb3JzXzEiLCJnbG9iYWwkMSIsImdsb2JhbCIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJpbml0ZWQiLCJpbml0IiwiY2hhckNvZGVBdCIsInRvQnl0ZUFycmF5IiwiYjY0IiwiaiIsImwiLCJwbGFjZUhvbGRlcnMiLCJMIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsInN0YXJ0IiwiZW5kIiwib3V0cHV0Iiwiam9pbiIsImZyb21CeXRlQXJyYXkiLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJyZWFkIiwiYnVmZmVyIiwib2Zmc2V0IiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJtIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiZCIsInMiLCJOYU4iLCJJbmZpbml0eSIsIk1hdGgiLCJwb3ciLCJ3cml0ZSIsImMiLCJydCIsImFicyIsImlzTmFOIiwiZmxvb3IiLCJsb2ciLCJMTjIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIkJ1ZmZlciIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJrTWF4TGVuZ3RoIiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsIlJhbmdlRXJyb3IiLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsInNwZWNpZXMiLCJhc3NlcnRTaXplIiwic2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsInN0cmluZyIsImlzRW5jb2RpbmciLCJieXRlTGVuZ3RoIiwiYWN0dWFsIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiYnl0ZU9mZnNldCIsImludGVybmFsSXNCdWZmZXIiLCJjb3B5IiwiaXNuYW4iLCJ0eXBlIiwiaXNCdWZmZXIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwieSIsIm1pbiIsInRvTG93ZXJDYXNlIiwiY29uY2F0IiwibGlzdCIsInBvcyIsImJ1ZiIsImlzVmlldyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJlcXVhbHMiLCJpbnNwZWN0Iiwic3RyIiwibWF4IiwibWF0Y2giLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VkIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzdWJhcnJheSIsInNsaWNlTGVuIiwiY2hlY2tPZmZzZXQiLCJleHQiLCJyZWFkVUludExFIiwibm9Bc3NlcnQiLCJtdWwiLCJyZWFkVUludEJFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludExFIiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJjaGVja0ludCIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVUludDgiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInNyYyIsImRzdCIsImlzRmFzdEJ1ZmZlciIsImlzU2xvd0J1ZmZlciIsImlzSGV4U3RyaW5nIiwiaGV4IiwidXRmOFRvSGV4IiwiX0V0aGVyZXVtUHJvdmlkZXJfaW5zdGFuY2VzIiwiX0V0aGVyZXVtUHJvdmlkZXJfZ2V0QmxvY3RvUHJvcGVydGllcyIsIl9FdGhlcmV1bVByb3ZpZGVyX2FkZFRvU3dpdGNoYWJsZSIsIl9FdGhlcmV1bVByb3ZpZGVyX2NoZWNrTmV0d29ya01hdGNoZWQiLCJwYXJzZUNoYWluSWQiLCJjaGFpbklkIiwic3RhcnRzV2l0aCIsIkV0aGVyZXVtUHJvdmlkZXIiLCJ3YWxsZXRTZXJ2ZXIiLCJhZGQiLCJuZXR3b3JrVmVyc2lvbiIsImluamVjdGVkV2FsbGV0U2VydmVyIiwiX2Jsb2N0byIsInNlc3Npb25LZXkiLCJibG9ja2NoYWluTmFtZSIsIm5ldHdvcmtUeXBlIiwic3VwcG9ydE5ldHdvcmtMaXN0Iiwic3dpdGNoYWJsZU5ldHdvcmsiLCJzZW5kIiwibWV0aG9kT3JQYXlsb2FkIiwicGFyYW1zT3JDYWxsYmFjayIsInNlbmRBc3luYyIsImpzb25ycGMiLCJtZXRob2QiLCJwYXJhbXMiLCJjYWxsYmFjayIsImhhbmRsZVJlcXVlc3QiLCJmaWx0ZXIiLCJtYXAiLCJpZEJhc2UiLCJyYW5kb20iLCJiYXRjaGVkUmVxdWVzdFBheWxvYWQiLCJiYXRjaFJlc3BvbnNlUHJvbWlzZSIsInJlcXVlc3RzIiwiaWQiLCJhbGxTZXR0bGVkIiwicmVzcG9uc2VzIiwicmVhc29uIiwiY2F0Y2giLCJzZW5kVXNlck9wZXJhdGlvbiIsInVzZXJPcCIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJleGlzdGVkU0RLIiwiZXRoZXJldW0iLCJycGNfdXJsIiwibG9hZFN3aXRjaGFibGVOZXR3b3JrIiwiaGFuZGxlUmVhZFJlcXVlc3RzIiwiZXJyb3JNZXNzYWdlIiwibmV3Q2hhaW5JZCIsInBoYXNlZENoYWluSWQiLCJjaGFpbkNoYW5nZWQiLCJlbWFpbCIsImVuYWJsZSIsImZldGNoQWNjb3VudHMiLCJoYW5kbGVTaWduIiwiaGFuZGxlRGlzY29ubmVjdCIsImhhbmRsZVNlbmRUcmFuc2FjdGlvbiIsImhhbmRsZVNlbmRCYXRjaFRyYW5zYWN0aW9uIiwiaGFuZGxlU2VuZFVzZXJPcGVyYXRpb24iLCJvbGRBY2NvdW50Iiwib2xkQ2hhaW5JZCIsIm5ld0FjY291bnQiLCJhY2NvdW50c0NoYW5nZWQiLCJoYW5kbGVCdW5kbGVyIiwiYmxvY3RvQXBpIiwic2Vzc2lvbklkIiwiaGVhZGVycyIsImRpc2Nvbm5lY3QiLCJyZXNwb25zZUxpc3RlbmVyIiwib2JqZWN0S2V5Iiwib3JpZ2luIiwiZXJyb3JDb2RlIiwic2V0SWZyYW1lIiwiYWRkcmVzcyIsInNldFRpbWVvdXQiLCJVUkxTZWFyY2hQYXJhbXMiLCJsb2NhdGlvbiIsImVtYWlsUGFyYW0iLCJsb2dpbkZyYW1lIiwiY29ubmVjdCIsImFkZHIiLCJleHAiLCJkb21haW4iLCJzaWduYXR1cmVJZCIsInNpZ25GcmFtZSIsImF1dGhvcml6YXRpb25JZCIsImF1dGh6RnJhbWUiLCJleHRyYWN0UGFyYW1zIiwicGFyYW0iLCJmb3JtYXRQYXJhbXMiLCJjb3B5UGF5bG9hZCIsInVzZXJPUEZyYW1lIiwibmV0d29ya0xpc3QiLCJsaXN0VG9BZGQiLCJycGNVcmxzIiwiYWxsIiwiV2Vha1NldCIsIm5ldHdvcmtfdHlwZSIsImJsb2N0b19zZXJ2aWNlX2Vudmlyb25tZW50IiwiZGlzcGxheV9uYW1lIiwid2FsbGV0X3dlYl91cmwiLCJiYXNlIiwiQUxQSEFCRVQiLCJCQVNFX01BUCIsImNoYXJBdCIsInhjIiwiQkFTRSIsIkxFQURFUiIsIkZBQ1RPUiIsImlGQUNUT1IiLCJlbmNvZGUiLCJzb3VyY2UiLCJ6ZXJvZXMiLCJwYmVnaW4iLCJwZW5kIiwiYjU4IiwiY2FycnkiLCJpdDEiLCJpdDIiLCJyZXBlYXQiLCJkZWNvZGVVbnNhZmUiLCJwc3oiLCJiMjU2IiwiaXQzIiwiaXQ0IiwidmNoIiwiZGVjb2RlIiwiYmFzZXgiLCJiczU4IiwiYnM1OCQxIiwiU29sYW5hIiwicmVxdWlyZSIsIlNvbGFuYVByb3ZpZGVyIiwibmV0IiwidmFsdWVzIiwic29sYW5hIiwiU09MQU5BIiwiYWNjb3VudEluZm8iLCJidWZmZXJEYXRhIiwib3duZXIiLCJQdWJsaWNLZXkiLCJoYW5kbGVDb252ZXJ0VHJhbnNhY3Rpb24iLCJoYW5kbGVTaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwiY29uc29sZSIsInB1YmxpY0tleSIsInRvQmFzZTU4IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY29udmVydFRvUHJvZ3JhbVdhbGxldFRyYW5zYWN0aW9uIiwic2VyaWFsaXplTWVzc2FnZSIsInRvVHJhbnNhY3Rpb24iLCJzaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsImV4dHJhIiwiY29tbWl0bWVudCIsIl9ycGNFbmRwb2ludCIsInNpZ25hdHVyZXMiLCJjb2xsZWN0U2lnbmF0dXJlcyIsInJhdyIsIk1lc3NhZ2UiLCJUcmFuc2FjdGlvbiIsInJlY2VudEJsb2NraGFzaCIsImhlYWRlciIsIm51bVJlcXVpcmVkU2lnbmF0dXJlcyIsImZlZVBheWVyIiwiYWNjb3VudEtleXMiLCJzaWduYXR1cmUiLCJzaWdQdWJrZXlQYWlyIiwiaW5zdHJ1Y3Rpb25zIiwiaW5zdHJ1Y3Rpb24iLCJwdWJrZXkiLCJpc1NpZ25lciIsImlzV3JpdGFibGUiLCJpc0FjY291bnRXcml0YWJsZSIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJwcm9ncmFtSWQiLCJwcm9ncmFtSWRJbmRleCIsImFjYyIsImN1ciIsInR4SGFzaCIsImNoZWNrTWVzc2FnZVBheWxvYWRGb3JtYXQiLCJmb3JtYXR0ZWRQYXlsb2FkIiwibm9uY2UiLCJhcHBsaWNhdGlvbiIsIkFwdG9zUHJvdmlkZXIiLCJhdXRoS2V5IiwibmV0d29ya05hbWUiLCJhcGkiLCJkZWZhdWx0U2VydmVyIiwicHVibGljQWNjb3VudCIsIkFQVE9TIiwibWluS2V5c1JlcXVpcmVkIiwibmV0d29yayIsImlzQ29ubmVjdGVkIiwic2lnblRyYW5zYWN0aW9uIiwiYmxvY3RvQXB0b3MiLCJoYXNDb25uZWN0ZWQiLCJzaWduQW5kU3VibWl0VHJhbnNhY3Rpb24iLCJ0eE9wdGlvbnMiLCJoYXNoIiwic2lnbk1lc3NhZ2UiLCJwdWJsaWNfa2V5cyIsInB1YmxpY0tleXMiLCJmZXRjaEFkZHJlc3MiLCJhcHRvcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocto/sdk/dist/blocto-sdk.module.js\n");

/***/ })

};
;