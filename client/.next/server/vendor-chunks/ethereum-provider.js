"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereum-provider";
exports.ids = ["vendor-chunks/ethereum-provider"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereum-provider/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/ethereum-provider/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst events_1 = __importDefault(__webpack_require__(/*! events */ \"events\"));\nconst payload_1 = __webpack_require__(/*! ./payload */ \"(ssr)/./node_modules/ethereum-provider/dist/payload.js\");\nclass Provider extends events_1.default {\n    constructor(connection){\n        super();\n        this.promises = {};\n        this.attemptedSubscriptions = new Set();\n        this.subscriptions = [];\n        this.checkConnectionRunning = false;\n        this.nextId = 1;\n        this.connected = false;\n        this.accounts = [];\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n        this.enable = this.enable.bind(this);\n        this.doSend = this.doSend.bind(this);\n        this.send = this.send.bind(this);\n        this.sendBatch = this.sendBatch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.unsubscribe = this.unsubscribe.bind(this);\n        this.resumeSubscriptions = this.resumeSubscriptions.bind(this);\n        this.sendAsync = this.sendAsync.bind(this);\n        this.sendAsyncBatch = this.sendAsyncBatch.bind(this);\n        this.isConnected = this.isConnected.bind(this);\n        this.close = this.close.bind(this);\n        this.request = this.request.bind(this);\n        this.connection = connection;\n        this.on(\"connect\", this.resumeSubscriptions);\n        this.connection.on(\"connect\", ()=>this.checkConnection(1000));\n        this.connection.on(\"close\", ()=>{\n            this.connected = false;\n            this.attemptedSubscriptions.clear();\n            this.emit(\"close\");\n            this.emit(\"disconnect\");\n        });\n        this.connection.on(\"payload\", (payload)=>{\n            const { id, method, error, result } = payload;\n            if (typeof id !== \"undefined\") {\n                if (this.promises[id]) {\n                    const requestMethod = this.promises[id].method;\n                    if (requestMethod && [\n                        \"eth_accounts\",\n                        \"eth_requestAccounts\"\n                    ].includes(requestMethod)) {\n                        const accounts = result || [];\n                        this.accounts = accounts;\n                        this.selectedAddress = accounts[0];\n                        this.coinbase = accounts[0];\n                    }\n                    payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);\n                    delete this.promises[id];\n                }\n            } else if (method && method.indexOf(\"_subscription\") > -1) {\n                // Events: connect, disconnect, chainChanged, chainsChanged, accountsChanged, assetsChanged, message\n                this.emit(payload.params.subscription, payload.params.result);\n                this.emit(method, payload.params); // Older EIP-1193\n                this.emit(\"message\", {\n                    type: payload.method,\n                    data: {\n                        subscription: payload.params.subscription,\n                        result: payload.params.result\n                    }\n                });\n                this.emit(\"data\", payload); // Backwards Compatibility\n            }\n        });\n        this.on(\"newListener\", (event)=>{\n            if (Object.keys(this.eventHandlers).includes(event)) {\n                if (!this.attemptedSubscription(event) && this.connected) {\n                    this.startSubscription(event);\n                    if (event === \"networkChanged\") {\n                        console.warn(\"The networkChanged event is being deprecated, use chainChanged instead\");\n                    }\n                }\n            }\n        });\n        this.eventHandlers = {\n            networkChanged: (netId)=>{\n                this.networkVersion = typeof netId === \"string\" ? parseInt(netId) : netId;\n                this.emit(\"networkChanged\", this.networkVersion);\n            },\n            chainChanged: (chainId)=>{\n                this.providerChainId = chainId;\n                if (!this.manualChainId) {\n                    this.emit(\"chainChanged\", chainId);\n                }\n            },\n            chainsChanged: (chains)=>{\n                this.emit(\"chainsChanged\", chains);\n            },\n            accountsChanged: (accounts)=>{\n                this.selectedAddress = accounts[0];\n                this.emit(\"accountsChanged\", accounts);\n            },\n            assetsChanged: (assets)=>{\n                this.emit(\"assetsChanged\", assets);\n            }\n        };\n    }\n    get chainId() {\n        return this.manualChainId || this.providerChainId;\n    }\n    async checkConnection(retryTimeout = 4000) {\n        if (this.checkConnectionRunning || this.connected) return;\n        clearTimeout(this.checkConnectionTimer);\n        this.checkConnectionTimer = undefined;\n        this.checkConnectionRunning = true;\n        try {\n            this.networkVersion = await this.doSend(\"net_version\", [], undefined, false);\n            this.providerChainId = await this.doSend(\"eth_chainId\", [], undefined, false);\n            this.connected = true;\n        } catch (e) {\n            this.checkConnectionTimer = setTimeout(()=>this.checkConnection(), retryTimeout);\n            this.connected = false;\n        } finally{\n            this.checkConnectionRunning = false;\n            if (this.connected) {\n                this.emit(\"connect\", {\n                    chainId: this.providerChainId\n                });\n            }\n        }\n    }\n    attemptedSubscription(event) {\n        return this.attemptedSubscriptions.has(event);\n    }\n    setSubscriptionAttempted(event) {\n        this.attemptedSubscriptions.add(event);\n    }\n    async startSubscription(event) {\n        console.debug(`starting subscription for ${event} events`);\n        this.setSubscriptionAttempted(event);\n        try {\n            const eventId = await this.subscribe(\"eth_subscribe\", event);\n            this.on(eventId, this.eventHandlers[event]);\n        } catch (e) {\n            console.warn(`Unable to subscribe to ${event}`, e);\n        }\n    }\n    resumeSubscriptions() {\n        Object.keys(this.eventHandlers).forEach((event)=>{\n            if (this.listenerCount(event) && !this.attemptedSubscription(event)) this.startSubscription(event);\n        });\n    }\n    async enable() {\n        const accounts = await this.doSend(\"eth_accounts\");\n        if (accounts.length > 0) {\n            this.accounts = accounts;\n            this.selectedAddress = accounts[0];\n            this.coinbase = accounts[0];\n            this.emit(\"enable\");\n            return accounts;\n        } else {\n            const err = new Error(\"User Denied Full Provider\");\n            err.code = \"4001\";\n            throw err;\n        }\n    }\n    doSend(rawPayload, rawParams = [], targetChain = this.manualChainId, waitForConnection = true) {\n        const sendFn = (resolve, reject)=>{\n            const method = typeof rawPayload === \"object\" ? rawPayload.method : rawPayload;\n            const params = typeof rawPayload === \"object\" ? rawPayload.params : rawParams;\n            const chainTarget = typeof rawPayload === \"object\" && rawPayload.chainId || targetChain;\n            if (!method) {\n                return reject(new Error(\"Method is not a valid string.\"));\n            }\n            try {\n                const payload = (0, payload_1.create)(method, params, this.nextId++, chainTarget);\n                this.promises[payload.id] = {\n                    resolve: (result)=>resolve(result),\n                    reject,\n                    method: payload.method\n                };\n                this.connection.send(payload);\n            } catch (e) {\n                reject(e);\n            }\n        };\n        if (this.connected || !waitForConnection) {\n            return new Promise(sendFn);\n        }\n        return new Promise((resolve, reject)=>{\n            const resolveSend = ()=>{\n                clearTimeout(disconnectTimer);\n                return resolve(new Promise(sendFn));\n            };\n            const disconnectTimer = setTimeout(()=>{\n                this.off(\"connect\", resolveSend);\n                reject(new Error(\"Not connected\"));\n            }, 5000);\n            this.once(\"connect\", resolveSend);\n        });\n    }\n    async send(methodOrPayload, callbackOrArgs) {\n        if (typeof methodOrPayload === \"string\" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {\n            const params = callbackOrArgs;\n            return this.doSend(methodOrPayload, params);\n        }\n        if (methodOrPayload && typeof methodOrPayload === \"object\" && typeof callbackOrArgs === \"function\") {\n            // a callback was passed to send(), forward everything to sendAsync()\n            const cb = callbackOrArgs;\n            return this.sendAsync(methodOrPayload, cb);\n        }\n        return this.request(methodOrPayload);\n    }\n    sendBatch(requests) {\n        return Promise.all(requests.map((payload)=>{\n            return this.doSend(payload.method, payload.params);\n        }));\n    }\n    async subscribe(type, method, params = []) {\n        const id = await this.doSend(type, [\n            method,\n            ...params\n        ]);\n        this.subscriptions.push(id);\n        return id;\n    }\n    async unsubscribe(type, id) {\n        const success = await this.doSend(type, [\n            id\n        ]);\n        if (success) {\n            this.subscriptions = this.subscriptions.filter((_id)=>_id !== id); // Remove subscription\n            this.removeAllListeners(id); // Remove listeners\n            return success;\n        }\n    }\n    async sendAsync(rawPayload, cb) {\n        if (!cb || typeof cb !== \"function\") return new Error(\"Invalid or undefined callback provided to sendAsync\");\n        if (!rawPayload) return cb(new Error(\"Invalid Payload\"));\n        // sendAsync can be called with an array for batch requests used by web3.js 0.x\n        // this is not part of EIP-1193's backwards compatibility but we still want to support it\n        if (Array.isArray(rawPayload)) {\n            const payloads = rawPayload.map((p)=>({\n                    ...p,\n                    jsonrpc: \"2.0\"\n                }));\n            const callback = cb;\n            return this.sendAsyncBatch(payloads, callback);\n        } else {\n            const payload = {\n                ...rawPayload,\n                jsonrpc: \"2.0\"\n            };\n            const callback = cb;\n            try {\n                const result = await this.doSend(payload.method, payload.params);\n                callback(null, {\n                    id: payload.id,\n                    jsonrpc: payload.jsonrpc,\n                    result\n                });\n            } catch (e) {\n                callback(e);\n            }\n        }\n    }\n    async sendAsyncBatch(payloads, cb) {\n        try {\n            const results = await this.sendBatch(payloads);\n            const result = results.map((entry, index)=>{\n                return {\n                    id: payloads[index].id,\n                    jsonrpc: payloads[index].jsonrpc,\n                    result: entry\n                };\n            });\n            cb(null, result);\n        } catch (e) {\n            cb(e);\n        }\n    }\n    isConnected() {\n        return this.connected;\n    }\n    close() {\n        if (this.connection && this.connection.close) this.connection.close();\n        this.off(\"connect\", this.resumeSubscriptions);\n        this.connected = false;\n        const error = new Error(\"Provider closed, subscription lost, please subscribe again.\");\n        this.subscriptions.forEach((id)=>this.emit(id, error)); // Send Error objects to any open subscriptions\n        this.subscriptions = []; // Clear subscriptions\n        this.manualChainId = undefined;\n        this.providerChainId = undefined;\n        this.networkVersion = undefined;\n        this.selectedAddress = undefined;\n        this.coinbase = undefined;\n    }\n    async request(payload) {\n        return this.doSend(payload.method, payload.params, payload.chainId);\n    }\n    setChain(chainId) {\n        if (typeof chainId === \"number\") chainId = \"0x\" + chainId.toString(16);\n        const chainChanged = chainId !== this.chainId;\n        this.manualChainId = chainId;\n        if (chainChanged) {\n            this.emit(\"chainChanged\", this.chainId);\n        }\n    }\n}\nexports[\"default\"] = Provider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxXQUFXUCxnQkFBZ0JRLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pELE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLHlFQUFXO0FBQ3JDLE1BQU1FLGlCQUFpQkgsU0FBU0ksT0FBTztJQUNuQ0MsWUFBWUMsVUFBVSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFFBQVEsR0FBRyxDQUFDO1FBQ2pCLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsSUFBSUM7UUFDbEMsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNDLHNCQUFzQixHQUFHO1FBQzlCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUNDLGVBQWUsR0FBR0M7UUFDdkIsSUFBSSxDQUFDQyxRQUFRLEdBQUdEO1FBQ2hCLElBQUksQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuQyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDRSxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUNGLElBQUksQ0FBQyxJQUFJO1FBQy9CLElBQUksQ0FBQ0csU0FBUyxHQUFHLElBQUksQ0FBQ0Es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Q0FBQztRQUN0QyxNQUFNMUQsZUFBZ0JDLFlBQVksSUFBSSxDQUFDQSxPQUFPO1FBQzlDLElBQUksQ0FBQ0UsYUFBYSxHQUFHRjtRQUNyQixJQUFJRCxjQUFjO1lBQ2QsSUFBSSxDQUFDMUIsSUFBSSxDQUFDLGdCQUFnQixJQUFJLENBQUMyQixPQUFPO1FBQzFDO0lBQ0o7QUFDSjtBQUNBL0Qsa0JBQWUsR0FBR0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9pbmRleC5qcz82Y2I3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV2ZW50c1wiKSk7XG5jb25zdCBwYXlsb2FkXzEgPSByZXF1aXJlKFwiLi9wYXlsb2FkXCIpO1xuY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBldmVudHNfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJvbWlzZXMgPSB7fTtcbiAgICAgICAgdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb25SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV4dElkID0gMTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb2luYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbmFibGUgPSB0aGlzLmVuYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvU2VuZCA9IHRoaXMuZG9TZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZCA9IHRoaXMuc2VuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlbmRCYXRjaCA9IHRoaXMuc2VuZEJhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXN1bWVTdWJzY3JpcHRpb25zID0gdGhpcy5yZXN1bWVTdWJzY3JpcHRpb25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VuZEFzeW5jID0gdGhpcy5zZW5kQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZW5kQXN5bmNCYXRjaCA9IHRoaXMuc2VuZEFzeW5jQmF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRoaXMuaXNDb25uZWN0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMub24oJ2Nvbm5lY3QnLCB0aGlzLnJlc3VtZVN1YnNjcmlwdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Nvbm5lY3QnLCAoKSA9PiB0aGlzLmNoZWNrQ29ubmVjdGlvbigxMDAwKSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbigncGF5bG9hZCcsIHBheWxvYWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgbWV0aG9kLCBlcnJvciwgcmVzdWx0IH0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9taXNlc1tpZF0pIHsgLy8gRnVsZmlsbCBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RNZXRob2QgPSB0aGlzLnByb21pc2VzW2lkXS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0TWV0aG9kICYmIFsnZXRoX2FjY291bnRzJywgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnXS5pbmNsdWRlcyhyZXF1ZXN0TWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSByZXN1bHQgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY291bnRzID0gYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IGFjY291bnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2luYmFzZSA9IGFjY291bnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuZXJyb3IgPyB0aGlzLnByb21pc2VzW2lkXS5yZWplY3QoZXJyb3IpIDogdGhpcy5wcm9taXNlc1tpZF0ucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wcm9taXNlc1tpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kICYmIG1ldGhvZC5pbmRleE9mKCdfc3Vic2NyaXB0aW9uJykgPiAtMSkgeyAvLyBFbWl0IHN1YnNjcmlwdGlvbiByZXN1bHRcbiAgICAgICAgICAgICAgICAvLyBFdmVudHM6IGNvbm5lY3QsIGRpc2Nvbm5lY3QsIGNoYWluQ2hhbmdlZCwgY2hhaW5zQ2hhbmdlZCwgYWNjb3VudHNDaGFuZ2VkLCBhc3NldHNDaGFuZ2VkLCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KHBheWxvYWQucGFyYW1zLnN1YnNjcmlwdGlvbiwgcGF5bG9hZC5wYXJhbXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQobWV0aG9kLCBwYXlsb2FkLnBhcmFtcyk7IC8vIE9sZGVyIEVJUC0xMTkzXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXlsb2FkLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uOiBwYXlsb2FkLnBhcmFtcy5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHBheWxvYWQucGFyYW1zLnJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGF5bG9hZCk7IC8vIEJhY2t3YXJkcyBDb21wYXRpYmlsaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmV2ZW50SGFuZGxlcnMpLmluY2x1ZGVzKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb24oZXZlbnQpICYmIHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdWJzY3JpcHRpb24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgPT09ICduZXR3b3JrQ2hhbmdlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIG5ldHdvcmtDaGFuZ2VkIGV2ZW50IGlzIGJlaW5nIGRlcHJlY2F0ZWQsIHVzZSBjaGFpbkNoYW5nZWQgaW5zdGVhZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgbmV0d29ya0NoYW5nZWQ6IG5ldElkID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gKHR5cGVvZiBuZXRJZCA9PT0gJ3N0cmluZycpID8gcGFyc2VJbnQobmV0SWQpIDogbmV0SWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCduZXR3b3JrQ2hhbmdlZCcsIHRoaXMubmV0d29ya1ZlcnNpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYWluQ2hhbmdlZDogY2hhaW5JZCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlckNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYW51YWxDaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhaW5DaGFuZ2VkJywgY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYWluc0NoYW5nZWQ6IGNoYWlucyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFpbnNDaGFuZ2VkJywgY2hhaW5zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY2NvdW50c0NoYW5nZWQ6IChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRBZGRyZXNzID0gYWNjb3VudHNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNzZXRzQ2hhbmdlZDogYXNzZXRzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Fzc2V0c0NoYW5nZWQnLCBhc3NldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgY2hhaW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFudWFsQ2hhaW5JZCB8fCB0aGlzLnByb3ZpZGVyQ2hhaW5JZDtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tDb25uZWN0aW9uKHJldHJ5VGltZW91dCA9IDQwMDApIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDb25uZWN0aW9uUnVubmluZyB8fCB0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tDb25uZWN0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5uZXR3b3JrVmVyc2lvbiA9IGF3YWl0IHRoaXMuZG9TZW5kKCduZXRfdmVyc2lvbicsIFtdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJDaGFpbklkID0gYXdhaXQgdGhpcy5kb1NlbmQoJ2V0aF9jaGFpbklkJywgW10sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoZWNrQ29ubmVjdGlvbigpLCByZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgeyBjaGFpbklkOiB0aGlzLnByb3ZpZGVyQ2hhaW5JZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRlbXB0ZWRTdWJzY3JpcHRpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdGVkU3Vic2NyaXB0aW9ucy5oYXMoZXZlbnQpO1xuICAgIH1cbiAgICBzZXRTdWJzY3JpcHRpb25BdHRlbXB0ZWQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0ZWRTdWJzY3JpcHRpb25zLmFkZChldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0U3Vic2NyaXB0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoYHN0YXJ0aW5nIHN1YnNjcmlwdGlvbiBmb3IgJHtldmVudH0gZXZlbnRzYCk7XG4gICAgICAgIHRoaXMuc2V0U3Vic2NyaXB0aW9uQXR0ZW1wdGVkKGV2ZW50KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50SWQgPSBhd2FpdCAodGhpcy5zdWJzY3JpYmUoJ2V0aF9zdWJzY3JpYmUnLCBldmVudCkpO1xuICAgICAgICAgICAgdGhpcy5vbihldmVudElkLCB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gc3Vic2NyaWJlIHRvICR7ZXZlbnR9YCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5ldmVudEhhbmRsZXJzKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQpICYmICF0aGlzLmF0dGVtcHRlZFN1YnNjcmlwdGlvbihldmVudCkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFN1YnNjcmlwdGlvbihldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBlbmFibGUoKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5kb1NlbmQoJ2V0aF9hY2NvdW50cycpO1xuICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hY2NvdW50cyA9IGFjY291bnRzO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEFkZHJlc3MgPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY29pbmJhc2UgPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5hYmxlJyk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1VzZXIgRGVuaWVkIEZ1bGwgUHJvdmlkZXInKTtcbiAgICAgICAgICAgIGVyci5jb2RlID0gJzQwMDEnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvU2VuZChyYXdQYXlsb2FkLCByYXdQYXJhbXMgPSBbXSwgdGFyZ2V0Q2hhaW4gPSB0aGlzLm1hbnVhbENoYWluSWQsIHdhaXRGb3JDb25uZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzZW5kRm4gPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdvYmplY3QnKSA/IHJhd1BheWxvYWQubWV0aG9kIDogcmF3UGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9ICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ29iamVjdCcpID8gcmF3UGF5bG9hZC5wYXJhbXMgOiByYXdQYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBjaGFpblRhcmdldCA9ICgodHlwZW9mIHJhd1BheWxvYWQgPT09ICdvYmplY3QnKSAmJiByYXdQYXlsb2FkLmNoYWluSWQpIHx8IHRhcmdldENoYWluO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTWV0aG9kIGlzIG5vdCBhIHZhbGlkIHN0cmluZy4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoMCwgcGF5bG9hZF8xLmNyZWF0ZSkobWV0aG9kLCBwYXJhbXMsIHRoaXMubmV4dElkKyssIGNoYWluVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VzW3BheWxvYWQuaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiAocmVzdWx0KSA9PiByZXNvbHZlKHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwYXlsb2FkLm1ldGhvZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkIHx8ICF3YWl0Rm9yQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHNlbmRGbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVTZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkaXNjb25uZWN0VGltZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5ldyBQcm9taXNlKHNlbmRGbikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdjb25uZWN0JywgcmVzb2x2ZVNlbmQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKSk7XG4gICAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgICAgIHRoaXMub25jZSgnY29ubmVjdCcsIHJlc29sdmVTZW5kKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQobWV0aG9kT3JQYXlsb2FkLCBjYWxsYmFja09yQXJncykge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZE9yUGF5bG9hZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICghY2FsbGJhY2tPckFyZ3MgfHwgQXJyYXkuaXNBcnJheShjYWxsYmFja09yQXJncykpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjYWxsYmFja09yQXJncztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvU2VuZChtZXRob2RPclBheWxvYWQsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZE9yUGF5bG9hZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1ldGhvZE9yUGF5bG9hZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYWxsYmFja09yQXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gYSBjYWxsYmFjayB3YXMgcGFzc2VkIHRvIHNlbmQoKSwgZm9yd2FyZCBldmVyeXRoaW5nIHRvIHNlbmRBc3luYygpXG4gICAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrT3JBcmdzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKG1ldGhvZE9yUGF5bG9hZCwgY2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWV0aG9kT3JQYXlsb2FkKTtcbiAgICB9XG4gICAgc2VuZEJhdGNoKHJlcXVlc3RzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXF1ZXN0cy5tYXAocGF5bG9hZCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb1NlbmQocGF5bG9hZC5tZXRob2QsIHBheWxvYWQucGFyYW1zKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUodHlwZSwgbWV0aG9kLCBwYXJhbXMgPSBbXSkge1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMuZG9TZW5kKHR5cGUsIFttZXRob2QsIC4uLnBhcmFtc10pO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChpZCk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmUodHlwZSwgaWQpIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMuZG9TZW5kKHR5cGUsIFtpZF0pO1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmZpbHRlcihfaWQgPT4gX2lkICE9PSBpZCk7IC8vIFJlbW92ZSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGlkKTsgLy8gUmVtb3ZlIGxpc3RlbmVyc1xuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZEFzeW5jKHJhd1BheWxvYWQsIGNiKSB7XG4gICAgICAgIGlmICghY2IgfHwgdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBvciB1bmRlZmluZWQgY2FsbGJhY2sgcHJvdmlkZWQgdG8gc2VuZEFzeW5jJyk7XG4gICAgICAgIGlmICghcmF3UGF5bG9hZClcbiAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ0ludmFsaWQgUGF5bG9hZCcpKTtcbiAgICAgICAgLy8gc2VuZEFzeW5jIGNhbiBiZSBjYWxsZWQgd2l0aCBhbiBhcnJheSBmb3IgYmF0Y2ggcmVxdWVzdHMgdXNlZCBieSB3ZWIzLmpzIDAueFxuICAgICAgICAvLyB0aGlzIGlzIG5vdCBwYXJ0IG9mIEVJUC0xMTkzJ3MgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYnV0IHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydCBpdFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdQYXlsb2FkKSkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSByYXdQYXlsb2FkLm1hcChwID0+ICh7IC4uLnAsIGpzb25ycGM6ICcyLjAnIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmNCYXRjaChwYXlsb2FkcywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHsgLi4ucmF3UGF5bG9hZCwganNvbnJwYzogJzIuMCcgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZG9TZW5kKHBheWxvYWQubWV0aG9kLCBwYXlsb2FkLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBpZDogcGF5bG9hZC5pZCwganNvbnJwYzogcGF5bG9hZC5qc29ucnBjLCByZXN1bHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlbmRBc3luY0JhdGNoKHBheWxvYWRzLCBjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VuZEJhdGNoKHBheWxvYWRzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHMubWFwKChlbnRyeSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpZDogcGF5bG9hZHNbaW5kZXhdLmlkLCBqc29ucnBjOiBwYXlsb2Fkc1tpbmRleF0uanNvbnJwYywgcmVzdWx0OiBlbnRyeSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYihudWxsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGVkO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24uY2xvc2UpXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgdGhpcy5vZmYoJ2Nvbm5lY3QnLCB0aGlzLnJlc3VtZVN1YnNjcmlwdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUHJvdmlkZXIgY2xvc2VkLCBzdWJzY3JpcHRpb24gbG9zdCwgcGxlYXNlIHN1YnNjcmliZSBhZ2Fpbi4nKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goaWQgPT4gdGhpcy5lbWl0KGlkLCBlcnJvcikpOyAvLyBTZW5kIEVycm9yIG9iamVjdHMgdG8gYW55IG9wZW4gc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTsgLy8gQ2xlYXIgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLm1hbnVhbENoYWluSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXJDaGFpbklkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5ldHdvcmtWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlbGVjdGVkQWRkcmVzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb2luYmFzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvU2VuZChwYXlsb2FkLm1ldGhvZCwgcGF5bG9hZC5wYXJhbXMsIHBheWxvYWQuY2hhaW5JZCk7XG4gICAgfVxuICAgIHNldENoYWluKGNoYWluSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFpbklkID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGNoYWluSWQgPSAnMHgnICsgY2hhaW5JZC50b1N0cmluZygxNik7XG4gICAgICAgIGNvbnN0IGNoYWluQ2hhbmdlZCA9IChjaGFpbklkICE9PSB0aGlzLmNoYWluSWQpO1xuICAgICAgICB0aGlzLm1hbnVhbENoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICBpZiAoY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYWluQ2hhbmdlZCcsIHRoaXMuY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQcm92aWRlcjtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJldmVudHNfMSIsInJlcXVpcmUiLCJwYXlsb2FkXzEiLCJQcm92aWRlciIsImRlZmF1bHQiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb24iLCJwcm9taXNlcyIsImF0dGVtcHRlZFN1YnNjcmlwdGlvbnMiLCJTZXQiLCJzdWJzY3JpcHRpb25zIiwiY2hlY2tDb25uZWN0aW9uUnVubmluZyIsIm5leHRJZCIsImNvbm5lY3RlZCIsImFjY291bnRzIiwic2VsZWN0ZWRBZGRyZXNzIiwidW5kZWZpbmVkIiwiY29pbmJhc2UiLCJlbmFibGUiLCJiaW5kIiwiZG9TZW5kIiwic2VuZCIsInNlbmRCYXRjaCIsInN1YnNjcmliZSIsInVuc3Vic2NyaWJlIiwicmVzdW1lU3Vic2NyaXB0aW9ucyIsInNlbmRBc3luYyIsInNlbmRBc3luY0JhdGNoIiwiaXNDb25uZWN0ZWQiLCJjbG9zZSIsInJlcXVlc3QiLCJvbiIsImNoZWNrQ29ubmVjdGlvbiIsImNsZWFyIiwiZW1pdCIsInBheWxvYWQiLCJpZCIsIm1ldGhvZCIsImVycm9yIiwicmVzdWx0IiwicmVxdWVzdE1ldGhvZCIsImluY2x1ZGVzIiwicmVqZWN0IiwicmVzb2x2ZSIsImluZGV4T2YiLCJwYXJhbXMiLCJzdWJzY3JpcHRpb24iLCJ0eXBlIiwiZGF0YSIsImV2ZW50Iiwia2V5cyIsImV2ZW50SGFuZGxlcnMiLCJhdHRlbXB0ZWRTdWJzY3JpcHRpb24iLCJzdGFydFN1YnNjcmlwdGlvbiIsImNvbnNvbGUiLCJ3YXJuIiwibmV0d29ya0NoYW5nZWQiLCJuZXRJZCIsIm5ldHdvcmtWZXJzaW9uIiwicGFyc2VJbnQiLCJjaGFpbkNoYW5nZWQiLCJjaGFpbklkIiwicHJvdmlkZXJDaGFpbklkIiwibWFudWFsQ2hhaW5JZCIsImNoYWluc0NoYW5nZWQiLCJjaGFpbnMiLCJhY2NvdW50c0NoYW5nZWQiLCJhc3NldHNDaGFuZ2VkIiwiYXNzZXRzIiwicmV0cnlUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2hlY2tDb25uZWN0aW9uVGltZXIiLCJlIiwic2V0VGltZW91dCIsImhhcyIsInNldFN1YnNjcmlwdGlvbkF0dGVtcHRlZCIsImFkZCIsImRlYnVnIiwiZXZlbnRJZCIsImZvckVhY2giLCJsaXN0ZW5lckNvdW50IiwibGVuZ3RoIiwiZXJyIiwiRXJyb3IiLCJjb2RlIiwicmF3UGF5bG9hZCIsInJhd1BhcmFtcyIsInRhcmdldENoYWluIiwid2FpdEZvckNvbm5lY3Rpb24iLCJzZW5kRm4iLCJjaGFpblRhcmdldCIsImNyZWF0ZSIsIlByb21pc2UiLCJyZXNvbHZlU2VuZCIsImRpc2Nvbm5lY3RUaW1lciIsIm9mZiIsIm9uY2UiLCJtZXRob2RPclBheWxvYWQiLCJjYWxsYmFja09yQXJncyIsIkFycmF5IiwiaXNBcnJheSIsImNiIiwicmVxdWVzdHMiLCJhbGwiLCJtYXAiLCJwdXNoIiwic3VjY2VzcyIsImZpbHRlciIsIl9pZCIsInJlbW92ZUFsbExpc3RlbmVycyIsInBheWxvYWRzIiwicCIsImpzb25ycGMiLCJjYWxsYmFjayIsInJlc3VsdHMiLCJlbnRyeSIsImluZGV4Iiwic2V0Q2hhaW4iLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-provider/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereum-provider/dist/payload.js":
/*!********************************************************!*\
  !*** ./node_modules/ethereum-provider/dist/payload.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.create = void 0;\nfunction create(method, params = [], id, targetChain) {\n    const payload = {\n        id,\n        method,\n        params,\n        jsonrpc: \"2.0\"\n    };\n    if (targetChain) {\n        payload.chainId = targetChain;\n    }\n    if (payload.method === \"eth_sendTransaction\") {\n        const mismatchedChain = isChainMismatch(payload);\n        if (mismatchedChain) {\n            throw new Error(`Payload chainId (${mismatchedChain}) inconsistent with specified target chainId: ${targetChain}`);\n        }\n        return updatePayloadChain(payload);\n    }\n    return payload;\n}\nexports.create = create;\nfunction isChainMismatch(payload) {\n    if (payload.method !== \"eth_sendTransaction\") return false;\n    const tx = payload.params[0] || {};\n    const chainId = tx.chainId;\n    return \"chainId\" in tx && parseInt(chainId) !== parseInt(payload.chainId || chainId);\n}\nfunction updatePayloadChain(payload) {\n    const tx = payload.params[0] || {};\n    return {\n        ...payload,\n        params: [\n            {\n                ...tx,\n                chainId: tx.chainId || payload.chainId\n            },\n            ...payload.params.slice(1)\n        ]\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW0tcHJvdmlkZXIvZGlzdC9wYXlsb2FkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixTQUFTRSxPQUFPQyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLFdBQVc7SUFDaEQsTUFBTUMsVUFBVTtRQUNaRjtRQUFJRjtRQUFRQztRQUFRSSxTQUFTO0lBQ2pDO0lBQ0EsSUFBSUYsYUFBYTtRQUNiQyxRQUFRRSxPQUFPLEdBQUdIO0lBQ3RCO0lBQ0EsSUFBSUMsUUFBUUosTUFBTSxLQUFLLHVCQUF1QjtRQUMxQyxNQUFNTyxrQkFBa0JDLGdCQUFnQko7UUFDeEMsSUFBSUcsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSUUsTUFBTSxDQUFDLGlCQUFpQixFQUFFRixnQkFBZ0IsOENBQThDLEVBQUVKLFlBQVksQ0FBQztRQUNySDtRQUNBLE9BQU9PLG1CQUFtQk47SUFDOUI7SUFDQSxPQUFPQTtBQUNYO0FBQ0FQLGNBQWMsR0FBR0U7QUFDakIsU0FBU1MsZ0JBQWdCSixPQUFPO0lBQzVCLElBQUlBLFFBQVFKLE1BQU0sS0FBSyx1QkFDbkIsT0FBTztJQUNYLE1BQU1XLEtBQUtQLFFBQVFILE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQztJQUNqQyxNQUFNSyxVQUFVSyxHQUFHTCxPQUFPO0lBQzFCLE9BQU8sYUFBY0ssTUFBT0MsU0FBU04sYUFBYU0sU0FBU1IsUUFBUUUsT0FBTyxJQUFJQTtBQUNsRjtBQUNBLFNBQVNJLG1CQUFtQk4sT0FBTztJQUMvQixNQUFNTyxLQUFLUCxRQUFRSCxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUM7SUFDakMsT0FBTztRQUFFLEdBQUdHLE9BQU87UUFBRUgsUUFBUTtZQUFDO2dCQUFFLEdBQUdVLEVBQUU7Z0JBQUVMLFNBQVNLLEdBQUdMLE9BQU8sSUFBSUYsUUFBUUUsT0FBTztZQUFDO2VBQU1GLFFBQVFILE1BQU0sQ0FBQ1ksS0FBSyxDQUFDO1NBQUc7SUFBQztBQUNqSCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1wcm92aWRlci9kaXN0L3BheWxvYWQuanM/MGNjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlID0gdm9pZCAwO1xuZnVuY3Rpb24gY3JlYXRlKG1ldGhvZCwgcGFyYW1zID0gW10sIGlkLCB0YXJnZXRDaGFpbikge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIGlkLCBtZXRob2QsIHBhcmFtcywganNvbnJwYzogJzIuMCdcbiAgICB9O1xuICAgIGlmICh0YXJnZXRDaGFpbikge1xuICAgICAgICBwYXlsb2FkLmNoYWluSWQgPSB0YXJnZXRDaGFpbjtcbiAgICB9XG4gICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicpIHtcbiAgICAgICAgY29uc3QgbWlzbWF0Y2hlZENoYWluID0gaXNDaGFpbk1pc21hdGNoKHBheWxvYWQpO1xuICAgICAgICBpZiAobWlzbWF0Y2hlZENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBheWxvYWQgY2hhaW5JZCAoJHttaXNtYXRjaGVkQ2hhaW59KSBpbmNvbnNpc3RlbnQgd2l0aCBzcGVjaWZpZWQgdGFyZ2V0IGNoYWluSWQ6ICR7dGFyZ2V0Q2hhaW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZVBheWxvYWRDaGFpbihwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmZ1bmN0aW9uIGlzQ2hhaW5NaXNtYXRjaChwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQubWV0aG9kICE9PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB0eCA9IHBheWxvYWQucGFyYW1zWzBdIHx8IHt9O1xuICAgIGNvbnN0IGNoYWluSWQgPSB0eC5jaGFpbklkO1xuICAgIHJldHVybiAoJ2NoYWluSWQnIGluIHR4KSAmJiBwYXJzZUludChjaGFpbklkKSAhPT0gcGFyc2VJbnQocGF5bG9hZC5jaGFpbklkIHx8IGNoYWluSWQpO1xufVxuZnVuY3Rpb24gdXBkYXRlUGF5bG9hZENoYWluKHBheWxvYWQpIHtcbiAgICBjb25zdCB0eCA9IHBheWxvYWQucGFyYW1zWzBdIHx8IHt9O1xuICAgIHJldHVybiB7IC4uLnBheWxvYWQsIHBhcmFtczogW3sgLi4udHgsIGNoYWluSWQ6IHR4LmNoYWluSWQgfHwgcGF5bG9hZC5jaGFpbklkIH0sIC4uLnBheWxvYWQucGFyYW1zLnNsaWNlKDEpXSB9O1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlIiwibWV0aG9kIiwicGFyYW1zIiwiaWQiLCJ0YXJnZXRDaGFpbiIsInBheWxvYWQiLCJqc29ucnBjIiwiY2hhaW5JZCIsIm1pc21hdGNoZWRDaGFpbiIsImlzQ2hhaW5NaXNtYXRjaCIsIkVycm9yIiwidXBkYXRlUGF5bG9hZENoYWluIiwidHgiLCJwYXJzZUludCIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereum-provider/dist/payload.js\n");

/***/ })

};
;