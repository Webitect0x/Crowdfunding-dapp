"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-utils";
exports.ids = ["vendor-chunks/web3-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-utils/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/web3-utils/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file utils.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar ethjsUnit = __webpack_require__(/*! ethjs-unit */ \"(ssr)/./node_modules/ethjs-unit/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/lib/utils.js\");\nvar soliditySha3 = __webpack_require__(/*! ./soliditySha3.js */ \"(ssr)/./node_modules/web3-utils/lib/soliditySha3.js\");\nvar randombytes = __webpack_require__(/*! randombytes */ \"(ssr)/./node_modules/randombytes/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/**\n * Fires an error in an event emitter and callback and returns the eventemitter\n *\n * @method _fireError\n * @param {Object} error a string, a error, or an object with {message, data}\n * @param {Object} emitter\n * @param {Function} reject\n * @param {Function} callback\n * @param {any} optionalData\n * @return {Object} the emitter\n */ var _fireError = function(error, emitter, reject, callback, optionalData) {\n    /*jshint maxcomplexity: 10 */ // add data if given\n    if (!!error && typeof error === \"object\" && !(error instanceof Error) && error.data) {\n        if (!!error.data && typeof error.data === \"object\" || Array.isArray(error.data)) {\n            error.data = JSON.stringify(error.data, null, 2);\n        }\n        error = error.message + \"\\n\" + error.data;\n    }\n    if (typeof error === \"string\") {\n        error = new Error(error);\n    }\n    if (typeof callback === \"function\") {\n        callback(error, optionalData);\n    }\n    if (typeof reject === \"function\") {\n        // suppress uncatched error if an error listener is present\n        // OR suppress uncatched error if an callback listener is present\n        if (emitter && typeof emitter.listeners === \"function\" && emitter.listeners(\"error\").length || typeof callback === \"function\") {\n            emitter.catch(function() {});\n        }\n        // reject later, to be able to return emitter\n        setTimeout(function() {\n            reject(error);\n        }, 1);\n    }\n    if (emitter && typeof emitter.emit === \"function\") {\n        // emit later, to be able to return emitter\n        setTimeout(function() {\n            emitter.emit(\"error\", error, optionalData);\n            emitter.removeAllListeners();\n        }, 1);\n    }\n    return emitter;\n};\n/**\n * Should be used to create full function/event name from json abi\n *\n * @method _jsonInterfaceMethodToString\n * @param {Object} json\n * @return {String} full function/event name\n */ var _jsonInterfaceMethodToString = function(json) {\n    if (!!json && typeof json === \"object\" && json.name && json.name.indexOf(\"(\") !== -1) {\n        return json.name;\n    }\n    return json.name + \"(\" + _flattenTypes(false, json.inputs).join(\",\") + \")\";\n};\n/**\n * Should be used to flatten json abi inputs/outputs into an array of type-representing-strings\n *\n * @method _flattenTypes\n * @param {bool} includeTuple\n * @param {Object} puts\n * @return {Array} parameters as strings\n */ var _flattenTypes = function(includeTuple, puts) {\n    // console.log(\"entered _flattenTypes. inputs/outputs: \" + puts)\n    var types = [];\n    puts.forEach(function(param) {\n        if (typeof param.components === \"object\") {\n            if (param.type.substring(0, 5) !== \"tuple\") {\n                throw new Error(\"components found but type is not tuple; report on GitHub\");\n            }\n            var suffix = \"\";\n            var arrayBracket = param.type.indexOf(\"[\");\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            var result = _flattenTypes(includeTuple, param.components);\n            // console.log(\"result should have things: \" + result)\n            if (Array.isArray(result) && includeTuple) {\n                // console.log(\"include tuple word, and its an array. joining...: \" + result.types)\n                types.push(\"tuple(\" + result.join(\",\") + \")\" + suffix);\n            } else if (!includeTuple) {\n                // console.log(\"don't include tuple, but its an array. joining...: \" + result)\n                types.push(\"(\" + result.join(\",\") + \")\" + suffix);\n            } else {\n                // console.log(\"its a single type within a tuple: \" + result.types)\n                types.push(\"(\" + result + \")\");\n            }\n        } else {\n            // console.log(\"its a type and not directly in a tuple: \" + param.type)\n            types.push(param.type);\n        }\n    });\n    return types;\n};\n/**\n * Returns a random hex string by the given bytes size\n *\n * @param {Number} size\n * @returns {string}\n */ var randomHex = function(size) {\n    return \"0x\" + randombytes(size).toString(\"hex\");\n};\n/**\n * Should be called to get ascii from it's hex representation\n *\n * @method hexToAscii\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */ var hexToAscii = function(hex) {\n    if (!utils.isHexStrict(hex)) throw new Error(\"The parameter must be a valid HEX string.\");\n    var str = \"\";\n    var i = 0, l = hex.length;\n    if (hex.substring(0, 2) === \"0x\") {\n        i = 2;\n    }\n    for(; i < l; i += 2){\n        var code = parseInt(hex.slice(i, i + 2), 16);\n        str += String.fromCharCode(code);\n    }\n    return str;\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @method asciiToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */ var asciiToHex = function(str) {\n    if (!str) return \"0x00\";\n    var hex = \"\";\n    for(var i = 0; i < str.length; i++){\n        var code = str.charCodeAt(i);\n        var n = code.toString(16);\n        hex += n.length < 2 ? \"0\" + n : n;\n    }\n    return \"0x\" + hex;\n};\n/**\n * Returns value of unit in Wei\n *\n * @method getUnitValue\n * @param {String} unit the unit to convert to, default ether\n * @returns {BN} value of the unit (in Wei)\n * @throws error if the unit is not correct:w\n */ var getUnitValue = function(unit) {\n    unit = unit ? unit.toLowerCase() : \"ether\";\n    if (!ethjsUnit.unitMap[unit]) {\n        throw new Error('This unit \"' + unit + \"\\\" doesn't exist, please use the one of the following units\" + JSON.stringify(ethjsUnit.unitMap, null, 2));\n    }\n    return unit;\n};\n/**\n * Takes a number of wei and converts it to any other ether unit.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method fromWei\n * @param {Number|String} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert to, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */ var fromWei = function(number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === \"string\")) {\n        throw new Error(\"Please pass numbers as strings or BN objects to avoid precision errors.\");\n    }\n    return utils.isBN(number) ? ethjsUnit.fromWei(number, unit) : ethjsUnit.fromWei(number, unit).toString(10);\n};\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * Possible units are:\n *   SI Short   SI Full        Effigy       Other\n * - kwei       femtoether     babbage\n * - mwei       picoether      lovelace\n * - gwei       nanoether      shannon      nano\n * - --         microether     szabo        micro\n * - --         microether     szabo        micro\n * - --         milliether     finney       milli\n * - ether      --             --\n * - kether                    --           grand\n * - mether\n * - gether\n * - tether\n *\n * @method toWei\n * @param {Number|String|BN} number can be a number, number string or a HEX of a decimal\n * @param {String} unit the unit to convert from, default ether\n * @return {String|Object} When given a BN object it returns one as well, otherwise a number\n */ var toWei = function(number, unit) {\n    unit = getUnitValue(unit);\n    if (!utils.isBN(number) && !(typeof number === \"string\")) {\n        throw new Error(\"Please pass numbers as strings or BN objects to avoid precision errors.\");\n    }\n    return utils.isBN(number) ? ethjsUnit.toWei(number, unit) : ethjsUnit.toWei(number, unit).toString(10);\n};\n/**\n * Converts to a checksum address\n *\n * @method toChecksumAddress\n * @param {String} address the given HEX address\n * @return {String}\n */ var toChecksumAddress = function(address) {\n    if (typeof address === \"undefined\") return \"\";\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) throw new Error('Given address \"' + address + '\" is not a valid Ethereum address.');\n    address = address.toLowerCase().replace(/^0x/i, \"\");\n    var addressHash = utils.sha3(address).replace(/^0x/i, \"\");\n    var checksumAddress = \"0x\";\n    for(var i = 0; i < address.length; i++){\n        // If ith character is 8 to f then make it uppercase\n        if (parseInt(addressHash[i], 16) > 7) {\n            checksumAddress += address[i].toUpperCase();\n        } else {\n            checksumAddress += address[i];\n        }\n    }\n    return checksumAddress;\n};\n/**\n * Returns -1 if a<b, 1 if a>b; 0 if a == b.\n * For more details on this type of function, see\n * developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * Block tag `safe` and `block number` combination param is not supported\n * @method compareBlockNumbers\n *\n * @param {String|Number|BN} a\n *\n * @param {String|Number|BN} b\n *\n * @returns {Number} -1, 0, or 1\n */ var compareBlockNumbers = function(a, b) {\n    // Increasing order: (genesis = earliest), safe, (finalized ~ latest), pending\n    // safe vs block-num cant be compared as block number provided can be on left or right side of safe tag, until safe tag block number is extracted and compared\n    if (a === b) {\n        return 0;\n    } else if ((\"genesis\" === a || \"earliest\" === a || 0 === a) && (\"genesis\" === b || \"earliest\" === b || 0 === b)) {\n        return 0;\n    } else if (\"genesis\" === a || \"earliest\" === a || a === 0) {\n        // b !== a, thus a < b\n        return -1;\n    } else if (\"genesis\" === b || \"earliest\" === b || b === 0) {\n        // b !== a, thus a > b\n        return 1;\n    } else if (a === \"latest\" || a === \"finalized\") {\n        if (b === \"pending\") {\n            return -1;\n        } else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return 1;\n        }\n    } else if (b === \"latest\" || b === \"finalized\") {\n        if (a === \"pending\") {\n            return 1;\n        } else {\n            // b !== (\"pending\" OR \"latest\"), thus a > b\n            return -1;\n        }\n    } else if (a === \"pending\") {\n        // b (== OR <) \"latest\", thus a > b\n        return 1;\n    } else if (b === \"pending\") {\n        return -1;\n    } else if (a === \"safe\" || b === \"safe\") {\n        // either a or b is \"safe\" and the other one did not fall into any of the conditions above, so the other one is a number\n        return undefined;\n    } else {\n        let bnA = new BN(a);\n        let bnB = new BN(b);\n        if (bnA.lt(bnB)) {\n            return -1;\n        } else if (bnA.eq(bnB)) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n};\nmodule.exports = {\n    _fireError: _fireError,\n    _jsonInterfaceMethodToString: _jsonInterfaceMethodToString,\n    _flattenTypes: _flattenTypes,\n    // extractDisplayName: extractDisplayName,\n    // extractTypeName: extractTypeName,\n    randomHex: randomHex,\n    BN: utils.BN,\n    isBN: utils.isBN,\n    isBigNumber: utils.isBigNumber,\n    isHex: utils.isHex,\n    isHexStrict: utils.isHexStrict,\n    sha3: utils.sha3,\n    sha3Raw: utils.sha3Raw,\n    keccak256: utils.sha3,\n    soliditySha3: soliditySha3.soliditySha3,\n    soliditySha3Raw: soliditySha3.soliditySha3Raw,\n    encodePacked: soliditySha3.encodePacked,\n    isAddress: utils.isAddress,\n    checkAddressChecksum: utils.checkAddressChecksum,\n    toChecksumAddress: toChecksumAddress,\n    toHex: utils.toHex,\n    toBN: utils.toBN,\n    bytesToHex: utils.bytesToHex,\n    hexToBytes: utils.hexToBytes,\n    hexToNumberString: utils.hexToNumberString,\n    hexToNumber: utils.hexToNumber,\n    toDecimal: utils.hexToNumber,\n    numberToHex: utils.numberToHex,\n    fromDecimal: utils.numberToHex,\n    hexToUtf8: utils.hexToUtf8,\n    hexToString: utils.hexToUtf8,\n    toUtf8: utils.hexToUtf8,\n    stripHexPrefix: utils.stripHexPrefix,\n    utf8ToHex: utils.utf8ToHex,\n    stringToHex: utils.utf8ToHex,\n    fromUtf8: utils.utf8ToHex,\n    hexToAscii: hexToAscii,\n    toAscii: hexToAscii,\n    asciiToHex: asciiToHex,\n    fromAscii: asciiToHex,\n    unitMap: ethjsUnit.unitMap,\n    toWei: toWei,\n    fromWei: fromWei,\n    padLeft: utils.leftPad,\n    leftPad: utils.leftPad,\n    padRight: utils.rightPad,\n    rightPad: utils.rightPad,\n    toTwosComplement: utils.toTwosComplement,\n    isBloom: utils.isBloom,\n    isUserEthereumAddressInBloom: utils.isUserEthereumAddressInBloom,\n    isContractAddressInBloom: utils.isContractAddressInBloom,\n    isTopic: utils.isTopic,\n    isTopicInBloom: utils.isTopicInBloom,\n    isInBloom: utils.isInBloom,\n    compareBlockNumbers: compareBlockNumbers,\n    toNumber: utils.toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Q7Ozs7O0NBS0M7QUFDRCxJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUN4QixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxlQUFlRixtQkFBT0EsQ0FBQztBQUMzQixJQUFJRyxjQUFjSCxtQkFBT0EsQ0FBQztBQUMxQixJQUFJSSxLQUFLSixtQkFBT0EsQ0FBQztBQUNqQjs7Ozs7Ozs7OztDQVVDLEdBQ0QsSUFBSUssYUFBYSxTQUFVQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFlBQVk7SUFDckUsMkJBQTJCLEdBQzNCLG9CQUFvQjtJQUNwQixJQUFJLENBQUMsQ0FBQ0osU0FBUyxPQUFPQSxVQUFVLFlBQVksQ0FBRUEsQ0FBQUEsaUJBQWlCSyxLQUFJLEtBQU1MLE1BQU1NLElBQUksRUFBRTtRQUNqRixJQUFJLENBQUMsQ0FBQ04sTUFBTU0sSUFBSSxJQUFJLE9BQU9OLE1BQU1NLElBQUksS0FBSyxZQUFZQyxNQUFNQyxPQUFPLENBQUNSLE1BQU1NLElBQUksR0FBRztZQUM3RU4sTUFBTU0sSUFBSSxHQUFHRyxLQUFLQyxTQUFTLENBQUNWLE1BQU1NLElBQUksRUFBRSxNQUFNO1FBQ2xEO1FBQ0FOLFFBQVFBLE1BQU1XLE9BQU8sR0FBRyxPQUFPWCxNQUFNTSxJQUFJO0lBQzdDO0lBQ0EsSUFBSSxPQUFPTixVQUFVLFVBQVU7UUFDM0JBLFFBQVEsSUFBSUssTUFBTUw7SUFDdEI7SUFDQSxJQUFJLE9BQU9HLGFBQWEsWUFBWTtRQUNoQ0EsU0FBU0gsT0FBT0k7SUFDcEI7SUFDQSxJQUFJLE9BQU9GLFdBQVcsWUFBWTtRQUM5QiwyREFBMkQ7UUFDM0QsaUVBQWlFO1FBQ2pFLElBQUlELFdBQ0MsT0FBT0EsUUFBUVcsU0FBUyxLQUFLLGNBQzFCWCxRQUFR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aEgsTUFBTWdILE9BQU87SUFDdEJDLFVBQVVqSCxNQUFNa0gsUUFBUTtJQUN4QkEsVUFBVWxILE1BQU1rSCxRQUFRO0lBQ3hCQyxrQkFBa0JuSCxNQUFNbUgsZ0JBQWdCO0lBQ3hDQyxTQUFTcEgsTUFBTW9ILE9BQU87SUFDdEJDLDhCQUE4QnJILE1BQU1xSCw0QkFBNEI7SUFDaEVDLDBCQUEwQnRILE1BQU1zSCx3QkFBd0I7SUFDeERDLFNBQVN2SCxNQUFNdUgsT0FBTztJQUN0QkMsZ0JBQWdCeEgsTUFBTXdILGNBQWM7SUFDcENDLFdBQVd6SCxNQUFNeUgsU0FBUztJQUMxQjlDLHFCQUFxQkE7SUFDckIrQyxVQUFVMUgsTUFBTTBILFFBQVE7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvaW5kZXguanM/MTdhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbi8qKlxuICogQGZpbGUgdXRpbHMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQHBhcml0eS5pbz5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xudmFyIGV0aGpzVW5pdCA9IHJlcXVpcmUoJ2V0aGpzLXVuaXQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMuanMnKTtcbnZhciBzb2xpZGl0eVNoYTMgPSByZXF1aXJlKCcuL3NvbGlkaXR5U2hhMy5qcycpO1xudmFyIHJhbmRvbWJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG4vKipcbiAqIEZpcmVzIGFuIGVycm9yIGluIGFuIGV2ZW50IGVtaXR0ZXIgYW5kIGNhbGxiYWNrIGFuZCByZXR1cm5zIHRoZSBldmVudGVtaXR0ZXJcbiAqXG4gKiBAbWV0aG9kIF9maXJlRXJyb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBhIHN0cmluZywgYSBlcnJvciwgb3IgYW4gb2JqZWN0IHdpdGgge21lc3NhZ2UsIGRhdGF9XG4gKiBAcGFyYW0ge09iamVjdH0gZW1pdHRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHthbnl9IG9wdGlvbmFsRGF0YVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZW1pdHRlclxuICovXG52YXIgX2ZpcmVFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZW1pdHRlciwgcmVqZWN0LCBjYWxsYmFjaywgb3B0aW9uYWxEYXRhKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogMTAgKi9cbiAgICAvLyBhZGQgZGF0YSBpZiBnaXZlblxuICAgIGlmICghIWVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSAmJiBlcnJvci5kYXRhKSB7XG4gICAgICAgIGlmICghIWVycm9yLmRhdGEgJiYgdHlwZW9mIGVycm9yLmRhdGEgPT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZXJyb3IuZGF0YSkpIHtcbiAgICAgICAgICAgIGVycm9yLmRhdGEgPSBKU09OLnN0cmluZ2lmeShlcnJvci5kYXRhLCBudWxsLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciA9IGVycm9yLm1lc3NhZ2UgKyBcIlxcblwiICsgZXJyb3IuZGF0YTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCBvcHRpb25hbERhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBzdXBwcmVzcyB1bmNhdGNoZWQgZXJyb3IgaWYgYW4gZXJyb3IgbGlzdGVuZXIgaXMgcHJlc2VudFxuICAgICAgICAvLyBPUiBzdXBwcmVzcyB1bmNhdGNoZWQgZXJyb3IgaWYgYW4gY2FsbGJhY2sgbGlzdGVuZXIgaXMgcHJlc2VudFxuICAgICAgICBpZiAoZW1pdHRlciAmJlxuICAgICAgICAgICAgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIGVtaXR0ZXIubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVqZWN0IGxhdGVyLCB0byBiZSBhYmxlIHRvIHJldHVybiBlbWl0dGVyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuICAgIGlmIChlbWl0dGVyICYmIHR5cGVvZiBlbWl0dGVyLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gZW1pdCBsYXRlciwgdG8gYmUgYWJsZSB0byByZXR1cm4gZW1pdHRlclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnJvciwgb3B0aW9uYWxEYXRhKTtcbiAgICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH0sIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZW1pdHRlcjtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBmdWxsIGZ1bmN0aW9uL2V2ZW50IG5hbWUgZnJvbSBqc29uIGFiaVxuICpcbiAqIEBtZXRob2QgX2pzb25JbnRlcmZhY2VNZXRob2RUb1N0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEByZXR1cm4ge1N0cmluZ30gZnVsbCBmdW5jdGlvbi9ldmVudCBuYW1lXG4gKi9cbnZhciBfanNvbkludGVyZmFjZU1ldGhvZFRvU3RyaW5nID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICBpZiAoISFqc29uICYmIHR5cGVvZiBqc29uID09PSAnb2JqZWN0JyAmJiBqc29uLm5hbWUgJiYganNvbi5uYW1lLmluZGV4T2YoJygnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGpzb24ubmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb24ubmFtZSArICcoJyArIF9mbGF0dGVuVHlwZXMoZmFsc2UsIGpzb24uaW5wdXRzKS5qb2luKCcsJykgKyAnKSc7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmbGF0dGVuIGpzb24gYWJpIGlucHV0cy9vdXRwdXRzIGludG8gYW4gYXJyYXkgb2YgdHlwZS1yZXByZXNlbnRpbmctc3RyaW5nc1xuICpcbiAqIEBtZXRob2QgX2ZsYXR0ZW5UeXBlc1xuICogQHBhcmFtIHtib29sfSBpbmNsdWRlVHVwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwdXRzXG4gKiBAcmV0dXJuIHtBcnJheX0gcGFyYW1ldGVycyBhcyBzdHJpbmdzXG4gKi9cbnZhciBfZmxhdHRlblR5cGVzID0gZnVuY3Rpb24gKGluY2x1ZGVUdXBsZSwgcHV0cykge1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZW50ZXJlZCBfZmxhdHRlblR5cGVzLiBpbnB1dHMvb3V0cHV0czogXCIgKyBwdXRzKVxuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIHB1dHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbS5jb21wb25lbnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUuc3Vic3RyaW5nKDAsIDUpICE9PSAndHVwbGUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb25lbnRzIGZvdW5kIGJ1dCB0eXBlIGlzIG5vdCB0dXBsZTsgcmVwb3J0IG9uIEdpdEh1YicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgdmFyIGFycmF5QnJhY2tldCA9IHBhcmFtLnR5cGUuaW5kZXhPZignWycpO1xuICAgICAgICAgICAgaWYgKGFycmF5QnJhY2tldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gcGFyYW0udHlwZS5zdWJzdHJpbmcoYXJyYXlCcmFja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfZmxhdHRlblR5cGVzKGluY2x1ZGVUdXBsZSwgcGFyYW0uY29tcG9uZW50cyk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJlc3VsdCBzaG91bGQgaGF2ZSB0aGluZ3M6IFwiICsgcmVzdWx0KVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiBpbmNsdWRlVHVwbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImluY2x1ZGUgdHVwbGUgd29yZCwgYW5kIGl0cyBhbiBhcnJheS4gam9pbmluZy4uLjogXCIgKyByZXN1bHQudHlwZXMpXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgndHVwbGUoJyArIHJlc3VsdC5qb2luKCcsJykgKyAnKScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVUdXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZG9uJ3QgaW5jbHVkZSB0dXBsZSwgYnV0IGl0cyBhbiBhcnJheS4gam9pbmluZy4uLjogXCIgKyByZXN1bHQpXG4gICAgICAgICAgICAgICAgdHlwZXMucHVzaCgnKCcgKyByZXN1bHQuam9pbignLCcpICsgJyknICsgc3VmZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaXRzIGEgc2luZ2xlIHR5cGUgd2l0aGluIGEgdHVwbGU6IFwiICsgcmVzdWx0LnR5cGVzKVxuICAgICAgICAgICAgICAgIHR5cGVzLnB1c2goJygnICsgcmVzdWx0ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiaXRzIGEgdHlwZSBhbmQgbm90IGRpcmVjdGx5IGluIGEgdHVwbGU6IFwiICsgcGFyYW0udHlwZSlcbiAgICAgICAgICAgIHR5cGVzLnB1c2gocGFyYW0udHlwZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZXM7XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGhleCBzdHJpbmcgYnkgdGhlIGdpdmVuIGJ5dGVzIHNpemVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xudmFyIHJhbmRvbUhleCA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuICcweCcgKyByYW5kb21ieXRlcyhzaXplKS50b1N0cmluZygnaGV4Jyk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCBoZXhUb0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbnZhciBoZXhUb0FzY2lpID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGlmICghdXRpbHMuaXNIZXhTdHJpY3QoaGV4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFyYW1ldGVyIG11c3QgYmUgYSB2YWxpZCBIRVggc3RyaW5nLicpO1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMCwgbCA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICAgICAgaSA9IDI7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgYXNjaWlUb0hleFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgYXNjaWlUb0hleCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoIXN0cilcbiAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuICAgIHZhciBoZXggPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGhleDtcbn07XG4vKipcbiAqIFJldHVybnMgdmFsdWUgb2YgdW5pdCBpbiBXZWlcbiAqXG4gKiBAbWV0aG9kIGdldFVuaXRWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCB0bywgZGVmYXVsdCBldGhlclxuICogQHJldHVybnMge0JOfSB2YWx1ZSBvZiB0aGUgdW5pdCAoaW4gV2VpKVxuICogQHRocm93cyBlcnJvciBpZiB0aGUgdW5pdCBpcyBub3QgY29ycmVjdDp3XG4gKi9cbnZhciBnZXRVbml0VmFsdWUgPSBmdW5jdGlvbiAodW5pdCkge1xuICAgIHVuaXQgPSB1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogJ2V0aGVyJztcbiAgICBpZiAoIWV0aGpzVW5pdC51bml0TWFwW3VuaXRdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IFwiJyArIHVuaXQgKyAnXCIgZG9lc25cXCd0IGV4aXN0LCBwbGVhc2UgdXNlIHRoZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB1bml0cycgKyBKU09OLnN0cmluZ2lmeShldGhqc1VuaXQudW5pdE1hcCwgbnVsbCwgMikpO1xuICAgIH1cbiAgICByZXR1cm4gdW5pdDtcbn07XG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIHdlaSBhbmQgY29udmVydHMgaXQgdG8gYW55IG90aGVyIGV0aGVyIHVuaXQuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIGZyb21XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9IFdoZW4gZ2l2ZW4gYSBCTiBvYmplY3QgaXQgcmV0dXJucyBvbmUgYXMgd2VsbCwgb3RoZXJ3aXNlIGEgbnVtYmVyXG4gKi9cbnZhciBmcm9tV2VpID0gZnVuY3Rpb24gKG51bWJlciwgdW5pdCkge1xuICAgIHVuaXQgPSBnZXRVbml0VmFsdWUodW5pdCk7XG4gICAgaWYgKCF1dGlscy5pc0JOKG51bWJlcikgJiYgISh0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBudW1iZXJzIGFzIHN0cmluZ3Mgb3IgQk4gb2JqZWN0cyB0byBhdm9pZCBwcmVjaXNpb24gZXJyb3JzLicpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuaXNCTihudW1iZXIpID8gZXRoanNVbml0LmZyb21XZWkobnVtYmVyLCB1bml0KSA6IGV0aGpzVW5pdC5mcm9tV2VpKG51bWJlciwgdW5pdCkudG9TdHJpbmcoMTApO1xufTtcbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYSB1bml0IGFuZCBjb252ZXJ0cyBpdCB0byB3ZWkuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIHRvV2VpXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8Qk59IG51bWJlciBjYW4gYmUgYSBudW1iZXIsIG51bWJlciBzdHJpbmcgb3IgYSBIRVggb2YgYSBkZWNpbWFsXG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pdCB0aGUgdW5pdCB0byBjb252ZXJ0IGZyb20sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9IFdoZW4gZ2l2ZW4gYSBCTiBvYmplY3QgaXQgcmV0dXJucyBvbmUgYXMgd2VsbCwgb3RoZXJ3aXNlIGEgbnVtYmVyXG4gKi9cbnZhciB0b1dlaSA9IGZ1bmN0aW9uIChudW1iZXIsIHVuaXQpIHtcbiAgICB1bml0ID0gZ2V0VW5pdFZhbHVlKHVuaXQpO1xuICAgIGlmICghdXRpbHMuaXNCTihudW1iZXIpICYmICEodHlwZW9mIG51bWJlciA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgbnVtYmVycyBhcyBzdHJpbmdzIG9yIEJOIG9iamVjdHMgdG8gYXZvaWQgcHJlY2lzaW9uIGVycm9ycy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmlzQk4obnVtYmVyKSA/IGV0aGpzVW5pdC50b1dlaShudW1iZXIsIHVuaXQpIDogZXRoanNVbml0LnRvV2VpKG51bWJlciwgdW5pdCkudG9TdHJpbmcoMTApO1xufTtcbi8qKlxuICogQ29udmVydHMgdG8gYSBjaGVja3N1bSBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCB0b0NoZWNrc3VtQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZGRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciB0b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezQwfSQvaS50ZXN0KGFkZHJlc3MpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIGFkZHJlc3MgXCInICsgYWRkcmVzcyArICdcIiBpcyBub3QgYSB2YWxpZCBFdGhlcmV1bSBhZGRyZXNzLicpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXjB4L2ksICcnKTtcbiAgICB2YXIgYWRkcmVzc0hhc2ggPSB1dGlscy5zaGEzKGFkZHJlc3MpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgdmFyIGNoZWNrc3VtQWRkcmVzcyA9ICcweCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIElmIGl0aCBjaGFyYWN0ZXIgaXMgOCB0byBmIHRoZW4gbWFrZSBpdCB1cHBlcmNhc2VcbiAgICAgICAgaWYgKHBhcnNlSW50KGFkZHJlc3NIYXNoW2ldLCAxNikgPiA3KSB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtQWRkcmVzcztcbn07XG4vKipcbiAqIFJldHVybnMgLTEgaWYgYTxiLCAxIGlmIGE+YjsgMCBpZiBhID09IGIuXG4gKiBGb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgdHlwZSBvZiBmdW5jdGlvbiwgc2VlXG4gKiBkZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFxuICogQmxvY2sgdGFnIGBzYWZlYCBhbmQgYGJsb2NrIG51bWJlcmAgY29tYmluYXRpb24gcGFyYW0gaXMgbm90IHN1cHBvcnRlZFxuICogQG1ldGhvZCBjb21wYXJlQmxvY2tOdW1iZXJzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSBhXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfSBiXG4gKlxuICogQHJldHVybnMge051bWJlcn0gLTEsIDAsIG9yIDFcbiAqL1xudmFyIGNvbXBhcmVCbG9ja051bWJlcnMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIEluY3JlYXNpbmcgb3JkZXI6IChnZW5lc2lzID0gZWFybGllc3QpLCBzYWZlLCAoZmluYWxpemVkIH4gbGF0ZXN0KSwgcGVuZGluZ1xuICAgIC8vIHNhZmUgdnMgYmxvY2stbnVtIGNhbnQgYmUgY29tcGFyZWQgYXMgYmxvY2sgbnVtYmVyIHByb3ZpZGVkIGNhbiBiZSBvbiBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2Ygc2FmZSB0YWcsIHVudGlsIHNhZmUgdGFnIGJsb2NrIG51bWJlciBpcyBleHRyYWN0ZWQgYW5kIGNvbXBhcmVkXG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKChcImdlbmVzaXNcIiA9PT0gYSB8fCBcImVhcmxpZXN0XCIgPT09IGEgfHwgMCA9PT0gYSkgJiYgKFwiZ2VuZXNpc1wiID09PSBiIHx8IFwiZWFybGllc3RcIiA9PT0gYiB8fCAwID09PSBiKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJnZW5lc2lzXCIgPT09IGEgfHwgXCJlYXJsaWVzdFwiID09PSBhIHx8IGEgPT09IDApIHtcbiAgICAgICAgLy8gYiAhPT0gYSwgdGh1cyBhIDwgYlxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKFwiZ2VuZXNpc1wiID09PSBiIHx8IFwiZWFybGllc3RcIiA9PT0gYiB8fCBiID09PSAwKSB7XG4gICAgICAgIC8vIGIgIT09IGEsIHRodXMgYSA+IGJcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT09IFwibGF0ZXN0XCIgfHwgYSA9PT0gXCJmaW5hbGl6ZWRcIikge1xuICAgICAgICBpZiAoYiA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGIgIT09IChcInBlbmRpbmdcIiBPUiBcImxhdGVzdFwiKSwgdGh1cyBhID4gYlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYiA9PT0gXCJsYXRlc3RcIiB8fCBiID09PSBcImZpbmFsaXplZFwiKSB7XG4gICAgICAgIGlmIChhID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBiICE9PSAoXCJwZW5kaW5nXCIgT1IgXCJsYXRlc3RcIiksIHRodXMgYSA+IGJcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAvLyBiICg9PSBPUiA8KSBcImxhdGVzdFwiLCB0aHVzIGEgPiBiXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChiID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPT09IFwic2FmZVwiIHx8IGIgPT09IFwic2FmZVwiKSB7XG4gICAgICAgIC8vIGVpdGhlciBhIG9yIGIgaXMgXCJzYWZlXCIgYW5kIHRoZSBvdGhlciBvbmUgZGlkIG5vdCBmYWxsIGludG8gYW55IG9mIHRoZSBjb25kaXRpb25zIGFib3ZlLCBzbyB0aGUgb3RoZXIgb25lIGlzIGEgbnVtYmVyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgYm5BID0gbmV3IEJOKGEpO1xuICAgICAgICBsZXQgYm5CID0gbmV3IEJOKGIpO1xuICAgICAgICBpZiAoYm5BLmx0KGJuQikpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibkEuZXEoYm5CKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBfZmlyZUVycm9yOiBfZmlyZUVycm9yLFxuICAgIF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmc6IF9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmcsXG4gICAgX2ZsYXR0ZW5UeXBlczogX2ZsYXR0ZW5UeXBlcyxcbiAgICAvLyBleHRyYWN0RGlzcGxheU5hbWU6IGV4dHJhY3REaXNwbGF5TmFtZSxcbiAgICAvLyBleHRyYWN0VHlwZU5hbWU6IGV4dHJhY3RUeXBlTmFtZSxcbiAgICByYW5kb21IZXg6IHJhbmRvbUhleCxcbiAgICBCTjogdXRpbHMuQk4sXG4gICAgaXNCTjogdXRpbHMuaXNCTixcbiAgICBpc0JpZ051bWJlcjogdXRpbHMuaXNCaWdOdW1iZXIsXG4gICAgaXNIZXg6IHV0aWxzLmlzSGV4LFxuICAgIGlzSGV4U3RyaWN0OiB1dGlscy5pc0hleFN0cmljdCxcbiAgICBzaGEzOiB1dGlscy5zaGEzLFxuICAgIHNoYTNSYXc6IHV0aWxzLnNoYTNSYXcsXG4gICAga2VjY2FrMjU2OiB1dGlscy5zaGEzLFxuICAgIHNvbGlkaXR5U2hhMzogc29saWRpdHlTaGEzLnNvbGlkaXR5U2hhMyxcbiAgICBzb2xpZGl0eVNoYTNSYXc6IHNvbGlkaXR5U2hhMy5zb2xpZGl0eVNoYTNSYXcsXG4gICAgZW5jb2RlUGFja2VkOiBzb2xpZGl0eVNoYTMuZW5jb2RlUGFja2VkLFxuICAgIGlzQWRkcmVzczogdXRpbHMuaXNBZGRyZXNzLFxuICAgIGNoZWNrQWRkcmVzc0NoZWNrc3VtOiB1dGlscy5jaGVja0FkZHJlc3NDaGVja3N1bSxcbiAgICB0b0NoZWNrc3VtQWRkcmVzczogdG9DaGVja3N1bUFkZHJlc3MsXG4gICAgdG9IZXg6IHV0aWxzLnRvSGV4LFxuICAgIHRvQk46IHV0aWxzLnRvQk4sXG4gICAgYnl0ZXNUb0hleDogdXRpbHMuYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzOiB1dGlscy5oZXhUb0J5dGVzLFxuICAgIGhleFRvTnVtYmVyU3RyaW5nOiB1dGlscy5oZXhUb051bWJlclN0cmluZyxcbiAgICBoZXhUb051bWJlcjogdXRpbHMuaGV4VG9OdW1iZXIsXG4gICAgdG9EZWNpbWFsOiB1dGlscy5oZXhUb051bWJlcixcbiAgICBudW1iZXJUb0hleDogdXRpbHMubnVtYmVyVG9IZXgsXG4gICAgZnJvbURlY2ltYWw6IHV0aWxzLm51bWJlclRvSGV4LFxuICAgIGhleFRvVXRmODogdXRpbHMuaGV4VG9VdGY4LFxuICAgIGhleFRvU3RyaW5nOiB1dGlscy5oZXhUb1V0ZjgsXG4gICAgdG9VdGY4OiB1dGlscy5oZXhUb1V0ZjgsXG4gICAgc3RyaXBIZXhQcmVmaXg6IHV0aWxzLnN0cmlwSGV4UHJlZml4LFxuICAgIHV0ZjhUb0hleDogdXRpbHMudXRmOFRvSGV4LFxuICAgIHN0cmluZ1RvSGV4OiB1dGlscy51dGY4VG9IZXgsXG4gICAgZnJvbVV0Zjg6IHV0aWxzLnV0ZjhUb0hleCxcbiAgICBoZXhUb0FzY2lpOiBoZXhUb0FzY2lpLFxuICAgIHRvQXNjaWk6IGhleFRvQXNjaWksXG4gICAgYXNjaWlUb0hleDogYXNjaWlUb0hleCxcbiAgICBmcm9tQXNjaWk6IGFzY2lpVG9IZXgsXG4gICAgdW5pdE1hcDogZXRoanNVbml0LnVuaXRNYXAsXG4gICAgdG9XZWk6IHRvV2VpLFxuICAgIGZyb21XZWk6IGZyb21XZWksXG4gICAgcGFkTGVmdDogdXRpbHMubGVmdFBhZCxcbiAgICBsZWZ0UGFkOiB1dGlscy5sZWZ0UGFkLFxuICAgIHBhZFJpZ2h0OiB1dGlscy5yaWdodFBhZCxcbiAgICByaWdodFBhZDogdXRpbHMucmlnaHRQYWQsXG4gICAgdG9Ud29zQ29tcGxlbWVudDogdXRpbHMudG9Ud29zQ29tcGxlbWVudCxcbiAgICBpc0Jsb29tOiB1dGlscy5pc0Jsb29tLFxuICAgIGlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb206IHV0aWxzLmlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20sXG4gICAgaXNDb250cmFjdEFkZHJlc3NJbkJsb29tOiB1dGlscy5pc0NvbnRyYWN0QWRkcmVzc0luQmxvb20sXG4gICAgaXNUb3BpYzogdXRpbHMuaXNUb3BpYyxcbiAgICBpc1RvcGljSW5CbG9vbTogdXRpbHMuaXNUb3BpY0luQmxvb20sXG4gICAgaXNJbkJsb29tOiB1dGlscy5pc0luQmxvb20sXG4gICAgY29tcGFyZUJsb2NrTnVtYmVyczogY29tcGFyZUJsb2NrTnVtYmVycyxcbiAgICB0b051bWJlcjogdXRpbHMudG9OdW1iZXJcbn07XG4iXSwibmFtZXMiOlsiZXRoanNVbml0IiwicmVxdWlyZSIsInV0aWxzIiwic29saWRpdHlTaGEzIiwicmFuZG9tYnl0ZXMiLCJCTiIsIl9maXJlRXJyb3IiLCJlcnJvciIsImVtaXR0ZXIiLCJyZWplY3QiLCJjYWxsYmFjayIsIm9wdGlvbmFsRGF0YSIsIkVycm9yIiwiZGF0YSIsIkFycmF5IiwiaXNBcnJheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIiwibGlzdGVuZXJzIiwibGVuZ3RoIiwiY2F0Y2giLCJzZXRUaW1lb3V0IiwiZW1pdCIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmciLCJqc29uIiwibmFtZSIsImluZGV4T2YiLCJfZmxhdHRlblR5cGVzIiwiaW5wdXRzIiwiam9pbiIsImluY2x1ZGVUdXBsZSIsInB1dHMiLCJ0eXBlcyIsImZvckVhY2giLCJwYXJhbSIsImNvbXBvbmVudHMiLCJ0eXBlIiwic3Vic3RyaW5nIiwic3VmZml4IiwiYXJyYXlCcmFja2V0IiwicmVzdWx0IiwicHVzaCIsInJhbmRvbUhleCIsInNpemUiLCJ0b1N0cmluZyIsImhleFRvQXNjaWkiLCJoZXgiLCJpc0hleFN0cmljdCIsInN0ciIsImkiLCJsIiwiY29kZSIsInBhcnNlSW50Iiwic2xpY2UiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhc2NpaVRvSGV4IiwiY2hhckNvZGVBdCIsIm4iLCJnZXRVbml0VmFsdWUiLCJ1bml0IiwidG9Mb3dlckNhc2UiLCJ1bml0TWFwIiwiZnJvbVdlaSIsIm51bWJlciIsImlzQk4iLCJ0b1dlaSIsInRvQ2hlY2tzdW1BZGRyZXNzIiwiYWRkcmVzcyIsInRlc3QiLCJyZXBsYWNlIiwiYWRkcmVzc0hhc2giLCJzaGEzIiwiY2hlY2tzdW1BZGRyZXNzIiwidG9VcHBlckNhc2UiLCJjb21wYXJlQmxvY2tOdW1iZXJzIiwiYSIsImIiLCJ1bmRlZmluZWQiLCJibkEiLCJibkIiLCJsdCIsImVxIiwibW9kdWxlIiwiZXhwb3J0cyIsImlzQmlnTnVtYmVyIiwiaXNIZXgiLCJzaGEzUmF3Iiwia2VjY2FrMjU2Iiwic29saWRpdHlTaGEzUmF3IiwiZW5jb2RlUGFja2VkIiwiaXNBZGRyZXNzIiwiY2hlY2tBZGRyZXNzQ2hlY2tzdW0iLCJ0b0hleCIsInRvQk4iLCJieXRlc1RvSGV4IiwiaGV4VG9CeXRlcyIsImhleFRvTnVtYmVyU3RyaW5nIiwiaGV4VG9OdW1iZXIiLCJ0b0RlY2ltYWwiLCJudW1iZXJUb0hleCIsImZyb21EZWNpbWFsIiwiaGV4VG9VdGY4IiwiaGV4VG9TdHJpbmciLCJ0b1V0ZjgiLCJzdHJpcEhleFByZWZpeCIsInV0ZjhUb0hleCIsInN0cmluZ1RvSGV4IiwiZnJvbVV0ZjgiLCJ0b0FzY2lpIiwiZnJvbUFzY2lpIiwicGFkTGVmdCIsImxlZnRQYWQiLCJwYWRSaWdodCIsInJpZ2h0UGFkIiwidG9Ud29zQ29tcGxlbWVudCIsImlzQmxvb20iLCJpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tIiwiaXNDb250cmFjdEFkZHJlc3NJbkJsb29tIiwiaXNUb3BpYyIsImlzVG9waWNJbkJsb29tIiwiaXNJbkJsb29tIiwidG9OdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/lib/soliditySha3.js":
/*!*****************************************************!*\
  !*** ./node_modules/web3-utils/lib/soliditySha3.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file soliditySha3.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar utils = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/lib/utils.js\");\nvar _elementaryName = function(name) {\n    /*jshint maxcomplexity:false */ if (name.startsWith(\"int[\")) {\n        return \"int256\" + name.slice(3);\n    } else if (name === \"int\") {\n        return \"int256\";\n    } else if (name.startsWith(\"uint[\")) {\n        return \"uint256\" + name.slice(4);\n    } else if (name === \"uint\") {\n        return \"uint256\";\n    } else if (name.startsWith(\"fixed[\")) {\n        return \"fixed128x128\" + name.slice(5);\n    } else if (name === \"fixed\") {\n        return \"fixed128x128\";\n    } else if (name.startsWith(\"ufixed[\")) {\n        return \"ufixed128x128\" + name.slice(6);\n    } else if (name === \"ufixed\") {\n        return \"ufixed128x128\";\n    }\n    return name;\n};\n// Parse N from type<N>\nvar _parseTypeN = function(type) {\n    var typesize = /^\\D+(\\d+).*$/.exec(type);\n    return typesize ? parseInt(typesize[1], 10) : null;\n};\n// Parse N from type[<N>]\nvar _parseTypeNArray = function(type) {\n    var arraySize = /^\\D+\\d*\\[(\\d+)\\]$/.exec(type);\n    return arraySize ? parseInt(arraySize[1], 10) : null;\n};\nvar _parseNumber = function(arg) {\n    var type = typeof arg;\n    if (type === \"string\") {\n        if (utils.isHexStrict(arg)) {\n            return new BN(arg.replace(/0x/i, \"\"), 16);\n        } else {\n            return new BN(arg, 10);\n        }\n    } else if (type === \"number\") {\n        return new BN(arg);\n    } else if (utils.isBigNumber(arg)) {\n        return new BN(arg.toString(10));\n    } else if (utils.isBN(arg)) {\n        return arg;\n    } else {\n        throw new Error(arg + \" is not a number\");\n    }\n};\nvar _solidityPack = function(type, value, arraySize) {\n    /*jshint maxcomplexity:false */ var size, num;\n    type = _elementaryName(type);\n    if (type === \"bytes\") {\n        if (value.replace(/^0x/i, \"\").length % 2 !== 0) {\n            throw new Error(\"Invalid bytes characters \" + value.length);\n        }\n        return value;\n    } else if (type === \"string\") {\n        return utils.utf8ToHex(value);\n    } else if (type === \"bool\") {\n        return value ? \"01\" : \"00\";\n    } else if (type.startsWith(\"address\")) {\n        if (arraySize) {\n            size = 64;\n        } else {\n            size = 40;\n        }\n        if (!utils.isAddress(value)) {\n            throw new Error(value + \" is not a valid address, or the checksum is invalid.\");\n        }\n        return utils.leftPad(value.toLowerCase(), size);\n    }\n    size = _parseTypeN(type);\n    if (type.startsWith(\"bytes\")) {\n        if (!size) {\n            throw new Error(\"bytes[] not yet supported in solidity\");\n        }\n        // must be 32 byte slices when in an array\n        if (arraySize) {\n            size = 32;\n        }\n        if (size < 1 || size > 32 || size < value.replace(/^0x/i, \"\").length / 2) {\n            throw new Error(\"Invalid bytes\" + size + \" for \" + value);\n        }\n        return utils.rightPad(value, size * 2);\n    } else if (type.startsWith(\"uint\")) {\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid uint\" + size + \" size\");\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied uint exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            throw new Error(\"Supplied uint \" + num.toString() + \" is negative\");\n        }\n        return size ? utils.leftPad(num.toString(\"hex\"), size / 8 * 2) : num;\n    } else if (type.startsWith(\"int\")) {\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid int\" + size + \" size\");\n        }\n        num = _parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied int exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        if (num.lt(new BN(0))) {\n            return num.toTwos(size).toString(\"hex\");\n        } else {\n            return size ? utils.leftPad(num.toString(\"hex\"), size / 8 * 2) : num;\n        }\n    } else {\n        // FIXME: support all other types\n        throw new Error(\"Unsupported or invalid type: \" + type);\n    }\n};\nvar _processSolidityEncodePackedArgs = function(arg) {\n    /*jshint maxcomplexity:false */ if (Array.isArray(arg)) {\n        throw new Error(\"Autodetection of array types is not supported.\");\n    }\n    var type, value = \"\";\n    var hexArg, arraySize;\n    // if type is given\n    if (!!arg && typeof arg === \"object\" && (arg.hasOwnProperty(\"v\") || arg.hasOwnProperty(\"t\") || arg.hasOwnProperty(\"value\") || arg.hasOwnProperty(\"type\"))) {\n        type = arg.hasOwnProperty(\"t\") ? arg.t : arg.type;\n        value = arg.hasOwnProperty(\"v\") ? arg.v : arg.value;\n    // otherwise try to guess the type\n    } else {\n        type = utils.toHex(arg, true);\n        value = utils.toHex(arg);\n        if (!type.startsWith(\"int\") && !type.startsWith(\"uint\")) {\n            type = \"bytes\";\n        }\n    }\n    if ((type.startsWith(\"int\") || type.startsWith(\"uint\")) && typeof value === \"string\" && !/^(-)?0x/i.test(value)) {\n        value = new BN(value);\n    }\n    // get the array size\n    if (Array.isArray(value)) {\n        arraySize = _parseTypeNArray(type);\n        if (arraySize && value.length !== arraySize) {\n            throw new Error(type + \" is not matching the given array \" + JSON.stringify(value));\n        } else {\n            arraySize = value.length;\n        }\n    }\n    if (Array.isArray(value)) {\n        hexArg = value.map(function(val) {\n            return _solidityPack(type, val, arraySize).toString(\"hex\").replace(\"0x\", \"\");\n        });\n        return hexArg.join(\"\");\n    } else {\n        hexArg = _solidityPack(type, value, arraySize);\n        return hexArg.toString(\"hex\").replace(\"0x\", \"\");\n    }\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256\n *\n * @method soliditySha3\n * @return {Object} the sha3\n */ var soliditySha3 = function() {\n    /*jshint maxcomplexity:false */ var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    // console.log(args, hexArgs);\n    // console.log('0x'+ hexArgs.join(''));\n    return utils.sha3(\"0x\" + hexArgs.join(\"\"));\n};\n/**\n * Hashes solidity values to a sha3 hash using keccak 256 but does return the hash of value `null` instead of `null`\n *\n * @method soliditySha3Raw\n * @return {Object} the sha3\n */ var soliditySha3Raw = function() {\n    return utils.sha3Raw(\"0x\" + Array.prototype.slice.call(arguments).map(_processSolidityEncodePackedArgs).join(\"\"));\n};\n/**\n * Encode packed args to hex\n *\n * @method encodePacked\n * @return {String} the hex encoded arguments\n */ var encodePacked = function() {\n    /*jshint maxcomplexity:false */ var args = Array.prototype.slice.call(arguments);\n    var hexArgs = args.map(_processSolidityEncodePackedArgs);\n    return \"0x\" + hexArgs.join(\"\").toLowerCase();\n};\nmodule.exports = {\n    soliditySha3: soliditySha3,\n    soliditySha3Raw: soliditySha3Raw,\n    encodePacked: encodePacked\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvc29saWRpdHlTaGEzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEOzs7O0NBSUM7QUFDRCxJQUFJQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNqQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxrQkFBa0IsU0FBVUMsSUFBSTtJQUNoQyw2QkFBNkIsR0FDN0IsSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFNBQVM7UUFDekIsT0FBTyxXQUFXRCxLQUFLRSxLQUFLLENBQUM7SUFDakMsT0FDSyxJQUFJRixTQUFTLE9BQU87UUFDckIsT0FBTztJQUNYLE9BQ0ssSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFVBQVU7UUFDL0IsT0FBTyxZQUFZRCxLQUFLRSxLQUFLLENBQUM7SUFDbEMsT0FDSyxJQUFJRixTQUFTLFFBQVE7UUFDdEIsT0FBTztJQUNYLE9BQ0ssSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFdBQVc7UUFDaEMsT0FBTyxpQkFBaUJELEtBQUtFLEtBQUssQ0FBQztJQUN2QyxPQUNLLElBQUlGLFNBQVMsU0FBUztRQUN2QixPQUFPO0lBQ1gsT0FDSyxJQUFJQSxLQUFLQyxVQUFVLENBQUMsWUFBWTtRQUNqQyxPQUFPLGtCQUFrQkQsS0FBS0UsS0FBSyxDQUFDO0lBQ3hDLE9BQ0ssSUFBSUYsU0FBUyxVQUFVO1FBQ3hCLE9BQU87SUFDWDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSx1QkFBdUI7QUFDdkIsSUFBSUcsY0FBYyxTQUFVQyxJQUFJO0lBQzVCLElBQUlDLFdBQVcsZUFBZUMsSUFBSSxDQUFDRjtJQUNuQyxPQUFPQyxXQUFXRSxTQUFTRixRQUFRLENBQUMsRUFBRSxFQUFFLE1BQU07QUFDbEQ7QUFDQSx5QkFBeUI7QUFDekIsSUFBSUcsbUJBQW1CLFNBQVVKLElBQUk7SUFDakMsSUFBSUssWUFBWSxvQkFBb0JILElBQUksQ0FBQ0Y7SUFDekMsT0FBT0ssWUFB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QUlDLFVBQVVKLEtBQUtKLEdBQUcsQ0FBQ1g7SUFDdkIsOEJBQThCO0lBQzlCLHVDQUF1QztJQUN2QyxPQUFPakMsTUFBTXFELElBQUksQ0FBQyxPQUFPRCxRQUFRTixJQUFJLENBQUM7QUFDMUM7QUFDQTs7Ozs7Q0FLQyxHQUNELElBQUlRLGtCQUFrQjtJQUNsQixPQUFPdEQsTUFBTXVELE9BQU8sQ0FBQyxPQUFPckIsTUFBTWUsU0FBUyxDQUFDN0MsS0FBSyxDQUFDOEMsSUFBSSxDQUFDQyxXQUFXUCxHQUFHLENBQUNYLGtDQUFrQ2EsSUFBSSxDQUFDO0FBQ2pIO0FBQ0E7Ozs7O0NBS0MsR0FDRCxJQUFJVSxlQUFlO0lBQ2YsNkJBQTZCLEdBQzdCLElBQUlSLE9BQU9kLE1BQU1lLFNBQVMsQ0FBQzdDLEtBQUssQ0FBQzhDLElBQUksQ0FBQ0M7SUFDdEMsSUFBSUMsVUFBVUosS0FBS0osR0FBRyxDQUFDWDtJQUN2QixPQUFPLE9BQU9tQixRQUFRTixJQUFJLENBQUMsSUFBSWxCLFdBQVc7QUFDOUM7QUFDQTZCLE9BQU9DLE9BQU8sR0FBRztJQUNiWCxjQUFjQTtJQUNkTyxpQkFBaUJBO0lBQ2pCRSxjQUFjQTtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL2xpYi9zb2xpZGl0eVNoYTMuanM/ZGE4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbi8qKlxuICogQGZpbGUgc29saWRpdHlTaGEzLmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzLmpzJyk7XG52YXIgX2VsZW1lbnRhcnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaW50WycpKSB7XG4gICAgICAgIHJldHVybiAnaW50MjU2JyArIG5hbWUuc2xpY2UoMyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpbnQnKSB7XG4gICAgICAgIHJldHVybiAnaW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1aW50WycpKSB7XG4gICAgICAgIHJldHVybiAndWludDI1NicgKyBuYW1lLnNsaWNlKDQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAndWludCcpIHtcbiAgICAgICAgcmV0dXJuICd1aW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaXhlZFsnKSkge1xuICAgICAgICByZXR1cm4gJ2ZpeGVkMTI4eDEyOCcgKyBuYW1lLnNsaWNlKDUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnZml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1Zml4ZWRbJykpIHtcbiAgICAgICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd1Zml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAndWZpeGVkMTI4eDEyOCc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufTtcbi8vIFBhcnNlIE4gZnJvbSB0eXBlPE4+XG52YXIgX3BhcnNlVHlwZU4gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB0eXBlc2l6ZSA9IC9eXFxEKyhcXGQrKS4qJC8uZXhlYyh0eXBlKTtcbiAgICByZXR1cm4gdHlwZXNpemUgPyBwYXJzZUludCh0eXBlc2l6ZVsxXSwgMTApIDogbnVsbDtcbn07XG4vLyBQYXJzZSBOIGZyb20gdHlwZVs8Tj5dXG52YXIgX3BhcnNlVHlwZU5BcnJheSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGFycmF5U2l6ZSA9IC9eXFxEK1xcZCpcXFsoXFxkKylcXF0kLy5leGVjKHR5cGUpO1xuICAgIHJldHVybiBhcnJheVNpemUgPyBwYXJzZUludChhcnJheVNpemVbMV0sIDEwKSA6IG51bGw7XG59O1xudmFyIF9wYXJzZU51bWJlciA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh1dGlscy5pc0hleFN0cmljdChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJOKGFyZy5yZXBsYWNlKC8weC9pLCAnJyksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQk4oYXJnLCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCTihhcmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlscy5pc0JpZ051bWJlcihhcmcpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQk4oYXJnLnRvU3RyaW5nKDEwKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxzLmlzQk4oYXJnKSkge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFyZyArICcgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgfVxufTtcbnZhciBfc29saWRpdHlQYWNrID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBhcnJheVNpemUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgdmFyIHNpemUsIG51bTtcbiAgICB0eXBlID0gX2VsZW1lbnRhcnlOYW1lKHR5cGUpO1xuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5yZXBsYWNlKC9eMHgvaSwgJycpLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlcyBjaGFyYWN0ZXJzICcgKyB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnV0ZjhUb0hleCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyAnMDEnIDogJzAwJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdhZGRyZXNzJykpIHtcbiAgICAgICAgaWYgKGFycmF5U2l6ZSkge1xuICAgICAgICAgICAgc2l6ZSA9IDY0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IDQwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbHMuaXNBZGRyZXNzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlICsgJyBpcyBub3QgYSB2YWxpZCBhZGRyZXNzLCBvciB0aGUgY2hlY2tzdW0gaXMgaW52YWxpZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMubGVmdFBhZCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCBzaXplKTtcbiAgICB9XG4gICAgc2l6ZSA9IF9wYXJzZVR5cGVOKHR5cGUpO1xuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J5dGVzW10gbm90IHlldCBzdXBwb3J0ZWQgaW4gc29saWRpdHknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtdXN0IGJlIDMyIGJ5dGUgc2xpY2VzIHdoZW4gaW4gYW4gYXJyYXlcbiAgICAgICAgaWYgKGFycmF5U2l6ZSkge1xuICAgICAgICAgICAgc2l6ZSA9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIgfHwgc2l6ZSA8IHZhbHVlLnJlcGxhY2UoL14weC9pLCAnJykubGVuZ3RoIC8gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGVzJyArIHNpemUgKyAnIGZvciAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5yaWdodFBhZCh2YWx1ZSwgc2l6ZSAqIDIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVpbnQnICsgc2l6ZSArICcgc2l6ZScpO1xuICAgICAgICB9XG4gICAgICAgIG51bSA9IF9wYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW0ubHQobmV3IEJOKDApKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50ICcgKyBudW0udG9TdHJpbmcoKSArICcgaXMgbmVnYXRpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZSA/IHV0aWxzLmxlZnRQYWQobnVtLnRvU3RyaW5nKCdoZXgnKSwgc2l6ZSAvIDggKiAyKSA6IG51bTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBpZiAoKHNpemUgJSA4KSB8fCAoc2l6ZSA8IDgpIHx8IChzaXplID4gMjU2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludCcgKyBzaXplICsgJyBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtID0gX3BhcnNlTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgaW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtLmx0KG5ldyBCTigwKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudW0udG9Ud29zKHNpemUpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplID8gdXRpbHMubGVmdFBhZChudW0udG9TdHJpbmcoJ2hleCcpLCBzaXplIC8gOCAqIDIpIDogbnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBhbGwgb3RoZXIgdHlwZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG59O1xudmFyIF9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzID0gZnVuY3Rpb24gKGFyZykge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0b2RldGVjdGlvbiBvZiBhcnJheSB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICB2YXIgdHlwZSwgdmFsdWUgPSAnJztcbiAgICB2YXIgaGV4QXJnLCBhcnJheVNpemU7XG4gICAgLy8gaWYgdHlwZSBpcyBnaXZlblxuICAgIGlmICghIWFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAoYXJnLmhhc093blByb3BlcnR5KCd2JykgfHwgYXJnLmhhc093blByb3BlcnR5KCd0JykgfHwgYXJnLmhhc093blByb3BlcnR5KCd2YWx1ZScpIHx8IGFyZy5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSkge1xuICAgICAgICB0eXBlID0gYXJnLmhhc093blByb3BlcnR5KCd0JykgPyBhcmcudCA6IGFyZy50eXBlO1xuICAgICAgICB2YWx1ZSA9IGFyZy5oYXNPd25Qcm9wZXJ0eSgndicpID8gYXJnLnYgOiBhcmcudmFsdWU7XG4gICAgICAgIC8vIG90aGVyd2lzZSB0cnkgdG8gZ3Vlc3MgdGhlIHR5cGVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSB1dGlscy50b0hleChhcmcsIHRydWUpO1xuICAgICAgICB2YWx1ZSA9IHV0aWxzLnRvSGV4KGFyZyk7XG4gICAgICAgIGlmICghdHlwZS5zdGFydHNXaXRoKCdpbnQnKSAmJiAhdHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYnl0ZXMnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgodHlwZS5zdGFydHNXaXRoKCdpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhL14oLSk/MHgvaS50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IG5ldyBCTih2YWx1ZSk7XG4gICAgfVxuICAgIC8vIGdldCB0aGUgYXJyYXkgc2l6ZVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcnJheVNpemUgPSBfcGFyc2VUeXBlTkFycmF5KHR5cGUpO1xuICAgICAgICBpZiAoYXJyYXlTaXplICYmIHZhbHVlLmxlbmd0aCAhPT0gYXJyYXlTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodHlwZSArICcgaXMgbm90IG1hdGNoaW5nIHRoZSBnaXZlbiBhcnJheSAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5U2l6ZSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaGV4QXJnID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBfc29saWRpdHlQYWNrKHR5cGUsIHZhbCwgYXJyYXlTaXplKS50b1N0cmluZygnaGV4JykucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGV4QXJnLmpvaW4oJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGV4QXJnID0gX3NvbGlkaXR5UGFjayh0eXBlLCB2YWx1ZSwgYXJyYXlTaXplKTtcbiAgICAgICAgcmV0dXJuIGhleEFyZy50b1N0cmluZygnaGV4JykucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgfVxufTtcbi8qKlxuICogSGFzaGVzIHNvbGlkaXR5IHZhbHVlcyB0byBhIHNoYTMgaGFzaCB1c2luZyBrZWNjYWsgMjU2XG4gKlxuICogQG1ldGhvZCBzb2xpZGl0eVNoYTNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNoYTNcbiAqL1xudmFyIHNvbGlkaXR5U2hhMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OmZhbHNlICovXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBoZXhBcmdzID0gYXJncy5tYXAoX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MpO1xuICAgIC8vIGNvbnNvbGUubG9nKGFyZ3MsIGhleEFyZ3MpO1xuICAgIC8vIGNvbnNvbGUubG9nKCcweCcrIGhleEFyZ3Muam9pbignJykpO1xuICAgIHJldHVybiB1dGlscy5zaGEzKCcweCcgKyBoZXhBcmdzLmpvaW4oJycpKTtcbn07XG4vKipcbiAqIEhhc2hlcyBzb2xpZGl0eSB2YWx1ZXMgdG8gYSBzaGEzIGhhc2ggdXNpbmcga2VjY2FrIDI1NiBidXQgZG9lcyByZXR1cm4gdGhlIGhhc2ggb2YgdmFsdWUgYG51bGxgIGluc3RlYWQgb2YgYG51bGxgXG4gKlxuICogQG1ldGhvZCBzb2xpZGl0eVNoYTNSYXdcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHNoYTNcbiAqL1xudmFyIHNvbGlkaXR5U2hhM1JhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuc2hhM1JhdygnMHgnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoX3Byb2Nlc3NTb2xpZGl0eUVuY29kZVBhY2tlZEFyZ3MpLmpvaW4oJycpKTtcbn07XG4vKipcbiAqIEVuY29kZSBwYWNrZWQgYXJncyB0byBoZXhcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVBhY2tlZFxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgaGV4IGVuY29kZWQgYXJndW1lbnRzXG4gKi9cbnZhciBlbmNvZGVQYWNrZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgaGV4QXJncyA9IGFyZ3MubWFwKF9wcm9jZXNzU29saWRpdHlFbmNvZGVQYWNrZWRBcmdzKTtcbiAgICByZXR1cm4gJzB4JyArIGhleEFyZ3Muam9pbignJykudG9Mb3dlckNhc2UoKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzb2xpZGl0eVNoYTM6IHNvbGlkaXR5U2hhMyxcbiAgICBzb2xpZGl0eVNoYTNSYXc6IHNvbGlkaXR5U2hhM1JhdyxcbiAgICBlbmNvZGVQYWNrZWQ6IGVuY29kZVBhY2tlZFxufTtcbiJdLCJuYW1lcyI6WyJCTiIsInJlcXVpcmUiLCJ1dGlscyIsIl9lbGVtZW50YXJ5TmFtZSIsIm5hbWUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJfcGFyc2VUeXBlTiIsInR5cGUiLCJ0eXBlc2l6ZSIsImV4ZWMiLCJwYXJzZUludCIsIl9wYXJzZVR5cGVOQXJyYXkiLCJhcnJheVNpemUiLCJfcGFyc2VOdW1iZXIiLCJhcmciLCJpc0hleFN0cmljdCIsInJlcGxhY2UiLCJpc0JpZ051bWJlciIsInRvU3RyaW5nIiwiaXNCTiIsIkVycm9yIiwiX3NvbGlkaXR5UGFjayIsInZhbHVlIiwic2l6ZSIsIm51bSIsImxlbmd0aCIsInV0ZjhUb0hleCIsImlzQWRkcmVzcyIsImxlZnRQYWQiLCJ0b0xvd2VyQ2FzZSIsInJpZ2h0UGFkIiwiYml0TGVuZ3RoIiwibHQiLCJ0b1R3b3MiLCJfcHJvY2Vzc1NvbGlkaXR5RW5jb2RlUGFja2VkQXJncyIsIkFycmF5IiwiaXNBcnJheSIsImhleEFyZyIsImhhc093blByb3BlcnR5IiwidCIsInYiLCJ0b0hleCIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwibWFwIiwidmFsIiwiam9pbiIsInNvbGlkaXR5U2hhMyIsImFyZ3MiLCJwcm90b3R5cGUiLCJjYWxsIiwiYXJndW1lbnRzIiwiaGV4QXJncyIsInNoYTMiLCJzb2xpZGl0eVNoYTNSYXciLCJzaGEzUmF3IiwiZW5jb2RlUGFja2VkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/lib/soliditySha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/web3-utils/lib/utils.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */ /**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */ \nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar numberToBN = __webpack_require__(/*! number-to-bn */ \"(ssr)/./node_modules/number-to-bn/src/index.js\");\nvar utf8 = __webpack_require__(/*! utf8 */ \"(ssr)/./node_modules/utf8/utf8.js\");\nvar ethereumjsUtil = __webpack_require__(/*! @ethereumjs/util */ \"(ssr)/./node_modules/@ethereumjs/util/dist/index.js\");\nvar ethereumBloomFilters = __webpack_require__(/*! ethereum-bloom-filters */ \"(ssr)/./node_modules/ethereum-bloom-filters/dist/index.js\");\nvar { keccak256 } = __webpack_require__(/*! ethereum-cryptography/keccak.js */ \"(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js\");\n/**\n * Returns true if object is BN, otherwise false\n *\n * @method isBN\n * @param {Object} object\n * @return {Boolean}\n */ var isBN = function(object) {\n    return BN.isBN(object);\n};\n/**\n * Returns true if object is BigNumber, otherwise false\n *\n * @method isBigNumber\n * @param {Object} object\n * @return {Boolean}\n */ var isBigNumber = function(object) {\n    return object && object.constructor && object.constructor.name === \"BigNumber\";\n};\n/**\n * Takes an input and transforms it into an BN\n *\n * @method toBN\n * @param {Number|String|BN} number, string, HEX string or BN\n * @return {BN} BN\n */ var toBN = function(number) {\n    try {\n        return numberToBN.apply(null, arguments);\n    } catch (e) {\n        throw new Error(e + ' Given value: \"' + number + '\"');\n    }\n};\n/**\n * Takes and input transforms it into BN and if it is negative value, into two's complement\n *\n * @method toTwosComplement\n * @param {Number|String|BN} number\n * @return {String}\n */ var toTwosComplement = function(number) {\n    return \"0x\" + toBN(number).toTwos(256).toString(16, 64);\n};\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX address\n * @return {Boolean}\n */ var isAddress = function(address) {\n    // check if it has the basic requirements of an address\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n    // If it's ALL lowercase or ALL upppercase\n    } else if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n    // Otherwise check each case\n    } else {\n        return checkAddressChecksum(address);\n    }\n};\n/**\n * Checks if the given string is a checksummed address\n *\n * @method checkAddressChecksum\n * @param {String} address the given HEX address\n * @return {Boolean}\n */ var checkAddressChecksum = function(address) {\n    // Check each case\n    address = address.replace(/^0x/i, \"\");\n    var addressHash = sha3(address.toLowerCase()).replace(/^0x/i, \"\");\n    for(var i = 0; i < 40; i++){\n        // the nth letter should be uppercase if the nth digit of casemap is 1\n        if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method leftPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */ var leftPad = function(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === \"number\";\n    string = string.toString(16).replace(/^0x/i, \"\");\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? \"0x\" : \"\") + new Array(padding).join(sign ? sign : \"0\") + string;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method rightPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */ var rightPad = function(string, chars, sign) {\n    var hasPrefix = /^0x/i.test(string) || typeof string === \"number\";\n    string = string.toString(16).replace(/^0x/i, \"\");\n    var padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n    return (hasPrefix ? \"0x\" : \"\") + string + new Array(padding).join(sign ? sign : \"0\");\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @method utf8ToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */ var utf8ToHex = function(str) {\n    str = utf8.encode(str);\n    var hex = \"\";\n    // remove \\u0000 padding from either side\n    str = str.replace(/^(?:\\u0000)*/, \"\");\n    str = str.split(\"\").reverse().join(\"\");\n    str = str.replace(/^(?:\\u0000)*/, \"\");\n    str = str.split(\"\").reverse().join(\"\");\n    for(var i = 0; i < str.length; i++){\n        var code = str.charCodeAt(i);\n        // if (code !== 0) {\n        var n = code.toString(16);\n        hex += n.length < 2 ? \"0\" + n : n;\n    // }\n    }\n    return \"0x\" + hex;\n};\n/**\n * Should be called to get utf8 from it's hex representation\n *\n * @method hexToUtf8\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */ var hexToUtf8 = function(hex) {\n    if (!isHexStrict(hex)) throw new Error('The parameter \"' + hex + '\" must be a valid HEX string.');\n    var str = \"\";\n    var code = 0;\n    hex = hex.replace(/^0x/i, \"\");\n    // remove 00 padding from either side\n    hex = hex.replace(/^(?:00)*/, \"\");\n    hex = hex.split(\"\").reverse().join(\"\");\n    hex = hex.replace(/^(?:00)*/, \"\");\n    hex = hex.split(\"\").reverse().join(\"\");\n    var l = hex.length;\n    for(var i = 0; i < l; i += 2){\n        code = parseInt(hex.slice(i, i + 2), 16);\n        // if (code !== 0) {\n        str += String.fromCharCode(code);\n    // }\n    }\n    return utf8.decode(str);\n};\n/**\n * Converts value to it's number representation.\n * However, if the value is larger than the maximum safe integer, returns the value as a string.\n *\n * @method hexToNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */ var hexToNumber = function(value, bigIntOnOverflow = false) {\n    if (!value) {\n        return value;\n    }\n    if (typeof value === \"string\" && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    const n = toBN(value);\n    if (bigIntOnOverflow && (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)) {\n        return BigInt(n);\n    }\n    return n.toNumber();\n};\n/**\n * Converts value to it's decimal representation in string\n *\n * @method hexToNumberString\n * @param {String|Number|BN} value\n * @return {String}\n */ var hexToNumberString = function(value) {\n    if (!value) return value;\n    if (typeof value === \"string\" && !isHexStrict(value)) {\n        throw new Error('Given value \"' + value + '\" is not a valid hex string.');\n    }\n    return toBN(value).toString(10);\n};\n/**\n * Converts value to it's hex representation\n *\n * @method numberToHex\n * @param {String|Number|BN} value\n * @return {String}\n */ var numberToHex = function(value) {\n    if (value === null || value === undefined) {\n        return value;\n    }\n    if (!isFinite(value) && !isHexStrict(value)) {\n        throw new Error('Given input \"' + value + '\" is not a number.');\n    }\n    var number = toBN(value);\n    var result = number.toString(16);\n    return number.lt(new BN(0)) ? \"-0x\" + result.slice(1) : \"0x\" + result;\n};\n/**\n * Convert a byte array to a hex string\n *\n * Note: Implementation from crypto-js\n *\n * @method bytesToHex\n * @param {Array} bytes\n * @return {String} the hex string\n */ var bytesToHex = function(bytes) {\n    for(var hex = [], i = 0; i < bytes.length; i++){\n        /* jshint ignore:start */ hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n    /* jshint ignore:end */ }\n    return \"0x\" + hex.join(\"\");\n};\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n * @param {string} hex\n * @return {Array} the byte array\n */ var hexToBytes = function(hex) {\n    hex = hex.toString(16);\n    if (!isHexStrict(hex)) {\n        throw new Error('Given value \"' + hex + '\" is not a valid hex string.');\n    }\n    hex = hex.replace(/^0x/i, \"\");\n    for(var bytes = [], c = 0; c < hex.length; c += 2)bytes.push(parseInt(hex.slice(c, c + 2), 16));\n    return bytes;\n};\n/**\n * Auto converts any given value into it's hex representation.\n *\n * And even stringifys objects before.\n *\n * @method toHex\n * @param {String|Number|BN|Object|Buffer} value\n * @param {Boolean} returnType\n * @return {String}\n */ var toHex = function(value, returnType) {\n    /*jshint maxcomplexity: false */ if (isAddress(value)) {\n        return returnType ? \"address\" : \"0x\" + value.toLowerCase().replace(/^0x/i, \"\");\n    }\n    if (typeof value === \"boolean\") {\n        return returnType ? \"bool\" : value ? \"0x01\" : \"0x00\";\n    }\n    if (Buffer.isBuffer(value)) {\n        return \"0x\" + value.toString(\"hex\");\n    }\n    if (typeof value === \"object\" && !!value && !isBigNumber(value) && !isBN(value)) {\n        return returnType ? \"string\" : utf8ToHex(JSON.stringify(value));\n    }\n    // if its a negative number, pass it through numberToHex\n    if (typeof value === \"string\") {\n        if (value.indexOf(\"-0x\") === 0 || value.indexOf(\"-0X\") === 0) {\n            return returnType ? \"int256\" : numberToHex(value);\n        } else if (value.indexOf(\"0x\") === 0 || value.indexOf(\"0X\") === 0) {\n            return returnType ? \"bytes\" : value;\n        } else if (!isFinite(value)) {\n            return returnType ? \"string\" : utf8ToHex(value);\n        }\n    }\n    return returnType ? value < 0 ? \"int256\" : \"uint256\" : numberToHex(value);\n};\n/**\n * Check if string is HEX, requires a 0x in front\n *\n * @method isHexStrict\n * @param {String} hex to be checked\n * @returns {Boolean}\n */ var isHexStrict = function(hex) {\n    return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\n * Check if string is HEX\n *\n * @method isHex\n * @param {String} hex to be checked\n * @returns {Boolean}\n */ var isHex = function(hex) {\n    return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n};\n/**\n * Remove 0x prefix from string\n *\n * @method stripHexPrefix\n * @param {String} str to be checked\n * @returns {String}\n */ var stripHexPrefix = function(str) {\n    if (str !== 0 && isHex(str)) return str.replace(/^(-)?0x/i, \"$1\");\n    return str;\n};\n/**\n * Returns true if given string is a valid Ethereum block header bloom.\n *\n * @method isBloom\n * @param {String} bloom encoded bloom filter\n * @return {Boolean}\n */ var isBloom = function(bloom) {\n    return ethereumBloomFilters.isBloom(bloom);\n};\n/**\n * Returns true if the ethereum users address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} ethereumAddress encoded bloom filter\n * @param {String} bloom ethereum addresss\n * @return {Boolean}\n */ var isUserEthereumAddressInBloom = function(bloom, ethereumAddress) {\n    return ethereumBloomFilters.isUserEthereumAddressInBloom(bloom, ethereumAddress);\n};\n/**\n * Returns true if the contract address is part of the given bloom\n * note: false positives are possible.\n *\n * @method isUserEthereumAddressInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} contractAddress contract addresss\n * @return {Boolean}\n */ var isContractAddressInBloom = function(bloom, contractAddress) {\n    return ethereumBloomFilters.isContractAddressInBloom(bloom, contractAddress);\n};\n/**\n * Returns true if given string is a valid log topic.\n *\n * @method isTopic\n * @param {String} topic encoded topic\n * @return {Boolean}\n */ var isTopic = function(topic) {\n    return ethereumBloomFilters.isTopic(topic);\n};\n/**\n * Returns true if the topic is part of the given bloom\n * note: false positives are possible.\n *\n * @method isTopicInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String} topic encoded topic\n * @return {Boolean}\n */ var isTopicInBloom = function(bloom, topic) {\n    return ethereumBloomFilters.isTopicInBloom(bloom, topic);\n};\n/**\n * Returns true if the value is part of the given bloom\n * note: false positives are possible.\n *\n * @method isInBloom\n * @param {String} bloom encoded bloom filter\n * @param {String | Uint8Array} topic encoded value\n * @return {Boolean}\n */ var isInBloom = function(bloom, topic) {\n    return ethereumBloomFilters.isInBloom(bloom, topic);\n};\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @method sha3\n * @return {String} the sha3 string\n */ var SHA3_NULL_S = \"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\nvar sha3 = function(value) {\n    if (isBN(value)) {\n        value = value.toString();\n    }\n    if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n        value = ethereumjsUtil.toBuffer(value);\n    } else if (typeof value === \"string\") {\n        // Assume value is an arbitrary string\n        value = Buffer.from(value, \"utf-8\");\n    }\n    var returnValue = ethereumjsUtil.bufferToHex(keccak256(value));\n    if (returnValue === SHA3_NULL_S) {\n        return null;\n    } else {\n        return returnValue;\n    }\n};\n// expose the under the hood keccak256\nsha3._Hash = keccak256;\n/**\n * @method sha3Raw\n *\n * @param value\n *\n * @returns {string}\n */ var sha3Raw = function(value) {\n    value = sha3(value);\n    if (value === null) {\n        return SHA3_NULL_S;\n    }\n    return value;\n};\n/**\n * Auto converts any given value into it's hex representation,\n * then converts hex to number.\n *\n * @method toNumber\n * @param {String|Number|BN} value\n * @param {Boolean} bigIntOnOverflow - if true, return the hex value in case of overflow\n * @return {Number|String}\n */ var toNumber = function(value, bigIntOnOverflow = false) {\n    return typeof value === \"number\" ? value : hexToNumber(toHex(value), bigIntOnOverflow);\n};\n// 1.x currently accepts 0x... strings, bn.js after update doesn't. it would be a breaking change\nvar BNwrapped = function(value) {\n    // check negative\n    if (typeof value == \"string\" && value.includes(\"0x\")) {\n        const [negative, hexValue] = value.toLocaleLowerCase().startsWith(\"-\") ? [\n            \"-\",\n            value.slice(3)\n        ] : [\n            \"\",\n            value.slice(2)\n        ];\n        return new BN(negative + hexValue, 16);\n    } else {\n        return new BN(value);\n    }\n};\nObject.setPrototypeOf(BNwrapped, BN);\nObject.setPrototypeOf(BNwrapped.prototype, BN.prototype);\nmodule.exports = {\n    BN: BNwrapped,\n    isBN: isBN,\n    isBigNumber: isBigNumber,\n    toBN: toBN,\n    isAddress: isAddress,\n    isBloom: isBloom,\n    isUserEthereumAddressInBloom: isUserEthereumAddressInBloom,\n    isContractAddressInBloom: isContractAddressInBloom,\n    isTopic: isTopic,\n    isTopicInBloom: isTopicInBloom,\n    isInBloom: isInBloom,\n    checkAddressChecksum: checkAddressChecksum,\n    utf8ToHex: utf8ToHex,\n    hexToUtf8: hexToUtf8,\n    hexToNumber: hexToNumber,\n    hexToNumberString: hexToNumberString,\n    numberToHex: numberToHex,\n    toHex: toHex,\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    isHex: isHex,\n    isHexStrict: isHexStrict,\n    stripHexPrefix: stripHexPrefix,\n    leftPad: leftPad,\n    rightPad: rightPad,\n    toTwosComplement: toTwosComplement,\n    sha3: sha3,\n    sha3Raw: sha3Raw,\n    toNumber: toNumber\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0Q7Ozs7Q0FJQztBQUNELElBQUlBLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ2pCLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLGlCQUFpQkgsbUJBQU9BLENBQUM7QUFDN0IsSUFBSUksdUJBQXVCSixtQkFBT0EsQ0FBQztBQUNuQyxJQUFJLEVBQUVLLFNBQVMsRUFBRSxHQUFHTCxtQkFBT0EsQ0FBQztBQUM1Qjs7Ozs7O0NBTUMsR0FDRCxJQUFJTSxPQUFPLFNBQVVDLE1BQU07SUFDdkIsT0FBT1IsR0FBR08sSUFBSSxDQUFDQztBQUNuQjtBQUNBOzs7Ozs7Q0FNQyxHQUNELElBQUlDLGNBQWMsU0FBVUQsTUFBTTtJQUM5QixPQUFPQSxVQUFVQSxPQUFPRSxXQUFXLElBQUlGLE9BQU9FLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3ZFO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsSUFBSUMsT0FBTyxTQUFVQyxNQUFNO0lBQ3ZCLElBQUk7UUFDQSxPQUFPWCxXQUFXWSxLQUFLLENBQUMsTUFBTUM7SUFDbEMsRUFDQSxPQUFPQyxHQUFHO1FBQ04sTUFBTSxJQUFJQyxNQUFNRCxJQUFJLG9CQUFvQkgsU0FBUztJQUNyRDtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsSUFBSUssbUJBQW1CLFNBQVVMLE1BQU07SUFDbkMsT0FBTyxPQUFPRCxLQUFLQyxRQUFRTSxNQUFNLENBQUMsS0FBS0MsUUFBUSxDQUFDLElBQUk7QUFDeEQ7QUFDQTs7Ozs7O0NBTUMsR0FDRCxJQUFJQyxZQUFZLFNBQVVDLE9BQU87SUFDN0IsdURBQXVEO0lBQ3ZELElBQUksQ0FBQyx1QkFBdUJDLElBQUksQ0FBQ0QsVUFBVTtRQUN2QyxPQUFPO0lBQ1AsMENBQTBDO0lBQzlDLE9BQ0ss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aWxzLmpzPzA4NmQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4vKipcbiAqIEBmaWxlIHV0aWxzLmpzXG4gKiBAYXV0aG9yIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhlcmV1bS5vcmc+XG4gKiBAZGF0ZSAyMDE3XG4gKi9cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgbnVtYmVyVG9CTiA9IHJlcXVpcmUoJ251bWJlci10by1ibicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG52YXIgZXRoZXJldW1qc1V0aWwgPSByZXF1aXJlKCdAZXRoZXJldW1qcy91dGlsJyk7XG52YXIgZXRoZXJldW1CbG9vbUZpbHRlcnMgPSByZXF1aXJlKCdldGhlcmV1bS1ibG9vbS1maWx0ZXJzJyk7XG52YXIgeyBrZWNjYWsyNTYgfSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsuanMnKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBCTiwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0JOXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNCTiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gQk4uaXNCTihvYmplY3QpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBCaWdOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCaWdOdW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0JpZ051bWJlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvciAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ0JpZ051bWJlcic7XG59O1xuLyoqXG4gKiBUYWtlcyBhbiBpbnB1dCBhbmQgdHJhbnNmb3JtcyBpdCBpbnRvIGFuIEJOXG4gKlxuICogQG1ldGhvZCB0b0JOXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8Qk59IG51bWJlciwgc3RyaW5nLCBIRVggc3RyaW5nIG9yIEJOXG4gKiBAcmV0dXJuIHtCTn0gQk5cbiAqL1xudmFyIHRvQk4gPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQk4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUgKyAnIEdpdmVuIHZhbHVlOiBcIicgKyBudW1iZXIgKyAnXCInKTtcbiAgICB9XG59O1xuLyoqXG4gKiBUYWtlcyBhbmQgaW5wdXQgdHJhbnNmb3JtcyBpdCBpbnRvIEJOIGFuZCBpZiBpdCBpcyBuZWdhdGl2ZSB2YWx1ZSwgaW50byB0d28ncyBjb21wbGVtZW50XG4gKlxuICogQG1ldGhvZCB0b1R3b3NDb21wbGVtZW50XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8Qk59IG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgdG9Ud29zQ29tcGxlbWVudCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICByZXR1cm4gJzB4JyArIHRvQk4obnVtYmVyKS50b1R3b3MoMjU2KS50b1N0cmluZygxNiwgNjQpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYW4gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgaXNBZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIC8vIGNoZWNrIGlmIGl0IGhhcyB0aGUgYmFzaWMgcmVxdWlyZW1lbnRzIG9mIGFuIGFkZHJlc3NcbiAgICBpZiAoIS9eKDB4KT9bMC05YS1mXXs0MH0kL2kudGVzdChhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIGl0J3MgQUxMIGxvd2VyY2FzZSBvciBBTEwgdXBwcGVyY2FzZVxuICAgIH1cbiAgICBlbHNlIGlmICgvXigweHwwWCk/WzAtOWEtZl17NDB9JC8udGVzdChhZGRyZXNzKSB8fCAvXigweHwwWCk/WzAtOUEtRl17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGVhY2ggY2FzZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrQWRkcmVzc0NoZWNrc3VtKGFkZHJlc3MpO1xuICAgIH1cbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgY2hlY2tBZGRyZXNzQ2hlY2tzdW1cbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGNoZWNrQWRkcmVzc0NoZWNrc3VtID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAvLyBDaGVjayBlYWNoIGNhc2VcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBhZGRyZXNzSGFzaCA9IHNoYTMoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICAvLyB0aGUgbnRoIGxldHRlciBzaG91bGQgYmUgdXBwZXJjYXNlIGlmIHRoZSBudGggZGlnaXQgb2YgY2FzZW1hcCBpcyAxXG4gICAgICAgIGlmICgocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcgJiYgYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpICE9PSBhZGRyZXNzW2ldKSB8fCAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA8PSA3ICYmIGFkZHJlc3NbaV0udG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcGFkIHN0cmluZyB0byBleHBlY3RlZCBsZW5ndGhcbiAqXG4gKiBAbWV0aG9kIGxlZnRQYWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gYmUgcGFkZGVkXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhcnMgdGhhdCByZXN1bHQgc3RyaW5nIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbiwgYnkgZGVmYXVsdCAwXG4gKiBAcmV0dXJucyB7U3RyaW5nfSByaWdodCBhbGlnbmVkIHN0cmluZ1xuICovXG52YXIgbGVmdFBhZCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgdmFyIGhhc1ByZWZpeCA9IC9eMHgvaS50ZXN0KHN0cmluZykgfHwgdHlwZW9mIHN0cmluZyA9PT0gJ251bWJlcic7XG4gICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKDE2KS5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIHZhciBwYWRkaW5nID0gKGNoYXJzIC0gc3RyaW5nLmxlbmd0aCArIDEgPj0gMCkgPyBjaGFycyAtIHN0cmluZy5sZW5ndGggKyAxIDogMDtcbiAgICByZXR1cm4gKGhhc1ByZWZpeCA/ICcweCcgOiAnJykgKyBuZXcgQXJyYXkocGFkZGluZykuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSArIHN0cmluZztcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcGFkIHN0cmluZyB0byBleHBlY3RlZCBsZW5ndGhcbiAqXG4gKiBAbWV0aG9kIHJpZ2h0UGFkXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRvIGJlIHBhZGRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIHJpZ2h0UGFkID0gZnVuY3Rpb24gKHN0cmluZywgY2hhcnMsIHNpZ24pIHtcbiAgICB2YXIgaGFzUHJlZml4ID0gL14weC9pLnRlc3Qoc3RyaW5nKSB8fCB0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJztcbiAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoMTYpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgdmFyIHBhZGRpbmcgPSAoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSA+PSAwKSA/IGNoYXJzIC0gc3RyaW5nLmxlbmd0aCArIDEgOiAwO1xuICAgIHJldHVybiAoaGFzUHJlZml4ID8gJzB4JyA6ICcnKSArIHN0cmluZyArIChuZXcgQXJyYXkocGFkZGluZykuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgdXRmOFRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbnZhciB1dGY4VG9IZXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgc3RyID0gdXRmOC5lbmNvZGUoc3RyKTtcbiAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICAvLyByZW1vdmUgXFx1MDAwMCBwYWRkaW5nIGZyb20gZWl0aGVyIHNpZGVcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXig/OlxcdTAwMDApKi8sICcnKTtcbiAgICBzdHIgPSBzdHIuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL14oPzpcXHUwMDAwKSovLCAnJyk7XG4gICAgc3RyID0gc3RyLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGV4O1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCBoZXhUb1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xudmFyIGhleFRvVXRmOCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBpZiAoIWlzSGV4U3RyaWN0KGhleCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhcmFtZXRlciBcIicgKyBoZXggKyAnXCIgbXVzdCBiZSBhIHZhbGlkIEhFWCBzdHJpbmcuJyk7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGNvZGUgPSAwO1xuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eMHgvaSwgJycpO1xuICAgIC8vIHJlbW92ZSAwMCBwYWRkaW5nIGZyb20gZWl0aGVyIHNpZGVcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXig/OjAwKSovLCAnJyk7XG4gICAgaGV4ID0gaGV4LnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGhleCA9IGhleC5yZXBsYWNlKC9eKD86MDApKi8sICcnKTtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgdmFyIGwgPSBoZXgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgIGNvZGUgPSBwYXJzZUludChoZXguc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgICAgIC8vIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIHJldHVybiB1dGY4LmRlY29kZShzdHIpO1xufTtcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBudW1iZXIgcmVwcmVzZW50YXRpb24uXG4gKiBIb3dldmVyLCBpZiB0aGUgdmFsdWUgaXMgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyLCByZXR1cm5zIHRoZSB2YWx1ZSBhcyBhIHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGhleFRvTnVtYmVyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJpZ0ludE9uT3ZlcmZsb3cgLSBpZiB0cnVlLCByZXR1cm4gdGhlIGhleCB2YWx1ZSBpbiBjYXNlIG9mIG92ZXJmbG93XG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICovXG52YXIgaGV4VG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIGJpZ0ludE9uT3ZlcmZsb3cgPSBmYWxzZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhaXNIZXhTdHJpY3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy4nKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHRvQk4odmFsdWUpO1xuICAgIGlmIChiaWdJbnRPbk92ZXJmbG93ICYmIChuID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbiA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkge1xuICAgICAgICByZXR1cm4gQmlnSW50KG4pO1xuICAgIH1cbiAgICByZXR1cm4gbi50b051bWJlcigpO1xufTtcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIGluIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgaGV4VG9OdW1iZXJTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxCTn0gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGhleFRvTnVtYmVyU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICFpc0hleFN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBub3QgYSB2YWxpZCBoZXggc3RyaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9CTih2YWx1ZSkudG9TdHJpbmcoMTApO1xufTtcbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIG51bWJlclRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbnZhciBudW1iZXJUb0hleCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSAmJiAhaXNIZXhTdHJpY3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gaW5wdXQgXCInICsgdmFsdWUgKyAnXCIgaXMgbm90IGEgbnVtYmVyLicpO1xuICAgIH1cbiAgICB2YXIgbnVtYmVyID0gdG9CTih2YWx1ZSk7XG4gICAgdmFyIHJlc3VsdCA9IG51bWJlci50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIG51bWJlci5sdChuZXcgQk4oMCkpID8gJy0weCcgKyByZXN1bHQuc2xpY2UoMSkgOiAnMHgnICsgcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBoZXggc3RyaW5nXG4gKlxuICogTm90ZTogSW1wbGVtZW50YXRpb24gZnJvbSBjcnlwdG8tanNcbiAqXG4gKiBAbWV0aG9kIGJ5dGVzVG9IZXhcbiAqIEBwYXJhbSB7QXJyYXl9IGJ5dGVzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBoZXggc3RyaW5nXG4gKi9cbnZhciBieXRlc1RvSGV4ID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgZm9yICh2YXIgaGV4ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSAmIDB4RikudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgICB9XG4gICAgcmV0dXJuICcweCcgKyBoZXguam9pbihcIlwiKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBoZXggc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICpcbiAqIE5vdGU6IEltcGxlbWVudGF0aW9uIGZyb20gY3J5cHRvLWpzXG4gKlxuICogQG1ldGhvZCBoZXhUb0J5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIGJ5dGUgYXJyYXlcbiAqL1xudmFyIGhleFRvQnl0ZXMgPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgaGV4ID0gaGV4LnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoIWlzSGV4U3RyaWN0KGhleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiB2YWx1ZSBcIicgKyBoZXggKyAnXCIgaXMgbm90IGEgdmFsaWQgaGV4IHN0cmluZy4nKTtcbiAgICB9XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYyA9IDA7IGMgPCBoZXgubGVuZ3RoOyBjICs9IDIpXG4gICAgICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoaGV4LnNsaWNlKGMsIGMgKyAyKSwgMTYpKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59O1xuLyoqXG4gKiBBdXRvIGNvbnZlcnRzIGFueSBnaXZlbiB2YWx1ZSBpbnRvIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEFuZCBldmVuIHN0cmluZ2lmeXMgb2JqZWN0cyBiZWZvcmUuXG4gKlxuICogQG1ldGhvZCB0b0hleFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJOfE9iamVjdHxCdWZmZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHJldHVyblR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvSGV4ID0gZnVuY3Rpb24gKHZhbHVlLCByZXR1cm5UeXBlKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogZmFsc2UgKi9cbiAgICBpZiAoaXNBZGRyZXNzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdhZGRyZXNzJyA6ICcweCcgKyB2YWx1ZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL14weC9pLCAnJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdib29sJyA6IHZhbHVlID8gJzB4MDEnIDogJzB4MDAnO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJzB4JyArIHZhbHVlLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZSAmJiAhaXNCaWdOdW1iZXIodmFsdWUpICYmICFpc0JOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdzdHJpbmcnIDogdXRmOFRvSGV4KEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIGlmIGl0cyBhIG5lZ2F0aXZlIG51bWJlciwgcGFzcyBpdCB0aHJvdWdoIG51bWJlclRvSGV4XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJy0weCcpID09PSAwIHx8IHZhbHVlLmluZGV4T2YoJy0wWCcpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZSA/ICdpbnQyNTYnIDogbnVtYmVyVG9IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLmluZGV4T2YoJzB4JykgPT09IDAgfHwgdmFsdWUuaW5kZXhPZignMFgnKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnYnl0ZXMnIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGUgPyAnc3RyaW5nJyA6IHV0ZjhUb0hleCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblR5cGUgPyAodmFsdWUgPCAwID8gJ2ludDI1NicgOiAndWludDI1NicpIDogbnVtYmVyVG9IZXgodmFsdWUpO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgc3RyaW5nIGlzIEhFWCwgcmVxdWlyZXMgYSAweCBpbiBmcm9udFxuICpcbiAqIEBtZXRob2QgaXNIZXhTdHJpY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggdG8gYmUgY2hlY2tlZFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbnZhciBpc0hleFN0cmljdCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICByZXR1cm4gKCh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaGV4ID09PSAnbnVtYmVyJykgJiYgL14oLSk/MHhbMC05YS1mXSokL2kudGVzdChoZXgpKTtcbn07XG4vKipcbiAqIENoZWNrIGlmIHN0cmluZyBpcyBIRVhcbiAqXG4gKiBAbWV0aG9kIGlzSGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG52YXIgaXNIZXggPSBmdW5jdGlvbiAoaGV4KSB7XG4gICAgcmV0dXJuICgodHlwZW9mIGhleCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGhleCA9PT0gJ251bWJlcicpICYmIC9eKC0weHwweCk/WzAtOWEtZl0qJC9pLnRlc3QoaGV4KSk7XG59O1xuLyoqXG4gKiBSZW1vdmUgMHggcHJlZml4IGZyb20gc3RyaW5nXG4gKlxuICogQG1ldGhvZCBzdHJpcEhleFByZWZpeFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG52YXIgc3RyaXBIZXhQcmVmaXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHN0ciAhPT0gMCAmJiBpc0hleChzdHIpKVxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14oLSk/MHgvaSwgJyQxJyk7XG4gICAgcmV0dXJuIHN0cjtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBFdGhlcmV1bSBibG9jayBoZWFkZXIgYmxvb20uXG4gKlxuICogQG1ldGhvZCBpc0Jsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gYmxvb20gZW5jb2RlZCBibG9vbSBmaWx0ZXJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0Jsb29tID0gZnVuY3Rpb24gKGJsb29tKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzQmxvb20oYmxvb20pO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBldGhlcmV1bSB1c2VycyBhZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbVxuICogQHBhcmFtIHtTdHJpbmd9IGV0aGVyZXVtQWRkcmVzcyBlbmNvZGVkIGJsb29tIGZpbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IGJsb29tIGV0aGVyZXVtIGFkZHJlc3NzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSA9IGZ1bmN0aW9uIChibG9vbSwgZXRoZXJldW1BZGRyZXNzKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20oYmxvb20sIGV0aGVyZXVtQWRkcmVzcyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyYWN0IGFkZHJlc3MgaXMgcGFydCBvZiB0aGUgZ2l2ZW4gYmxvb21cbiAqIG5vdGU6IGZhbHNlIHBvc2l0aXZlcyBhcmUgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCBpc1VzZXJFdGhlcmV1bUFkZHJlc3NJbkJsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gYmxvb20gZW5jb2RlZCBibG9vbSBmaWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250cmFjdEFkZHJlc3MgY29udHJhY3QgYWRkcmVzc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb20gPSBmdW5jdGlvbiAoYmxvb20sIGNvbnRyYWN0QWRkcmVzcykge1xuICAgIHJldHVybiBldGhlcmV1bUJsb29tRmlsdGVycy5pc0NvbnRyYWN0QWRkcmVzc0luQmxvb20oYmxvb20sIGNvbnRyYWN0QWRkcmVzcyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgbG9nIHRvcGljLlxuICpcbiAqIEBtZXRob2QgaXNUb3BpY1xuICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIGVuY29kZWQgdG9waWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1RvcGljID0gZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzVG9waWModG9waWMpO1xufTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0b3BpYyBpcyBwYXJ0IG9mIHRoZSBnaXZlbiBibG9vbVxuICogbm90ZTogZmFsc2UgcG9zaXRpdmVzIGFyZSBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIGlzVG9waWNJbkJsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gYmxvb20gZW5jb2RlZCBibG9vbSBmaWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b3BpYyBlbmNvZGVkIHRvcGljXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUb3BpY0luQmxvb20gPSBmdW5jdGlvbiAoYmxvb20sIHRvcGljKSB7XG4gICAgcmV0dXJuIGV0aGVyZXVtQmxvb21GaWx0ZXJzLmlzVG9waWNJbkJsb29tKGJsb29tLCB0b3BpYyk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIHBhcnQgb2YgdGhlIGdpdmVuIGJsb29tXG4gKiBub3RlOiBmYWxzZSBwb3NpdGl2ZXMgYXJlIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgaXNJbkJsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gYmxvb20gZW5jb2RlZCBibG9vbSBmaWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nIHwgVWludDhBcnJheX0gdG9waWMgZW5jb2RlZCB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzSW5CbG9vbSA9IGZ1bmN0aW9uIChibG9vbSwgdG9waWMpIHtcbiAgICByZXR1cm4gZXRoZXJldW1CbG9vbUZpbHRlcnMuaXNJbkJsb29tKGJsb29tLCB0b3BpYyk7XG59O1xuLyoqXG4gKiBIYXNoZXMgdmFsdWVzIHRvIGEgc2hhMyBoYXNoIHVzaW5nIGtlY2NhayAyNTZcbiAqXG4gKiBUbyBoYXNoIGEgSEVYIHN0cmluZyB0aGUgaGV4IG11c3QgaGF2ZSAweCBpbiBmcm9udC5cbiAqXG4gKiBAbWV0aG9kIHNoYTNcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHNoYTMgc3RyaW5nXG4gKi9cbnZhciBTSEEzX05VTExfUyA9ICcweGM1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xudmFyIHNoYTMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoaXNCTih2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpY3QodmFsdWUpICYmIC9eMHgvaS50ZXN0KCh2YWx1ZSkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgdmFsdWUgPSBldGhlcmV1bWpzVXRpbC50b0J1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXNzdW1lIHZhbHVlIGlzIGFuIGFyYml0cmFyeSBzdHJpbmdcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0Zi04Jyk7XG4gICAgfVxuICAgIHZhciByZXR1cm5WYWx1ZSA9IGV0aGVyZXVtanNVdGlsLmJ1ZmZlclRvSGV4KGtlY2NhazI1Nih2YWx1ZSkpO1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gU0hBM19OVUxMX1MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxufTtcbi8vIGV4cG9zZSB0aGUgdW5kZXIgdGhlIGhvb2Qga2VjY2FrMjU2XG5zaGEzLl9IYXNoID0ga2VjY2FrMjU2O1xuLyoqXG4gKiBAbWV0aG9kIHNoYTNSYXdcbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgc2hhM1JhdyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gc2hhMyh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBTSEEzX05VTExfUztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogQXV0byBjb252ZXJ0cyBhbnkgZ2l2ZW4gdmFsdWUgaW50byBpdCdzIGhleCByZXByZXNlbnRhdGlvbixcbiAqIHRoZW4gY29udmVydHMgaGV4IHRvIG51bWJlci5cbiAqXG4gKiBAbWV0aG9kIHRvTnVtYmVyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8Qk59IHZhbHVlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJpZ0ludE9uT3ZlcmZsb3cgLSBpZiB0cnVlLCByZXR1cm4gdGhlIGhleCB2YWx1ZSBpbiBjYXNlIG9mIG92ZXJmbG93XG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICovXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIGJpZ0ludE9uT3ZlcmZsb3cgPSBmYWxzZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBoZXhUb051bWJlcih0b0hleCh2YWx1ZSksIGJpZ0ludE9uT3ZlcmZsb3cpO1xufTtcbi8vIDEueCBjdXJyZW50bHkgYWNjZXB0cyAweC4uLiBzdHJpbmdzLCBibi5qcyBhZnRlciB1cGRhdGUgZG9lc24ndC4gaXQgd291bGQgYmUgYSBicmVha2luZyBjaGFuZ2VcbnZhciBCTndyYXBwZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBjaGVjayBuZWdhdGl2ZVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5pbmNsdWRlcyhcIjB4XCIpKSB7XG4gICAgICAgIGNvbnN0IFtuZWdhdGl2ZSwgaGV4VmFsdWVdID0gdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKS5zdGFydHNXaXRoKCctJykgPyBbXCItXCIsIHZhbHVlLnNsaWNlKDMpXSA6IFtcIlwiLCB2YWx1ZS5zbGljZSgyKV07XG4gICAgICAgIHJldHVybiBuZXcgQk4obmVnYXRpdmUgKyBoZXhWYWx1ZSwgMTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCTih2YWx1ZSk7XG4gICAgfVxufTtcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCTndyYXBwZWQsIEJOKTtcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCTndyYXBwZWQucHJvdG90eXBlLCBCTi5wcm90b3R5cGUpO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQk46IEJOd3JhcHBlZCxcbiAgICBpc0JOOiBpc0JOLFxuICAgIGlzQmlnTnVtYmVyOiBpc0JpZ051bWJlcixcbiAgICB0b0JOOiB0b0JOLFxuICAgIGlzQWRkcmVzczogaXNBZGRyZXNzLFxuICAgIGlzQmxvb206IGlzQmxvb20sXG4gICAgaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbTogaXNVc2VyRXRoZXJldW1BZGRyZXNzSW5CbG9vbSxcbiAgICBpc0NvbnRyYWN0QWRkcmVzc0luQmxvb206IGlzQ29udHJhY3RBZGRyZXNzSW5CbG9vbSxcbiAgICBpc1RvcGljOiBpc1RvcGljLFxuICAgIGlzVG9waWNJbkJsb29tOiBpc1RvcGljSW5CbG9vbSxcbiAgICBpc0luQmxvb206IGlzSW5CbG9vbSxcbiAgICBjaGVja0FkZHJlc3NDaGVja3N1bTogY2hlY2tBZGRyZXNzQ2hlY2tzdW0sXG4gICAgdXRmOFRvSGV4OiB1dGY4VG9IZXgsXG4gICAgaGV4VG9VdGY4OiBoZXhUb1V0ZjgsXG4gICAgaGV4VG9OdW1iZXI6IGhleFRvTnVtYmVyLFxuICAgIGhleFRvTnVtYmVyU3RyaW5nOiBoZXhUb051bWJlclN0cmluZyxcbiAgICBudW1iZXJUb0hleDogbnVtYmVyVG9IZXgsXG4gICAgdG9IZXg6IHRvSGV4LFxuICAgIGhleFRvQnl0ZXM6IGhleFRvQnl0ZXMsXG4gICAgYnl0ZXNUb0hleDogYnl0ZXNUb0hleCxcbiAgICBpc0hleDogaXNIZXgsXG4gICAgaXNIZXhTdHJpY3Q6IGlzSGV4U3RyaWN0LFxuICAgIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgICBsZWZ0UGFkOiBsZWZ0UGFkLFxuICAgIHJpZ2h0UGFkOiByaWdodFBhZCxcbiAgICB0b1R3b3NDb21wbGVtZW50OiB0b1R3b3NDb21wbGVtZW50LFxuICAgIHNoYTM6IHNoYTMsXG4gICAgc2hhM1Jhdzogc2hhM1JhdyxcbiAgICB0b051bWJlcjogdG9OdW1iZXJcbn07XG4iXSwibmFtZXMiOlsiQk4iLCJyZXF1aXJlIiwibnVtYmVyVG9CTiIsInV0ZjgiLCJldGhlcmV1bWpzVXRpbCIsImV0aGVyZXVtQmxvb21GaWx0ZXJzIiwia2VjY2FrMjU2IiwiaXNCTiIsIm9iamVjdCIsImlzQmlnTnVtYmVyIiwiY29uc3RydWN0b3IiLCJuYW1lIiwidG9CTiIsIm51bWJlciIsImFwcGx5IiwiYXJndW1lbnRzIiwiZSIsIkVycm9yIiwidG9Ud29zQ29tcGxlbWVudCIsInRvVHdvcyIsInRvU3RyaW5nIiwiaXNBZGRyZXNzIiwiYWRkcmVzcyIsInRlc3QiLCJjaGVja0FkZHJlc3NDaGVja3N1bSIsInJlcGxhY2UiLCJhZGRyZXNzSGFzaCIsInNoYTMiLCJ0b0xvd2VyQ2FzZSIsImkiLCJwYXJzZUludCIsInRvVXBwZXJDYXNlIiwibGVmdFBhZCIsInN0cmluZyIsImNoYXJzIiwic2lnbiIsImhhc1ByZWZpeCIsInBhZGRpbmciLCJsZW5ndGgiLCJBcnJheSIsImpvaW4iLCJyaWdodFBhZCIsInV0ZjhUb0hleCIsInN0ciIsImVuY29kZSIsImhleCIsInNwbGl0IiwicmV2ZXJzZSIsImNvZGUiLCJjaGFyQ29kZUF0IiwibiIsImhleFRvVXRmOCIsImlzSGV4U3RyaWN0IiwibCIsInNsaWNlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZGVjb2RlIiwiaGV4VG9OdW1iZXIiLCJ2YWx1ZSIsImJpZ0ludE9uT3ZlcmZsb3ciLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIkJpZ0ludCIsInRvTnVtYmVyIiwiaGV4VG9OdW1iZXJTdHJpbmciLCJudW1iZXJUb0hleCIsInVuZGVmaW5lZCIsImlzRmluaXRlIiwicmVzdWx0IiwibHQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJwdXNoIiwiaGV4VG9CeXRlcyIsImMiLCJ0b0hleCIsInJldHVyblR5cGUiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbmRleE9mIiwiaXNIZXgiLCJzdHJpcEhleFByZWZpeCIsImlzQmxvb20iLCJibG9vbSIsImlzVXNlckV0aGVyZXVtQWRkcmVzc0luQmxvb20iLCJldGhlcmV1bUFkZHJlc3MiLCJpc0NvbnRyYWN0QWRkcmVzc0luQmxvb20iLCJjb250cmFjdEFkZHJlc3MiLCJpc1RvcGljIiwidG9waWMiLCJpc1RvcGljSW5CbG9vbSIsImlzSW5CbG9vbSIsIlNIQTNfTlVMTF9TIiwidG9CdWZmZXIiLCJmcm9tIiwicmV0dXJuVmFsdWUiLCJidWZmZXJUb0hleCIsIl9IYXNoIiwic2hhM1JhdyIsIkJOd3JhcHBlZCIsImluY2x1ZGVzIiwibmVnYXRpdmUiLCJoZXhWYWx1ZSIsInRvTG9jYWxlTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js":
/*!***********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== \"boolean\") throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n};\nexports[\"default\"] = assert; //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsWUFBWSxHQUFHQSxhQUFhLEdBQUdBLFlBQVksR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdEcsU0FBU08sT0FBT0MsQ0FBQztJQUNiLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixNQUFNQSxJQUFJLEdBQ2hDLE1BQU0sSUFBSUcsTUFBTSxDQUFDLHdCQUF3QixFQUFFSCxFQUFFLENBQUM7QUFDdEQ7QUFDQVIsY0FBYyxHQUFHTztBQUNqQixTQUFTRCxLQUFLTSxDQUFDO0lBQ1gsSUFBSSxPQUFPQSxNQUFNLFdBQ2IsTUFBTSxJQUFJRCxNQUFNLENBQUMsc0JBQXNCLEVBQUVDLEVBQUUsQ0FBQztBQUNwRDtBQUNBWixZQUFZLEdBQUdNO0FBQ2YsU0FBU0QsTUFBTU8sQ0FBQyxFQUFFLEdBQUdDLE9BQU87SUFDeEIsSUFBSSxDQUFFRCxDQUFBQSxhQUFhRSxVQUFTLEdBQ3hCLE1BQU0sSUFBSUgsTUFBTTtJQUNwQixJQUFJRSxRQUFRRSxNQUFNLEdBQUcsS0FBSyxDQUFDRixRQUFRRyxRQUFRLENBQUNKLEVBQUVHLE1BQU0sR0FDaEQsTUFBTSxJQUFJSixNQUFNLENBQUMsOEJBQThCLEVBQUVFLFFBQVEsZ0JBQWdCLEVBQUVELEVBQUVHLE1BQU0sQ0FBQyxDQUFDO0FBQzdGO0FBQ0FmLGFBQWEsR0FBR0s7QUFDaEIsU0FBU0QsS0FBS0EsSUFBSTtJQUNkLElBQUksT0FBT0EsU0FBUyxjQUFjLE9BQU9BLEtBQUthLE1BQU0sS0FBSyxZQUNyRCxNQUFNLElBQUlOLE1BQU07SUFDcEJKLE9BQU9ILEtBQUtjLFNBQVM7SUFDckJYLE9BQU9ILEtBQUtlLFFBQVE7QUFDeEI7QUFDQW5CLFlBQVksR0FBR0k7QUFDZixTQUFTRCxPQUFPaUIsUUFBUSxFQUFFQyxnQkFBZ0IsSUFBSTtJQUMxQyxJQUFJRCxTQUFTRSxTQUFTLEVBQ2xCLE1BQU0sSUFBSVgsTUFBTTtJQUNwQixJQUFJVSxpQkFBaUJELFNBQVNHLFFBQVEsRUFDbEMsTUFBTSxJQUFJWixNQUFNO0FBQ3hCO0FBQ0FYLGNBQWMsR0FBR0c7QUFDakIsU0FBU0QsT0FBT3NCLEdBQUcsRUFBRUosUUFBUTtJQUN6QmYsTUFBTW1CO0lBQ04sTUFBTUMsTUFBTUwsU0FBU0YsU0FBUztJQUM5QixJQUFJTSxJQUFJVCxNQUFNLEdBQUdVLEtBQUs7UUFDbEIsTUFBTSxJQUFJZCxNQUFNLENBQUMsc0RBQXNELEVBQUVjLElBQUksQ0FBQztJQUNsRjtBQUNKO0FBQ0F6QixjQUFjLEdBQUdFO0FBQ2pCLE1BQU13QixTQUFTO0lBQ1huQjtJQUNBRDtJQUNBRDtJQUNBRDtJQUNBRDtJQUNBRDtBQUNKO0FBQ0FGLGtCQUFlLEdBQUcwQixRQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzPzE2ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm91dHB1dCA9IGV4cG9ydHMuZXhpc3RzID0gZXhwb3J0cy5oYXNoID0gZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuYm9vbCA9IGV4cG9ydHMubnVtYmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydHMuYm9vbCA9IGJvb2w7XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnRzLm91dHB1dCA9IG91dHB1dDtcbmNvbnN0IGFzc2VydCA9IHtcbiAgICBudW1iZXIsXG4gICAgYm9vbCxcbiAgICBieXRlcyxcbiAgICBoYXNoLFxuICAgIGV4aXN0cyxcbiAgICBvdXRwdXQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJvdXRwdXQiLCJleGlzdHMiLCJoYXNoIiwiYnl0ZXMiLCJib29sIiwibnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImIiLCJsZW5ndGhzIiwiVWludDhBcnJheSIsImxlbmd0aCIsImluY2x1ZGVzIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJpbnN0YW5jZSIsImNoZWNrRmluaXNoZWQiLCJkZXN0cm95ZWQiLCJmaW5pc2hlZCIsIm91dCIsIm1pbiIsImFzc2VydCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js":
/*!********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.add = exports.toBig = exports.split = exports.fromBig = void 0;\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nexports.fromBig = fromBig;\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for(let i = 0; i < lst.length; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nexports.split = split;\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l)=>l;\nconst rotr32L = (h, l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\nexports.add = add;\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig: exports.toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\nexports[\"default\"] = u64; //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUNyRSxNQUFNTSxhQUFhQyxPQUFPLEtBQUssS0FBSztBQUNwQyxNQUFNQyxPQUFPRCxPQUFPO0FBQ3BCLCtFQUErRTtBQUMvRSxTQUFTRixRQUFRSSxDQUFDLEVBQUVDLEtBQUssS0FBSztJQUMxQixJQUFJQSxJQUNBLE9BQU87UUFBRUMsR0FBR0MsT0FBT0gsSUFBSUg7UUFBYU8sR0FBR0QsT0FBTyxLQUFNSixPQUFRRjtJQUFZO0lBQzVFLE9BQU87UUFBRUssR0FBR0MsT0FBTyxLQUFNSixPQUFRRixjQUFjO1FBQUdPLEdBQUdELE9BQU9ILElBQUlILGNBQWM7SUFBRTtBQUNwRjtBQUNBTixlQUFlLEdBQUdLO0FBQ2xCLFNBQVNELE1BQU1VLEdBQUcsRUFBRUosS0FBSyxLQUFLO0lBQzFCLElBQUlLLEtBQUssSUFBSUMsWUFBWUYsSUFBSUcsTUFBTTtJQUNuQyxJQUFJQyxLQUFLLElBQUlGLFlBQVlGLElBQUlHLE1BQU07SUFDbkMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFBSztRQUNqQyxNQUFNLEVBQUVSLENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdSLFFBQVFTLEdBQUcsQ0FBQ0ssRUFBRSxFQUFFVDtRQUNqQyxDQUFDSyxFQUFFLENBQUNJLEVBQUUsRUFBRUQsRUFBRSxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUFDUjtZQUFHRTtTQUFFO0lBQzNCO0lBQ0EsT0FBTztRQUFDRTtRQUFJRztLQUFHO0FBQ25CO0FBQ0FsQixhQUFhLEdBQUdJO0FBQ2hCLE1BQU1ELFFBQVEsQ0FBQ1EsR0FBR0UsSUFBTSxPQUFRRixNQUFNLE1BQU1ILE9BQVFELE9BQU9NLE1BQU07QUFDakViLGFBQWEsR0FBR0c7QUFDaEIsdUJBQXVCO0FBQ3ZCLE1BQU1pQixRQUFRLENBQUNULEdBQUdFLEdBQUdRLElBQU1WLE1BQU1VO0FBQ2pDLE1BQU1DLFFBQVEsQ0FBQ1gsR0FBR0UsR0FBR1EsSUFBTSxLQUFPLEtBQUtBLElBQU9SLE1BQU1RO0FBQ3BELG9DQUFvQztBQUNwQyxNQUFNRSxTQUFTLENBQUNaLEdBQUdFLEdBQUdRLElBQU0sTUFBT0EsSUFBTVIsS0FBTSxLQUFLUTtBQUNwRCxNQUFNRyxTQUFTLENBQUNiLEdBQUdFLEdBQUdRLElBQU0sS0FBTyxLQUFLQSxJQUFPUixNQUFNUTtBQUNyRCxnRUFBZ0U7QUFDaEUsTUFBTUksU0FBUyxDQUFDZCxHQUFHRSxHQUFHUSxJQUFNLEtBQU8sS0FBS0EsSUFBT1IsTUFBT1EsSUFBSTtBQUMxRCxNQUFNSyxTQUFTLENBQUNmLEdBQUdFLEdBQUdRLElBQU0sTUFBUUEsSUFBSSxLQUFRUixLQUFNLEtBQUtRO0FBQzNELCtDQUErQztBQUMvQyxNQUFNTSxVQUFVLENBQUNoQixHQUFHRSxJQUFNQTtBQUMxQixNQUFNZSxVQUFVLENBQUNqQixHQUFHRSxJQUFNRjtBQUMxQixtQ0FBbUM7QUFDbkMsTUFBTWtCLFNBQVMsQ0FBQ2xCLEdBQUdFLEdBQUdRLElBQU0sS0FBTUEsSUFBTVIsTUFBTyxLQUFLUTtBQUNwRCxNQUFNUyxTQUFTLENBQUNuQixHQUFHRSxHQUFHUSxJQUFNLEtBQU1BLElBQU1WLE1BQU8sS0FBS1U7QUFDcEQsK0RBQStEO0FBQy9ELE1BQU1VLFNBQVMsQ0FBQ3BCLEdBQUdFLEdBQUdRLElBQU0sS0FBT0EsSUFBSSxLQUFRVixNQUFPLEtBQUtVO0FBQzNELE1BQU1XLFNBQVMsQ0FBQ3JCLEdBQUdFLEdBQUdRLElBQU0sS0FBT0EsSUFBSSxLQUFRUixNQUFPLEtBQUtRO0FBQzNELDhFQUE4RTtBQUM5RSwwRUFBMEU7QUFDMUUsNENBQTRDO0FBQzVDLFNBQVNuQixJQUFJYSxFQUFFLEVBQUVHLEVBQUUsRUFBRWUsRUFBRSxFQUFFQyxFQUFFO0lBQ3ZCLE1BQU1yQixJQUFJLENBQUNLLE9BQU8sS0FBTWdCLENBQUFBLE9BQU87SUFDL0IsT0FBTztRQUFFdkIsR0FBRyxLQUFNc0IsS0FBTSxLQUFLLEtBQUssS0FBTSxLQUFNO1FBQUdwQixHQUFHQSxJQUFJO0lBQUU7QUFDOUQ7QUFDQWIsV0FBVyxHQUFHRTtBQUNkLHFDQUFxQztBQUNyQyxNQUFNaUMsUUFBUSxDQUFDakIsSUFBSWdCLElBQUlFLEtBQU8sQ0FBQ2xCLE9BQU8sS0FBTWdCLENBQUFBLE9BQU8sS0FBTUUsQ0FBQUEsT0FBTztBQUNoRSxNQUFNQyxRQUFRLENBQUNDLEtBQUt2QixJQUFJa0IsSUFBSU0sS0FBTyxLQUFNTixLQUFLTSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDNUUsTUFBTUMsUUFBUSxDQUFDdEIsSUFBSWdCLElBQUlFLElBQUlLLEtBQU8sQ0FBQ3ZCLE9BQU8sS0FBTWdCLENBQUFBLE9BQU8sS0FBTUUsQ0FBQUEsT0FBTyxLQUFNSyxDQUFBQSxPQUFPO0FBQ2pGLE1BQU1DLFFBQVEsQ0FBQ0osS0FBS3ZCLElBQUlrQixJQUFJTSxJQUFJSSxLQUFPLEtBQU1WLEtBQUtNLEtBQUtJLEtBQU0sT0FBTyxLQUFLLEtBQU0sS0FBTTtBQUNyRixNQUFNQyxRQUFRLENBQUMxQixJQUFJZ0IsSUFBSUUsSUFBSUssSUFBSUksS0FBTyxDQUFDM0IsT0FBTyxLQUFNZ0IsQ0FBQUEsT0FBTyxLQUFNRSxDQUFBQSxPQUFPLEtBQU1LLENBQUFBLE9BQU8sS0FBTUksQ0FBQUEsT0FBTztBQUNsRyxNQUFNQyxRQUFRLENBQUNSLEtBQUt2QixJQUFJa0IsSUFBSU0sSUFBSUksSUFBSUksS0FBTyxLQUFNZCxLQUFLTSxLQUFLSSxLQUFLSSxLQUFNLE9BQU8sS0FBSyxLQUFNLEtBQU07QUFDOUYsa0JBQWtCO0FBQ2xCLE1BQU1DLE1BQU07SUFDUjNDO0lBQVNEO0lBQU9ELE9BQU9ILFFBQVFHLEtBQUs7SUFDcENpQjtJQUFPRTtJQUNQQztJQUFRQztJQUFRQztJQUFRQztJQUN4QkM7SUFBU0M7SUFDVEM7SUFBUUM7SUFBUUM7SUFBUUM7SUFDeEI5QjtJQUFLaUM7SUFBT0U7SUFBT0c7SUFBT0U7SUFBT0k7SUFBT0Y7QUFDNUM7QUFDQTVDLGtCQUFlLEdBQUdnRCxLQUNsQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzPzdiMmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZCA9IGV4cG9ydHMudG9CaWcgPSBleHBvcnRzLnNwbGl0ID0gZXhwb3J0cy5mcm9tQmlnID0gdm9pZCAwO1xuY29uc3QgVTMyX01BU0s2NCA9IEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIGwsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKGgsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIGwpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG4vLyBSZW1vdmluZyBcImV4cG9ydFwiIGhhcyA1JSBwZXJmIHBlbmFsdHkgLV8tXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG5leHBvcnRzLmFkZCA9IGFkZDtcbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZzogZXhwb3J0cy50b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZCIsInRvQmlnIiwic3BsaXQiLCJmcm9tQmlnIiwiVTMyX01BU0s2NCIsIkJpZ0ludCIsIl8zMm4iLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsImxzdCIsIkFoIiwiVWludDMyQXJyYXkiLCJsZW5ndGgiLCJBbCIsImkiLCJzaHJTSCIsInMiLCJzaHJTTCIsInJvdHJTSCIsInJvdHJTTCIsInJvdHJCSCIsInJvdHJCTCIsInJvdHIzMkgiLCJyb3RyMzJMIiwicm90bFNIIiwicm90bFNMIiwicm90bEJIIiwicm90bEJMIiwiQmgiLCJCbCIsImFkZDNMIiwiQ2wiLCJhZGQzSCIsImxvdyIsIkNoIiwiYWRkNEwiLCJEbCIsImFkZDRIIiwiRGgiLCJhZGQ1TCIsIkVsIiwiYWRkNUgiLCJFaCIsInU2NCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixvRkFBb0Y7QUFDcEYsNEJBQTRCO0FBQzVCLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2IsTUFBTUcsS0FBS0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDaENKLGNBQWMsR0FBR0csTUFBTSxPQUFPQSxPQUFPLFlBQVksZUFBZUEsS0FBS0EsR0FBR0UsU0FBUyxHQUFHQyxXQUNwRixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzPzBmYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuY29uc3QgbmMgPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG5leHBvcnRzLmNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyeXB0byIsIm5jIiwicmVxdWlyZSIsIndlYmNyeXB0byIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js":
/*!********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js\");\nconst _u64_js_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_u64.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\");\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [\n    [],\n    [],\n    []\n];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta θ\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        _assert_js_1.default.number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error(\"Sha3 supports only keccak-f1600 function\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_js_1.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { blockLen, state } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        _assert_js_1.default.exists(this, false);\n        _assert_js_1.default.bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        _assert_js_1.default.number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        _assert_js_1.default.output(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapConstructor)(()=>new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */ exports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */ exports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen)=>(0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUM5TyxNQUFNYyxlQUFlQyxtQkFBT0EsQ0FBQywyRkFBYztBQUMzQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyxxRkFBVztBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyx1RkFBWTtBQUN2QywyQ0FBMkM7QUFDM0MsTUFBTSxDQUFDRyxTQUFTQyxXQUFXQyxXQUFXLEdBQUc7SUFBQyxFQUFFO0lBQUUsRUFBRTtJQUFFLEVBQUU7Q0FBQztBQUNyRCxNQUFNQyxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLFFBQVFKLE9BQU87QUFDckIsTUFBTUssU0FBU0wsT0FBTztBQUN0QixJQUFLLElBQUlNLFFBQVEsR0FBR0MsSUFBSU4sS0FBS08sSUFBSSxHQUFHQyxJQUFJLEdBQUdILFFBQVEsSUFBSUEsUUFBUztJQUM1RCxLQUFLO0lBQ0wsQ0FBQ0UsR0FBR0MsRUFBRSxHQUFHO1FBQUNBO1FBQUksS0FBSUQsSUFBSSxJQUFJQyxDQUFBQSxJQUFLO0tBQUU7SUFDakNiLFFBQVFjLElBQUksQ0FBQyxJQUFLLEtBQUlELElBQUlELENBQUFBO0lBQzFCLGFBQWE7SUFDYlgsVUFBVWEsSUFBSSxDQUFDLENBQUdKLFFBQVEsS0FBTUEsQ0FB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QG5vYmxlL2hhc2hlcy9zaGEzLmpzP2ZkMzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZXhwb3J0cy5zaGFrZTEyOCA9IGV4cG9ydHMua2VjY2FrXzUxMiA9IGV4cG9ydHMua2VjY2FrXzM4NCA9IGV4cG9ydHMua2VjY2FrXzI1NiA9IGV4cG9ydHMua2VjY2FrXzIyNCA9IGV4cG9ydHMuc2hhM181MTIgPSBleHBvcnRzLnNoYTNfMzg0ID0gZXhwb3J0cy5zaGEzXzI1NiA9IGV4cG9ydHMuc2hhM18yMjQgPSBleHBvcnRzLktlY2NhayA9IGV4cG9ydHMua2VjY2FrUCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gX3U2NF9qc18xLmRlZmF1bHQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCSChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTSChoLCBsLCBzKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCTChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTTChoLCBsLCBzKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5udW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5ieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzaGFrZTI1NiIsInNoYWtlMTI4Iiwia2VjY2FrXzUxMiIsImtlY2Nha18zODQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzIyNCIsInNoYTNfNTEyIiwic2hhM18zODQiLCJzaGEzXzI1NiIsInNoYTNfMjI0IiwiS2VjY2FrIiwia2VjY2FrUCIsIl9hc3NlcnRfanNfMSIsInJlcXVpcmUiLCJfdTY0X2pzXzEiLCJ1dGlsc19qc18xIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsInJvdW5kIiwiUiIsIngiLCJ5IiwicHVzaCIsInQiLCJqIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsImRlZmF1bHQiLCJzcGxpdCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEJIIiwicm90bFNIIiwicm90bEwiLCJyb3RsQkwiLCJyb3RsU0wiLCJyb3VuZHMiLCJCIiwiVWludDMyQXJyYXkiLCJpZHgxIiwiaWR4MCIsIkIwIiwiQjEiLCJUaCIsIlRsIiwiY3VySCIsImN1ckwiLCJzaGlmdCIsIlBJIiwiZmlsbCIsIkhhc2giLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwic3VmZml4Iiwib3V0cHV0TGVuIiwiZW5hYmxlWE9GIiwicG9zIiwicG9zT3V0IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJudW1iZXIiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJ1MzIiLCJrZWNjYWsiLCJ1cGRhdGUiLCJkYXRhIiwiZXhpc3RzIiwidG9CeXRlcyIsImxlbiIsImxlbmd0aCIsInRha2UiLCJNYXRoIiwibWluIiwiaSIsImZpbmlzaCIsIndyaXRlSW50byIsIm91dCIsImJ5dGVzIiwiYnVmZmVyT3V0Iiwic2V0Iiwic3ViYXJyYXkiLCJ4b2ZJbnRvIiwieG9mIiwiZGlnZXN0SW50byIsIm91dHB1dCIsImRlc3Ryb3kiLCJkaWdlc3QiLCJfY2xvbmVJbnRvIiwidG8iLCJnZW4iLCJ3cmFwQ29uc3RydWN0b3IiLCJnZW5TaGFrZSIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwib3B0cyIsImRrTGVuIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/@noble/hashes/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/cryptoNode.js\");\nconst u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!exports.isLE) throw new Error(\"Non little-endian hardware is not supported\");\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\");\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\");\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\" && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== \"object\" || !isPlainObject(opts))) throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n}\nexports.randomBytes = randomBytes; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLG9FQUFvRSxHQUNwRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxrQ0FBa0MsR0FBR0EsK0JBQStCLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBR0EsWUFBWSxHQUFHQSxtQkFBbUIsR0FBR0EsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLFlBQVksR0FBR0EsWUFBWSxHQUFHQSxrQkFBa0IsR0FBR0EsV0FBVyxHQUFHQSxVQUFVLEdBQUcsS0FBSztBQUM1WCxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDhEQUE4RDtBQUM5RCxNQUFNb0IsV0FBV0MsbUJBQU9BLENBQUMsc0dBQXNCO0FBQy9DLE1BQU1DLE1BQU0sQ0FBQ0MsSUFBTUEsYUFBYUM7QUFDaEMsK0JBQStCO0FBQy9CLE1BQU1MLEtBQUssQ0FBQ00sTUFBUSxJQUFJRCxXQUFXQyxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVTtBQUM3RTVCLFVBQVUsR0FBR21CO0FBQ2IsTUFBTUQsTUFBTSxDQUFDTyxNQUFRLElBQUlJLFlBQVlKLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRyxLQUFLQyxLQUFLLENBQUNOLElBQUlHLFVBQVUsR0FBRztBQUM3RjVCLFdBQVcsR0FBR2tCO0FBQ2QscUJBQXFCO0FBQ3JCLE1BQU1ELGFBQWEsQ0FBQ1EsTUFBUSxJQUFJTyxTQUFTUCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVTtBQUNuRjVCLGtCQUFrQixH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QWUsQ0FBQyxJQUFJeEUsV0FBV3NFO0lBQzFEO0lBQ0EsTUFBTSxJQUFJM0QsTUFBTTtBQUNwQjtBQUNBbkMsbUJBQW1CLEdBQUdFLGFBQ3RCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy93ZWIzLXV0aWxzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzP2I3NjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmFzeW5jTG9vcCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydHMuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWV4cG9ydHMuaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0ICgwLCBleHBvcnRzLm5leHRUaWNrKSgpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbmV4cG9ydHMuYXN5bmNMb29wID0gYXN5bmNMb29wO1xuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzO1xuZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyYW5kb21CeXRlcyIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwQ29uc3RydWN0b3IiLCJjaGVja09wdHMiLCJIYXNoIiwiY29uY2F0Qnl0ZXMiLCJ0b0J5dGVzIiwidXRmOFRvQnl0ZXMiLCJhc3luY0xvb3AiLCJuZXh0VGljayIsImhleFRvQnl0ZXMiLCJieXRlc1RvSGV4IiwiaXNMRSIsInJvdHIiLCJjcmVhdGVWaWV3IiwidTMyIiwidTgiLCJjcnlwdG9fMSIsInJlcXVpcmUiLCJ1OGEiLCJhIiwiVWludDhBcnJheSIsImFyciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiVWludDMyQXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJEYXRhVmlldyIsIndvcmQiLCJzaGlmdCIsIkVycm9yIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJ2IiwiaSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlcyIsImhleCIsImxlbiIsImFycmF5IiwiaiIsImhleEJ5dGUiLCJzbGljZSIsImJ5dGUiLCJOdW1iZXIiLCJwYXJzZUludCIsImlzTmFOIiwiaXRlcnMiLCJ0aWNrIiwiY2IiLCJ0cyIsIkRhdGUiLCJub3ciLCJkaWZmIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJkYXRhIiwiYXJyYXlzIiwiciIsInJlZHVjZSIsInN1bSIsInBhZCIsImZvckVhY2giLCJzZXQiLCJjbG9uZSIsIl9jbG9uZUludG8iLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwicHJvdG90eXBlIiwiY2FsbCIsImNvbnN0cnVjdG9yIiwiZGVmYXVsdHMiLCJvcHRzIiwidW5kZWZpbmVkIiwibWVyZ2VkIiwiYXNzaWduIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiY3JlYXRlIiwiYnl0ZXNMZW5ndGgiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js":
/*!******************************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/sha3.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js\");\nexports.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);\nexports.keccak256 = (()=>{\n    const k = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);\n    k.create = sha3_1.keccak_256.create;\n    return k;\n})();\nexports.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);\nexports.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUNyRixNQUFNTSxTQUFTQyxtQkFBT0EsQ0FBQyw4RkFBb0I7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsK0ZBQVk7QUFDdkNQLGlCQUFpQixHQUFHLENBQUMsR0FBR1EsV0FBV0MsUUFBUSxFQUFFSCxPQUFPSSxVQUFVO0FBQzlEVixpQkFBaUIsR0FBRyxDQUFDO0lBQ2pCLE1BQU1XLElBQUksQ0FBQyxHQUFHSCxXQUFXQyxRQUFRLEVBQUVILE9BQU9NLFVBQVU7SUFDcERELEVBQUVFLE1BQU0sR0FBR1AsT0FBT00sVUFBVSxDQUFDQyxNQUFNO0lBQ25DLE9BQU9GO0FBQ1g7QUFDQVgsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHUSxXQUFXQyxRQUFRLEVBQUVILE9BQU9RLFVBQVU7QUFDOURkLGlCQUFpQixHQUFHLENBQUMsR0FBR1EsV0FBV0MsUUFBUSxFQUFFSCxPQUFPUyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3dlYjMtdXRpbHMvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsuanM/NjcwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzX2pzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc19qc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc19qc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJrZWNjYWs1MTIiLCJrZWNjYWszODQiLCJrZWNjYWsyNTYiLCJrZWNjYWsyMjQiLCJzaGEzXzEiLCJyZXF1aXJlIiwidXRpbHNfanNfMSIsIndyYXBIYXNoIiwia2VjY2FrXzIyNCIsImsiLCJrZWNjYWtfMjU2IiwiY3JlYXRlIiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/keccak.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;\nconst _assert_1 = __importDefault(__webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/_assert.js\"));\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\");\nconst assertBool = _assert_1.default.bool;\nexports.assertBool = assertBool;\nconst assertBytes = _assert_1.default.bytes;\nexports.assertBytes = assertBytes;\nvar utils_2 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/web3-utils/node_modules/@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"bytesToHex\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.bytesToHex;\n    }\n}));\nObject.defineProperty(exports, \"toHex\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.bytesToHex;\n    }\n}));\nObject.defineProperty(exports, \"concatBytes\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.concatBytes;\n    }\n}));\nObject.defineProperty(exports, \"createView\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.createView;\n    }\n}));\nObject.defineProperty(exports, \"utf8ToBytes\", ({\n    enumerable: true,\n    get: function() {\n        return utils_2.utf8ToBytes;\n    }\n}));\n// buf.toString('utf8') -> bytesToUtf8(buf)\nfunction bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nexports.bytesToUtf8 = bytesToUtf8;\nfunction hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return (0, utils_1.hexToBytes)(sliced);\n}\nexports.hexToBytes = hexToBytes;\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nfunction equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.equalsBytes = equalsBytes;\n// Internal utils\nfunction wrapHash(hash) {\n    return (msg)=>{\n        _assert_1.default.bytes(msg);\n        return hash(msg);\n    };\n}\nexports.wrapHash = wrapHash;\n// TODO(v3): switch away from node crypto, remove this unnecessary variable.\nexports.crypto = (()=>{\n    const webCrypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n    const nodeRequire =  true && typeof module.require === \"function\" && module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0EsYUFBYSxHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDM1AsTUFBTWMsWUFBWW5CLGdCQUFnQm9CLG1CQUFPQSxDQUFDLG9HQUF1QjtBQUNqRSxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxnR0FBcUI7QUFDN0MsTUFBTUYsYUFBYUMsVUFBVUcsT0FBTyxDQUFDQyxJQUFJO0FBQ3pDbEIsa0JBQWtCLEdBQUdhO0FBQ3JCLE1BQU1ELGNBQWNFLFVBQVVHLE9BQU8sQ0FBQ0UsS0FBSztBQUMzQ25CLG1CQUFtQixHQUFHWTtBQUN0QixJQUFJUSxVQUFVTCxtQkFBT0EsQ0FBQyxnR0FBcUI7QUFDM0NqQiw4Q0FBNkM7SUFBRXVCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFULFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSGIseUNBQXdDO0lBQUV1QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRVCxVQUFVO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUdiLCtDQUE4QztJQUFFdUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsUUFBUVgsV0FBVztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JIWCw4Q0FBNkM7SUFBRXVCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFFBQVFaLFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNuSFYsK0NBQThDO0lBQUV1QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixRQUFRYixXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckgsMkNBQTJDO0FBQzNDLFNBQVNELFlBQVlpQixJQUFJO0lBQ3JCLElBQUksQ0FBRUEsQ0FBQUEsZ0JBQWdCQyxVQUFTLEdBQUk7UUFDL0IsTUFBTSxJQUFJQyxVQUFVLENBQUMscUNBQXFDLEVBQUUsT0FBT0YsS0FBSyxDQUFDO0lBQzdFO0lBQ0EsT0FBTyxJQUFJRyxjQUFjQyxNQUFNLENBQUNKO0FBQ3BDO0FBQ0F2QixtQkFBbUIsR0FBR007QUFDdEIsU0FBU0QsV0FBV2tCLElBQUk7SUFDcEIsTUFBTUssU0FBU0wsS0FBS00sVUFBVSxDQUFDLFFBQVFOLEtBQUtPLFNBQVMsQ0FBQyxLQUFLUDtJQUMzRCxPQUFPLENBQUMsR0FBR1AsUUFBUVgsVUFBVSxFQUFFdUI7QUFDbkM7QUFDQTVCLGtCQUFrQixHQUFHSztBQUNyQiw2Q0FBNkM7QUFDN0MsU0FBU0QsWUFBWTJCLENBQUMsRUFBRUMsQ0FBQztJQUNyQixJQUFJRCxFQUFFRSxNQUFNLEtBQUtELEVBQUVDLE1BQU0sRUFBRTtRQUN2QixPQUFPO0lBQ1g7SUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsRUFBRUUsTUFBTSxFQUFFQyxJQUFLO1FBQy9CLElBQUlILENBQUMsQ0FBQ0csRUFBRSxLQUFLRixDQUFDLENBQUNFLEVBQUUsRUFBRTtZQUNmLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0FsQyxtQkFBbUIsR0FBR0k7QUFDdEIsaUJBQWlCO0FBQ2pCLFNBQVNELFNBQVNnQyxJQUFJO0lBQ2xCLE9BQU8sQ0FBQ0M7UUFDSnRCLFVBQVVHLE9BQU8sQ0FBQ0UsS0FBSyxDQUFDaUI7UUFDeEIsT0FBT0QsS0FBS0M7SUFDaEI7QUFDSjtBQUNBcEMsZ0JBQWdCLEdBQUdHO0FBQ25CLDRFQUE0RTtBQUM1RUgsY0FBYyxHQUFHLENBQUM7SUFDZCxNQUFNcUMsWUFBWSxPQUFPQyxlQUFlLFlBQVksWUFBWUEsYUFBYUEsV0FBV3BDLE1BQU0sR0FBR3FDO0lBQ2pHLE1BQU1DLGNBQWMsS0FBNkIsSUFDN0MsT0FBT0MsT0FBTzFCLE9BQU8sS0FBSyxjQUMxQjBCLE9BQU8xQixPQUFPLENBQUMyQixJQUFJLENBQUNEO0lBQ3hCLE9BQU87UUFDSEUsTUFBTUgsZUFBZSxDQUFDSCxZQUFZRyxZQUFZLFlBQVlEO1FBQzFESyxLQUFLUDtJQUNUO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvd2ViMy11dGlscy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzPzRiY2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IGV4cG9ydHMud3JhcEhhc2ggPSBleHBvcnRzLmVxdWFsc0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvVXRmOCA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0hleCA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuYXNzZXJ0Qnl0ZXMgPSBleHBvcnRzLmFzc2VydEJvb2wgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBhc3NlcnRCb29sID0gX2Fzc2VydF8xLmRlZmF1bHQuYm9vbDtcbmV4cG9ydHMuYXNzZXJ0Qm9vbCA9IGFzc2VydEJvb2w7XG5jb25zdCBhc3NlcnRCeXRlcyA9IF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzO1xuZXhwb3J0cy5hc3NlcnRCeXRlcyA9IGFzc2VydEJ5dGVzO1xudmFyIHV0aWxzXzIgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuYnl0ZXNUb0hleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5jb25jYXRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZpZXdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY3JlYXRlVmlldzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0ZjhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLnV0ZjhUb0J5dGVzOyB9IH0pO1xuLy8gYnVmLnRvU3RyaW5nKCd1dGY4JykgLT4gYnl0ZXNUb1V0ZjgoYnVmKVxuZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoZGF0YSkge1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBieXRlc1RvVXRmOCBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBieXRlc1RvVXRmODtcbmZ1bmN0aW9uIGhleFRvQnl0ZXMoZGF0YSkge1xuICAgIGNvbnN0IHNsaWNlZCA9IGRhdGEuc3RhcnRzV2l0aChcIjB4XCIpID8gZGF0YS5zdWJzdHJpbmcoMikgOiBkYXRhO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShzbGljZWQpO1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIGJ1Zi5lcXVhbHMoYnVmMikgLT4gZXF1YWxzQnl0ZXMoYnVmLCBidWYyKVxuZnVuY3Rpb24gZXF1YWxzQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxzQnl0ZXMgPSBlcXVhbHNCeXRlcztcbi8vIEludGVybmFsIHV0aWxzXG5mdW5jdGlvbiB3cmFwSGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIChtc2cpID0+IHtcbiAgICAgICAgX2Fzc2VydF8xLmRlZmF1bHQuYnl0ZXMobXNnKTtcbiAgICAgICAgcmV0dXJuIGhhc2gobXNnKTtcbiAgICB9O1xufVxuZXhwb3J0cy53cmFwSGFzaCA9IHdyYXBIYXNoO1xuLy8gVE9ETyh2Myk6IHN3aXRjaCBhd2F5IGZyb20gbm9kZSBjcnlwdG8sIHJlbW92ZSB0aGlzIHVubmVjZXNzYXJ5IHZhcmlhYmxlLlxuZXhwb3J0cy5jcnlwdG8gPSAoKCkgPT4ge1xuICAgIGNvbnN0IHdlYkNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vZGVSZXF1aXJlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgbW9kdWxlLnJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBtb2R1bGUucmVxdWlyZS5iaW5kKG1vZHVsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZVJlcXVpcmUgJiYgIXdlYkNyeXB0byA/IG5vZGVSZXF1aXJlKFwiY3J5cHRvXCIpIDogdW5kZWZpbmVkLFxuICAgICAgICB3ZWI6IHdlYkNyeXB0b1xuICAgIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyeXB0byIsIndyYXBIYXNoIiwiZXF1YWxzQnl0ZXMiLCJoZXhUb0J5dGVzIiwiYnl0ZXNUb1V0ZjgiLCJ1dGY4VG9CeXRlcyIsImNyZWF0ZVZpZXciLCJjb25jYXRCeXRlcyIsInRvSGV4IiwiYnl0ZXNUb0hleCIsImFzc2VydEJ5dGVzIiwiYXNzZXJ0Qm9vbCIsIl9hc3NlcnRfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwiZGVmYXVsdCIsImJvb2wiLCJieXRlcyIsInV0aWxzXzIiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGF0YSIsIlVpbnQ4QXJyYXkiLCJUeXBlRXJyb3IiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInNsaWNlZCIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJhIiwiYiIsImxlbmd0aCIsImkiLCJoYXNoIiwibXNnIiwid2ViQ3J5cHRvIiwiZ2xvYmFsVGhpcyIsInVuZGVmaW5lZCIsIm5vZGVSZXF1aXJlIiwibW9kdWxlIiwiYmluZCIsIm5vZGUiLCJ3ZWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-utils/node_modules/ethereum-cryptography/utils.js\n");

/***/ })

};
;